"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@langchain";
exports.ids = ["vendor-chunks/@langchain"];
exports.modules = {

/***/ "(action-browser)/./node_modules/@langchain/core/dist/callbacks/base.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/base.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseCallbackHandler: () => (/* binding */ BaseCallbackHandler)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../load/serializable.js */ \"(action-browser)/./node_modules/@langchain/core/dist/load/serializable.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/env.js */ \"(action-browser)/./node_modules/@langchain/core/dist/utils/env.js\");\n\n\n\n/**\n * Abstract class that provides a set of optional methods that can be\n * overridden in derived classes to handle various events during the\n * execution of a LangChain application.\n */\nclass BaseCallbackHandlerMethodsClass {\n}\n/**\n * Abstract base class for creating callback handlers in the LangChain\n * framework. It provides a set of optional methods that can be overridden\n * in derived classes to handle various events during the execution of a\n * LangChain application.\n */\nclass BaseCallbackHandler extends BaseCallbackHandlerMethodsClass {\n    get lc_namespace() {\n        return [\"langchain_core\", \"callbacks\", this.name];\n    }\n    get lc_secrets() {\n        return undefined;\n    }\n    get lc_attributes() {\n        return undefined;\n    }\n    get lc_aliases() {\n        return undefined;\n    }\n    /**\n     * The name of the serializable. Override to provide an alias or\n     * to preserve the serialized module name in minified environments.\n     *\n     * Implemented as a static method to support loading logic.\n     */\n    static lc_name() {\n        return this.name;\n    }\n    /**\n     * The final serialized identifier for the module.\n     */\n    get lc_id() {\n        return [\n            ...this.lc_namespace,\n            (0,_load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.get_lc_unique_name)(this.constructor),\n        ];\n    }\n    constructor(input) {\n        super();\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ignoreLLM\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreAgent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreRetriever\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"awaitHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_1__.getEnvironmentVariable)(\"LANGCHAIN_CALLBACKS_BACKGROUND\") !== \"true\"\n        });\n        this.lc_kwargs = input || {};\n        if (input) {\n            this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;\n            this.ignoreChain = input.ignoreChain ?? this.ignoreChain;\n            this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;\n            this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;\n            this.awaitHandlers = input._awaitHandler ?? this.awaitHandlers;\n        }\n    }\n    copy() {\n        return new this.constructor(this);\n    }\n    toJSON() {\n        return _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.Serializable.prototype.toJSON.call(this);\n    }\n    toJSONNotImplemented() {\n        return _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.Serializable.prototype.toJSONNotImplemented.call(this);\n    }\n    static fromMethods(methods) {\n        class Handler extends BaseCallbackHandler {\n            constructor() {\n                super();\n                Object.defineProperty(this, \"name\", {\n                    enumerable: true,\n                    configurable: true,\n                    writable: true,\n                    value: uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"]()\n                });\n                Object.assign(this, methods);\n            }\n        }\n        return new Handler();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9jYWxsYmFja3MvYmFzZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZCO0FBQytDO0FBQ25CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlFQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFFQUFzQjtBQUN6QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtEQUFZO0FBQzNCO0FBQ0E7QUFDQSxlQUFlLCtEQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0Q0FBTztBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcY2FsbGJhY2tzXFxiYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV1aWQgZnJvbSBcInV1aWRcIjtcbmltcG9ydCB7IFNlcmlhbGl6YWJsZSwgZ2V0X2xjX3VuaXF1ZV9uYW1lLCB9IGZyb20gXCIuLi9sb2FkL3NlcmlhbGl6YWJsZS5qc1wiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSB9IGZyb20gXCIuLi91dGlscy9lbnYuanNcIjtcbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdGhhdCBwcm92aWRlcyBhIHNldCBvZiBvcHRpb25hbCBtZXRob2RzIHRoYXQgY2FuIGJlXG4gKiBvdmVycmlkZGVuIGluIGRlcml2ZWQgY2xhc3NlcyB0byBoYW5kbGUgdmFyaW91cyBldmVudHMgZHVyaW5nIHRoZVxuICogZXhlY3V0aW9uIG9mIGEgTGFuZ0NoYWluIGFwcGxpY2F0aW9uLlxuICovXG5jbGFzcyBCYXNlQ2FsbGJhY2tIYW5kbGVyTWV0aG9kc0NsYXNzIHtcbn1cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgY3JlYXRpbmcgY2FsbGJhY2sgaGFuZGxlcnMgaW4gdGhlIExhbmdDaGFpblxuICogZnJhbWV3b3JrLiBJdCBwcm92aWRlcyBhIHNldCBvZiBvcHRpb25hbCBtZXRob2RzIHRoYXQgY2FuIGJlIG92ZXJyaWRkZW5cbiAqIGluIGRlcml2ZWQgY2xhc3NlcyB0byBoYW5kbGUgdmFyaW91cyBldmVudHMgZHVyaW5nIHRoZSBleGVjdXRpb24gb2YgYVxuICogTGFuZ0NoYWluIGFwcGxpY2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZUNhbGxiYWNrSGFuZGxlciBleHRlbmRzIEJhc2VDYWxsYmFja0hhbmRsZXJNZXRob2RzQ2xhc3Mge1xuICAgIGdldCBsY19uYW1lc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcImNhbGxiYWNrc1wiLCB0aGlzLm5hbWVdO1xuICAgIH1cbiAgICBnZXQgbGNfc2VjcmV0cygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGxjX2F0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBsY19hbGlhc2VzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgc2VyaWFsaXphYmxlLiBPdmVycmlkZSB0byBwcm92aWRlIGFuIGFsaWFzIG9yXG4gICAgICogdG8gcHJlc2VydmUgdGhlIHNlcmlhbGl6ZWQgbW9kdWxlIG5hbWUgaW4gbWluaWZpZWQgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogSW1wbGVtZW50ZWQgYXMgYSBzdGF0aWMgbWV0aG9kIHRvIHN1cHBvcnQgbG9hZGluZyBsb2dpYy5cbiAgICAgKi9cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpbmFsIHNlcmlhbGl6ZWQgaWRlbnRpZmllciBmb3IgdGhlIG1vZHVsZS5cbiAgICAgKi9cbiAgICBnZXQgbGNfaWQoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi50aGlzLmxjX25hbWVzcGFjZSxcbiAgICAgICAgICAgIGdldF9sY191bmlxdWVfbmFtZSh0aGlzLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfa3dhcmdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlnbm9yZUxMTVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlnbm9yZUNoYWluXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWdub3JlQWdlbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZ25vcmVSZXRyaWV2ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhd2FpdEhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0NBTExCQUNLU19CQUNLR1JPVU5EXCIpICE9PSBcInRydWVcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sY19rd2FyZ3MgPSBpbnB1dCB8fCB7fTtcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUxMTSA9IGlucHV0Lmlnbm9yZUxMTSA/PyB0aGlzLmlnbm9yZUxMTTtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlQ2hhaW4gPSBpbnB1dC5pZ25vcmVDaGFpbiA/PyB0aGlzLmlnbm9yZUNoYWluO1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVBZ2VudCA9IGlucHV0Lmlnbm9yZUFnZW50ID8/IHRoaXMuaWdub3JlQWdlbnQ7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZVJldHJpZXZlciA9IGlucHV0Lmlnbm9yZVJldHJpZXZlciA/PyB0aGlzLmlnbm9yZVJldHJpZXZlcjtcbiAgICAgICAgICAgIHRoaXMuYXdhaXRIYW5kbGVycyA9IGlucHV0Ll9hd2FpdEhhbmRsZXIgPz8gdGhpcy5hd2FpdEhhbmRsZXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gU2VyaWFsaXphYmxlLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgdG9KU09OTm90SW1wbGVtZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiBTZXJpYWxpemFibGUucHJvdG90eXBlLnRvSlNPTk5vdEltcGxlbWVudGVkLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTWV0aG9kcyhtZXRob2RzKSB7XG4gICAgICAgIGNsYXNzIEhhbmRsZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tIYW5kbGVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1dWlkLnY0KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG1ldGhvZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGFuZGxlcigpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/callbacks/base.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/callbacks/manager.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/manager.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseCallbackManager: () => (/* binding */ BaseCallbackManager),\n/* harmony export */   CallbackManager: () => (/* binding */ CallbackManager),\n/* harmony export */   CallbackManagerForChainRun: () => (/* binding */ CallbackManagerForChainRun),\n/* harmony export */   CallbackManagerForLLMRun: () => (/* binding */ CallbackManagerForLLMRun),\n/* harmony export */   CallbackManagerForRetrieverRun: () => (/* binding */ CallbackManagerForRetrieverRun),\n/* harmony export */   CallbackManagerForToolRun: () => (/* binding */ CallbackManagerForToolRun),\n/* harmony export */   TraceGroup: () => (/* binding */ TraceGroup),\n/* harmony export */   ensureHandler: () => (/* binding */ ensureHandler),\n/* harmony export */   parseCallbackConfigArg: () => (/* binding */ parseCallbackConfigArg),\n/* harmony export */   traceAsGroup: () => (/* binding */ traceAsGroup)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! uuid */ \"(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/core/dist/callbacks/base.js\");\n/* harmony import */ var _tracers_console_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tracers/console.js */ \"(action-browser)/./node_modules/@langchain/core/dist/tracers/console.js\");\n/* harmony import */ var _tracers_initialize_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tracers/initialize.js */ \"(action-browser)/./node_modules/@langchain/core/dist/tracers/initialize.js\");\n/* harmony import */ var _messages_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../messages/index.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/index.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/env.js */ \"(action-browser)/./node_modules/@langchain/core/dist/utils/env.js\");\n/* harmony import */ var _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tracers/tracer_langchain.js */ \"(action-browser)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.js\");\n/* harmony import */ var _promises_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./promises.js */ \"(action-browser)/./node_modules/@langchain/core/dist/callbacks/promises.js\");\n\n\n\n\n\n\n\n\nif (\n/* #__PURE__ */ (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(\"LANGCHAIN_TRACING_V2\") === \"true\" &&\n    /* #__PURE__ */ (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(\"LANGCHAIN_CALLBACKS_BACKGROUND\") !==\n        \"true\") {\n    /* #__PURE__ */ console.warn([\n        \"[WARN]: You have enabled LangSmith tracing without backgrounding callbacks.\",\n        \"[WARN]: If you are not using a serverless environment where you must wait for tracing calls to finish,\",\n        `[WARN]: we suggest setting \"process.env.LANGCHAIN_CALLBACKS_BACKGROUND=true\" to avoid additional latency.`,\n    ].join(\"\\n\"));\n}\nfunction parseCallbackConfigArg(arg) {\n    if (!arg) {\n        return {};\n    }\n    else if (Array.isArray(arg) || \"name\" in arg) {\n        return { callbacks: arg };\n    }\n    else {\n        return arg;\n    }\n}\n/**\n * Manage callbacks from different components of LangChain.\n */\nclass BaseCallbackManager {\n    setHandler(handler) {\n        return this.setHandlers([handler]);\n    }\n}\n/**\n * Base class for run manager in LangChain.\n */\nclass BaseRunManager {\n    constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {\n        Object.defineProperty(this, \"runId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: runId\n        });\n        Object.defineProperty(this, \"handlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: handlers\n        });\n        Object.defineProperty(this, \"inheritableHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableHandlers\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: tags\n        });\n        Object.defineProperty(this, \"inheritableTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableTags\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: metadata\n        });\n        Object.defineProperty(this, \"inheritableMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableMetadata\n        });\n        Object.defineProperty(this, \"_parentRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _parentRunId\n        });\n    }\n    async handleText(text) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_6__.consumeCallback)(async () => {\n            try {\n                await handler.handleText?.(text, this.runId, this._parentRunId, this.tags);\n            }\n            catch (err) {\n                console.error(`Error in handler ${handler.constructor.name}, handleText: ${err}`);\n            }\n        }, handler.awaitHandlers)));\n    }\n}\n/**\n * Manages callbacks for retriever runs.\n */\nclass CallbackManagerForRetrieverRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleRetrieverEnd(documents) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_6__.consumeCallback)(async () => {\n            if (!handler.ignoreRetriever) {\n                try {\n                    await handler.handleRetrieverEnd?.(documents, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    console.error(`Error in handler ${handler.constructor.name}, handleRetriever`);\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleRetrieverError(err) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_6__.consumeCallback)(async () => {\n            if (!handler.ignoreRetriever) {\n                try {\n                    await handler.handleRetrieverError?.(err, this.runId, this._parentRunId, this.tags);\n                }\n                catch (error) {\n                    console.error(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nclass CallbackManagerForLLMRun extends BaseRunManager {\n    async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_6__.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMNewToken?.(token, idx ?? { prompt: 0, completion: 0 }, this.runId, this._parentRunId, this.tags, fields);\n                }\n                catch (err) {\n                    console.error(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleLLMError(err) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_6__.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMError?.(err, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    console.error(`Error in handler ${handler.constructor.name}, handleLLMError: ${err}`);\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleLLMEnd(output) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_6__.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMEnd?.(output, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    console.error(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nclass CallbackManagerForChainRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_6__.consumeCallback)(async () => {\n            if (!handler.ignoreChain) {\n                try {\n                    await handler.handleChainError?.(err, this.runId, this._parentRunId, this.tags, kwargs);\n                }\n                catch (err) {\n                    console.error(`Error in handler ${handler.constructor.name}, handleChainError: ${err}`);\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_6__.consumeCallback)(async () => {\n            if (!handler.ignoreChain) {\n                try {\n                    await handler.handleChainEnd?.(output, this.runId, this._parentRunId, this.tags, kwargs);\n                }\n                catch (err) {\n                    console.error(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleAgentAction(action) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_6__.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleAgentAction?.(action, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    console.error(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleAgentEnd(action) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_6__.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleAgentEnd?.(action, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    console.error(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nclass CallbackManagerForToolRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleToolError(err) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_6__.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleToolError?.(err, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    console.error(`Error in handler ${handler.constructor.name}, handleToolError: ${err}`);\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleToolEnd(output) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_6__.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleToolEnd?.(output, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    console.error(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\n/**\n * @example\n * ```typescript\n * const prompt = PromptTemplate.fromTemplate(\"What is the answer to {question}?\");\n *\n * // Example of using LLMChain with OpenAI and a simple prompt\n * const chain = new LLMChain({\n *   llm: new ChatOpenAI({ temperature: 0.9 }),\n *   prompt,\n * });\n *\n * // Running the chain with a single question\n * const result = await chain.call({\n *   question: \"What is the airspeed velocity of an unladen swallow?\",\n * });\n * console.log(\"The answer is:\", result);\n * ```\n */\nclass CallbackManager extends BaseCallbackManager {\n    constructor(parentRunId, options) {\n        super();\n        Object.defineProperty(this, \"handlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"inheritableHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"inheritableTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"inheritableMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"callback_manager\"\n        });\n        Object.defineProperty(this, \"_parentRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.handlers = options?.handlers ?? this.handlers;\n        this.inheritableHandlers =\n            options?.inheritableHandlers ?? this.inheritableHandlers;\n        this.tags = options?.tags ?? this.tags;\n        this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;\n        this.metadata = options?.metadata ?? this.metadata;\n        this.inheritableMetadata =\n            options?.inheritableMetadata ?? this.inheritableMetadata;\n        this._parentRunId = parentRunId;\n    }\n    /**\n     * Gets the parent run ID, if any.\n     *\n     * @returns The parent run ID.\n     */\n    getParentRunId() {\n        return this._parentRunId;\n    }\n    async handleLLMStart(llm, prompts, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        return Promise.all(prompts.map(async (prompt, idx) => {\n            // Can't have duplicate runs with the same run ID (if provided)\n            const runId_ = idx === 0 && runId ? runId : (0,uuid__WEBPACK_IMPORTED_MODULE_7__[\"default\"])();\n            await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_6__.consumeCallback)(async () => {\n                if (!handler.ignoreLLM) {\n                    try {\n                        await handler.handleLLMStart?.(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                    }\n                    catch (err) {\n                        console.error(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n                    }\n                }\n            }, handler.awaitHandlers)));\n            return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n        }));\n    }\n    async handleChatModelStart(llm, messages, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        return Promise.all(messages.map(async (messageGroup, idx) => {\n            // Can't have duplicate runs with the same run ID (if provided)\n            const runId_ = idx === 0 && runId ? runId : (0,uuid__WEBPACK_IMPORTED_MODULE_7__[\"default\"])();\n            await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_6__.consumeCallback)(async () => {\n                if (!handler.ignoreLLM) {\n                    try {\n                        if (handler.handleChatModelStart) {\n                            await handler.handleChatModelStart?.(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                        }\n                        else if (handler.handleLLMStart) {\n                            const messageString = (0,_messages_index_js__WEBPACK_IMPORTED_MODULE_3__.getBufferString)(messageGroup);\n                            await handler.handleLLMStart?.(llm, [messageString], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                        }\n                    }\n                    catch (err) {\n                        console.error(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n                    }\n                }\n            }, handler.awaitHandlers)));\n            return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n        }));\n    }\n    async handleChainStart(chain, inputs, runId = (0,uuid__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(), runType = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_6__.consumeCallback)(async () => {\n            if (!handler.ignoreChain) {\n                try {\n                    await handler.handleChainStart?.(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);\n                }\n                catch (err) {\n                    console.error(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);\n                }\n            }\n        }, handler.awaitHandlers)));\n        return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleToolStart(tool, input, runId = (0,uuid__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_6__.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleToolStart?.(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);\n                }\n                catch (err) {\n                    console.error(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);\n                }\n            }\n        }, handler.awaitHandlers)));\n        return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleRetrieverStart(retriever, query, runId = (0,uuid__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_6__.consumeCallback)(async () => {\n            if (!handler.ignoreRetriever) {\n                try {\n                    await handler.handleRetrieverStart?.(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);\n                }\n                catch (err) {\n                    console.error(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);\n                }\n            }\n        }, handler.awaitHandlers)));\n        return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    addHandler(handler, inherit = true) {\n        this.handlers.push(handler);\n        if (inherit) {\n            this.inheritableHandlers.push(handler);\n        }\n    }\n    removeHandler(handler) {\n        this.handlers = this.handlers.filter((_handler) => _handler !== handler);\n        this.inheritableHandlers = this.inheritableHandlers.filter((_handler) => _handler !== handler);\n    }\n    setHandlers(handlers, inherit = true) {\n        this.handlers = [];\n        this.inheritableHandlers = [];\n        for (const handler of handlers) {\n            this.addHandler(handler, inherit);\n        }\n    }\n    addTags(tags, inherit = true) {\n        this.removeTags(tags); // Remove duplicates\n        this.tags.push(...tags);\n        if (inherit) {\n            this.inheritableTags.push(...tags);\n        }\n    }\n    removeTags(tags) {\n        this.tags = this.tags.filter((tag) => !tags.includes(tag));\n        this.inheritableTags = this.inheritableTags.filter((tag) => !tags.includes(tag));\n    }\n    addMetadata(metadata, inherit = true) {\n        this.metadata = { ...this.metadata, ...metadata };\n        if (inherit) {\n            this.inheritableMetadata = { ...this.inheritableMetadata, ...metadata };\n        }\n    }\n    removeMetadata(metadata) {\n        for (const key of Object.keys(metadata)) {\n            delete this.metadata[key];\n            delete this.inheritableMetadata[key];\n        }\n    }\n    copy(additionalHandlers = [], inherit = true) {\n        const manager = new CallbackManager(this._parentRunId);\n        for (const handler of this.handlers) {\n            const inheritable = this.inheritableHandlers.includes(handler);\n            manager.addHandler(handler, inheritable);\n        }\n        for (const tag of this.tags) {\n            const inheritable = this.inheritableTags.includes(tag);\n            manager.addTags([tag], inheritable);\n        }\n        for (const key of Object.keys(this.metadata)) {\n            const inheritable = Object.keys(this.inheritableMetadata).includes(key);\n            manager.addMetadata({ [key]: this.metadata[key] }, inheritable);\n        }\n        for (const handler of additionalHandlers) {\n            if (\n            // Prevent multiple copies of console_callback_handler\n            manager.handlers\n                .filter((h) => h.name === \"console_callback_handler\")\n                .some((h) => h.name === handler.name)) {\n                continue;\n            }\n            manager.addHandler(handler, inherit);\n        }\n        return manager;\n    }\n    static fromHandlers(handlers) {\n        class Handler extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseCallbackHandler {\n            constructor() {\n                super();\n                Object.defineProperty(this, \"name\", {\n                    enumerable: true,\n                    configurable: true,\n                    writable: true,\n                    value: (0,uuid__WEBPACK_IMPORTED_MODULE_7__[\"default\"])()\n                });\n                Object.assign(this, handlers);\n            }\n        }\n        const manager = new this();\n        manager.addHandler(new Handler());\n        return manager;\n    }\n    static async configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {\n        let callbackManager;\n        if (inheritableHandlers || localHandlers) {\n            if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {\n                callbackManager = new CallbackManager();\n                callbackManager.setHandlers(inheritableHandlers?.map(ensureHandler) ?? [], true);\n            }\n            else {\n                callbackManager = inheritableHandlers;\n            }\n            callbackManager = callbackManager.copy(Array.isArray(localHandlers)\n                ? localHandlers.map(ensureHandler)\n                : localHandlers?.handlers, false);\n        }\n        const verboseEnabled = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(\"LANGCHAIN_VERBOSE\") === \"true\" ||\n            options?.verbose;\n        const tracingV2Enabled = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(\"LANGCHAIN_TRACING_V2\") === \"true\";\n        const tracingEnabled = tracingV2Enabled ||\n            ((0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(\"LANGCHAIN_TRACING\") ?? false);\n        if (verboseEnabled || tracingEnabled) {\n            if (!callbackManager) {\n                callbackManager = new CallbackManager();\n            }\n            if (verboseEnabled &&\n                !callbackManager.handlers.some((handler) => handler.name === _tracers_console_js__WEBPACK_IMPORTED_MODULE_1__.ConsoleCallbackHandler.prototype.name)) {\n                const consoleHandler = new _tracers_console_js__WEBPACK_IMPORTED_MODULE_1__.ConsoleCallbackHandler();\n                callbackManager.addHandler(consoleHandler, true);\n            }\n            if (tracingEnabled &&\n                !callbackManager.handlers.some((handler) => handler.name === \"langchain_tracer\")) {\n                if (tracingV2Enabled) {\n                    callbackManager.addHandler(await (0,_tracers_initialize_js__WEBPACK_IMPORTED_MODULE_2__.getTracingV2CallbackHandler)(), true);\n                }\n            }\n        }\n        if (inheritableTags || localTags) {\n            if (callbackManager) {\n                callbackManager.addTags(inheritableTags ?? []);\n                callbackManager.addTags(localTags ?? [], false);\n            }\n        }\n        if (inheritableMetadata || localMetadata) {\n            if (callbackManager) {\n                callbackManager.addMetadata(inheritableMetadata ?? {});\n                callbackManager.addMetadata(localMetadata ?? {}, false);\n            }\n        }\n        return callbackManager;\n    }\n}\nfunction ensureHandler(handler) {\n    if (\"name\" in handler) {\n        return handler;\n    }\n    return _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseCallbackHandler.fromMethods(handler);\n}\n/**\n * @example\n * ```typescript\n * const prompt = PromptTemplate.fromTemplate(`What is the answer to {question}?`);\n *\n * // Example of using LLMChain to process a series of questions\n * const chain = new LLMChain({\n *   llm: new ChatOpenAI({ temperature: 0.9 }),\n *   prompt,\n * });\n *\n * // Process questions using the chain\n * const processQuestions = async (questions) => {\n *   for (const question of questions) {\n *     const result = await chain.call({ question });\n *     console.log(result);\n *   }\n * };\n *\n * // Example questions\n * const questions = [\n *   \"What is your name?\",\n *   \"What is your quest?\",\n *   \"What is your favorite color?\",\n * ];\n *\n * // Run the example\n * processQuestions(questions).catch(console.error);\n *\n * ```\n */\nclass TraceGroup {\n    constructor(groupName, options) {\n        Object.defineProperty(this, \"groupName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: groupName\n        });\n        Object.defineProperty(this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: options\n        });\n        Object.defineProperty(this, \"runManager\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    async getTraceGroupCallbackManager(group_name, inputs, options) {\n        const cb = new _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_5__.LangChainTracer(options);\n        const cm = await CallbackManager.configure([cb]);\n        const runManager = await cm?.handleChainStart({\n            lc: 1,\n            type: \"not_implemented\",\n            id: [\"langchain\", \"callbacks\", \"groups\", group_name],\n        }, inputs ?? {});\n        if (!runManager) {\n            throw new Error(\"Failed to create run group callback manager.\");\n        }\n        return runManager;\n    }\n    async start(inputs) {\n        if (!this.runManager) {\n            this.runManager = await this.getTraceGroupCallbackManager(this.groupName, inputs, this.options);\n        }\n        return this.runManager.getChild();\n    }\n    async error(err) {\n        if (this.runManager) {\n            await this.runManager.handleChainError(err);\n            this.runManager = undefined;\n        }\n    }\n    async end(output) {\n        if (this.runManager) {\n            await this.runManager.handleChainEnd(output ?? {});\n            this.runManager = undefined;\n        }\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function traceAsGroup(groupOptions, enclosedCode, ...args) {\n    const traceGroup = new TraceGroup(groupOptions.name, groupOptions);\n    const callbackManager = await traceGroup.start({ ...args });\n    try {\n        const result = await enclosedCode(callbackManager, ...args);\n        await traceGroup.end(_coerceToDict(result, \"output\"));\n        return result;\n    }\n    catch (err) {\n        await traceGroup.error(err);\n        throw err;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9jYWxsYmFja3MvbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDYTtBQUNjO0FBQ1E7QUFDaEI7QUFDRTtBQUNTO0FBQ2xCO0FBQ2hEO0FBQ0EsZ0JBQWdCLHFFQUFzQjtBQUN0QyxvQkFBb0IscUVBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlEQUF5RCw2REFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx5QkFBeUIsZ0JBQWdCLElBQUk7QUFDL0Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDZEQUFlO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QseUJBQXlCO0FBQy9FO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlEQUF5RCw2REFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlCQUF5QiwwQkFBMEIsTUFBTTtBQUMvRztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0EseURBQXlELDZEQUFlO0FBQ3hFO0FBQ0E7QUFDQSxzRUFBc0UsMEJBQTBCO0FBQ2hHO0FBQ0E7QUFDQSxzREFBc0QseUJBQXlCLHVCQUF1QixJQUFJO0FBQzFHO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlEQUF5RCw2REFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlCQUF5QixvQkFBb0IsSUFBSTtBQUN2RztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5REFBeUQsNkRBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5QkFBeUIsa0JBQWtCLElBQUk7QUFDckc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsNkRBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5QkFBeUIsc0JBQXNCLElBQUk7QUFDekc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseURBQXlELDZEQUFlO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QseUJBQXlCLG9CQUFvQixJQUFJO0FBQ3ZHO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlEQUF5RCw2REFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlCQUF5Qix1QkFBdUIsSUFBSTtBQUMxRztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5REFBeUQsNkRBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5QkFBeUIsb0JBQW9CLElBQUk7QUFDdkc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsNkRBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5QkFBeUIscUJBQXFCLElBQUk7QUFDeEc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseURBQXlELDZEQUFlO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QseUJBQXlCLG1CQUFtQixJQUFJO0FBQ3RHO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxTQUFTO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnREFBTTtBQUM5RCw2REFBNkQsNkRBQWU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx5QkFBeUIsb0JBQW9CLElBQUk7QUFDM0c7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnREFBTTtBQUM5RCw2REFBNkQsNkRBQWU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG1FQUFlO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHlCQUF5QixvQkFBb0IsSUFBSTtBQUMzRztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0RBQWtELGdEQUFNO0FBQ3hELHlEQUF5RCw2REFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlCQUF5QixzQkFBc0IsSUFBSTtBQUN6RztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwrQ0FBK0MsZ0RBQU07QUFDckQseURBQXlELDZEQUFlO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QseUJBQXlCLHFCQUFxQixJQUFJO0FBQ3hHO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlEQUF5RCxnREFBTTtBQUMvRCx5REFBeUQsNkRBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5QkFBeUIsMEJBQTBCLElBQUk7QUFDN0c7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMkJBQTJCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseURBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnREFBTTtBQUNqQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFFQUFzQjtBQUNyRDtBQUNBLGlDQUFpQyxxRUFBc0I7QUFDdkQ7QUFDQSxhQUFhLHFFQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHVFQUFzQjtBQUNuRywyQ0FBMkMsdUVBQXNCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsbUZBQTJCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckUsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVcseURBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFNBQVM7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxVQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1QkFBdUIseUVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsY0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxjYWxsYmFja3NcXG1hbmFnZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSBcInV1aWRcIjtcbmltcG9ydCB7IEJhc2VDYWxsYmFja0hhbmRsZXIsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgQ29uc29sZUNhbGxiYWNrSGFuZGxlciB9IGZyb20gXCIuLi90cmFjZXJzL2NvbnNvbGUuanNcIjtcbmltcG9ydCB7IGdldFRyYWNpbmdWMkNhbGxiYWNrSGFuZGxlciB9IGZyb20gXCIuLi90cmFjZXJzL2luaXRpYWxpemUuanNcIjtcbmltcG9ydCB7IGdldEJ1ZmZlclN0cmluZyB9IGZyb20gXCIuLi9tZXNzYWdlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSB9IGZyb20gXCIuLi91dGlscy9lbnYuanNcIjtcbmltcG9ydCB7IExhbmdDaGFpblRyYWNlciwgfSBmcm9tIFwiLi4vdHJhY2Vycy90cmFjZXJfbGFuZ2NoYWluLmpzXCI7XG5pbXBvcnQgeyBjb25zdW1lQ2FsbGJhY2sgfSBmcm9tIFwiLi9wcm9taXNlcy5qc1wiO1xuaWYgKFxuLyogI19fUFVSRV9fICovIGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fVFJBQ0lOR19WMlwiKSA9PT0gXCJ0cnVlXCIgJiZcbiAgICAvKiAjX19QVVJFX18gKi8gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9DQUxMQkFDS1NfQkFDS0dST1VORFwiKSAhPT1cbiAgICAgICAgXCJ0cnVlXCIpIHtcbiAgICAvKiAjX19QVVJFX18gKi8gY29uc29sZS53YXJuKFtcbiAgICAgICAgXCJbV0FSTl06IFlvdSBoYXZlIGVuYWJsZWQgTGFuZ1NtaXRoIHRyYWNpbmcgd2l0aG91dCBiYWNrZ3JvdW5kaW5nIGNhbGxiYWNrcy5cIixcbiAgICAgICAgXCJbV0FSTl06IElmIHlvdSBhcmUgbm90IHVzaW5nIGEgc2VydmVybGVzcyBlbnZpcm9ubWVudCB3aGVyZSB5b3UgbXVzdCB3YWl0IGZvciB0cmFjaW5nIGNhbGxzIHRvIGZpbmlzaCxcIixcbiAgICAgICAgYFtXQVJOXTogd2Ugc3VnZ2VzdCBzZXR0aW5nIFwicHJvY2Vzcy5lbnYuTEFOR0NIQUlOX0NBTExCQUNLU19CQUNLR1JPVU5EPXRydWVcIiB0byBhdm9pZCBhZGRpdGlvbmFsIGxhdGVuY3kuYCxcbiAgICBdLmpvaW4oXCJcXG5cIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ2FsbGJhY2tDb25maWdBcmcoYXJnKSB7XG4gICAgaWYgKCFhcmcpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgfHwgXCJuYW1lXCIgaW4gYXJnKSB7XG4gICAgICAgIHJldHVybiB7IGNhbGxiYWNrczogYXJnIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbn1cbi8qKlxuICogTWFuYWdlIGNhbGxiYWNrcyBmcm9tIGRpZmZlcmVudCBjb21wb25lbnRzIG9mIExhbmdDaGFpbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VDYWxsYmFja01hbmFnZXIge1xuICAgIHNldEhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRIYW5kbGVycyhbaGFuZGxlcl0pO1xuICAgIH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgcnVuIG1hbmFnZXIgaW4gTGFuZ0NoYWluLlxuICovXG5jbGFzcyBCYXNlUnVuTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IocnVuSWQsIGhhbmRsZXJzLCBpbmhlcml0YWJsZUhhbmRsZXJzLCB0YWdzLCBpbmhlcml0YWJsZVRhZ3MsIG1ldGFkYXRhLCBpbmhlcml0YWJsZU1ldGFkYXRhLCBfcGFyZW50UnVuSWQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVuSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHJ1bklkXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogaGFuZGxlcnNcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlSGFuZGxlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGluaGVyaXRhYmxlSGFuZGxlcnNcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRhZ3NcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogaW5oZXJpdGFibGVUYWdzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlTWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGluaGVyaXRhYmxlTWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wYXJlbnRSdW5JZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogX3BhcmVudFJ1bklkXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUZXh0KHRleHQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlVGV4dD8uKHRleHQsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVUZXh0OiAke2Vycn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbn1cbi8qKlxuICogTWFuYWdlcyBjYWxsYmFja3MgZm9yIHJldHJpZXZlciBydW5zLlxuICovXG5leHBvcnQgY2xhc3MgQ2FsbGJhY2tNYW5hZ2VyRm9yUmV0cmlldmVyUnVuIGV4dGVuZHMgQmFzZVJ1bk1hbmFnZXIge1xuICAgIGdldENoaWxkKHRhZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHRoaXMucnVuSWQpO1xuICAgICAgICBtYW5hZ2VyLnNldEhhbmRsZXJzKHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycyk7XG4gICAgICAgIG1hbmFnZXIuYWRkVGFncyh0aGlzLmluaGVyaXRhYmxlVGFncyk7XG4gICAgICAgIG1hbmFnZXIuYWRkTWV0YWRhdGEodGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhKTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgbWFuYWdlci5hZGRUYWdzKFt0YWddLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlckVuZChkb2N1bWVudHMpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlUmV0cmlldmVyKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVSZXRyaWV2ZXJFbmQ/Lihkb2N1bWVudHMsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVSZXRyaWV2ZXJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmV0cmlldmVyRXJyb3IoZXJyKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZVJldHJpZXZlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlUmV0cmlldmVyRXJyb3I/LihlcnIsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVJldHJpZXZlckVycm9yOiAke2Vycm9yfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDYWxsYmFja01hbmFnZXJGb3JMTE1SdW4gZXh0ZW5kcyBCYXNlUnVuTWFuYWdlciB7XG4gICAgYXN5bmMgaGFuZGxlTExNTmV3VG9rZW4odG9rZW4sIGlkeCwgX3J1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBmaWVsZHMpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlTExNKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVMTE1OZXdUb2tlbj8uKHRva2VuLCBpZHggPz8geyBwcm9tcHQ6IDAsIGNvbXBsZXRpb246IDAgfSwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywgZmllbGRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlTExNTmV3VG9rZW46ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVMTE1FcnJvcihlcnIpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlTExNKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVMTE1FcnJvcj8uKGVyciwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTUVycm9yOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNRW5kKG91dHB1dCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVMTE0pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUxMTUVuZD8uKG91dHB1dCwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTUVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENhbGxiYWNrTWFuYWdlckZvckNoYWluUnVuIGV4dGVuZHMgQmFzZVJ1bk1hbmFnZXIge1xuICAgIGdldENoaWxkKHRhZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHRoaXMucnVuSWQpO1xuICAgICAgICBtYW5hZ2VyLnNldEhhbmRsZXJzKHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycyk7XG4gICAgICAgIG1hbmFnZXIuYWRkVGFncyh0aGlzLmluaGVyaXRhYmxlVGFncyk7XG4gICAgICAgIG1hbmFnZXIuYWRkTWV0YWRhdGEodGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhKTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgbWFuYWdlci5hZGRUYWdzKFt0YWddLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluRXJyb3IoZXJyLCBfcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGt3YXJncykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVDaGFpbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQ2hhaW5FcnJvcj8uKGVyciwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywga3dhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQ2hhaW5FcnJvcjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluRW5kKG91dHB1dCwgX3J1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBrd2FyZ3MpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQ2hhaW4pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUNoYWluRW5kPy4ob3V0cHV0LCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCBrd2FyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDaGFpbkVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUFnZW50QWN0aW9uKGFjdGlvbikge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVBZ2VudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQWdlbnRBY3Rpb24/LihhY3Rpb24sIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVBZ2VudEFjdGlvbjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUFnZW50RW5kKGFjdGlvbikge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVBZ2VudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQWdlbnRFbmQ/LihhY3Rpb24sIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVBZ2VudEVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENhbGxiYWNrTWFuYWdlckZvclRvb2xSdW4gZXh0ZW5kcyBCYXNlUnVuTWFuYWdlciB7XG4gICAgZ2V0Q2hpbGQodGFnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIodGhpcy5ydW5JZCk7XG4gICAgICAgIG1hbmFnZXIuc2V0SGFuZGxlcnModGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzKTtcbiAgICAgICAgbWFuYWdlci5hZGRUYWdzKHRoaXMuaW5oZXJpdGFibGVUYWdzKTtcbiAgICAgICAgbWFuYWdlci5hZGRNZXRhZGF0YSh0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEpO1xuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICBtYW5hZ2VyLmFkZFRhZ3MoW3RhZ10sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFuYWdlcjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVG9vbEVycm9yKGVycikge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVBZ2VudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlVG9vbEVycm9yPy4oZXJyLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlVG9vbEVycm9yOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVG9vbEVuZChvdXRwdXQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVRvb2xFbmQ/LihvdXRwdXQsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVUb29sRW5kOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBwcm9tcHQgPSBQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoXCJXaGF0IGlzIHRoZSBhbnN3ZXIgdG8ge3F1ZXN0aW9ufT9cIik7XG4gKlxuICogLy8gRXhhbXBsZSBvZiB1c2luZyBMTE1DaGFpbiB3aXRoIE9wZW5BSSBhbmQgYSBzaW1wbGUgcHJvbXB0XG4gKiBjb25zdCBjaGFpbiA9IG5ldyBMTE1DaGFpbih7XG4gKiAgIGxsbTogbmV3IENoYXRPcGVuQUkoeyB0ZW1wZXJhdHVyZTogMC45IH0pLFxuICogICBwcm9tcHQsXG4gKiB9KTtcbiAqXG4gKiAvLyBSdW5uaW5nIHRoZSBjaGFpbiB3aXRoIGEgc2luZ2xlIHF1ZXN0aW9uXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGFpbi5jYWxsKHtcbiAqICAgcXVlc3Rpb246IFwiV2hhdCBpcyB0aGUgYWlyc3BlZWQgdmVsb2NpdHkgb2YgYW4gdW5sYWRlbiBzd2FsbG93P1wiLFxuICogfSk7XG4gKiBjb25zb2xlLmxvZyhcIlRoZSBhbnN3ZXIgaXM6XCIsIHJlc3VsdCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIENhbGxiYWNrTWFuYWdlciBleHRlbmRzIEJhc2VDYWxsYmFja01hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFJ1bklkLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5oZXJpdGFibGVIYW5kbGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlTWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImNhbGxiYWNrX21hbmFnZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BhcmVudFJ1bklkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBvcHRpb25zPy5oYW5kbGVycyA/PyB0aGlzLmhhbmRsZXJzO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMgPVxuICAgICAgICAgICAgb3B0aW9ucz8uaW5oZXJpdGFibGVIYW5kbGVycyA/PyB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnM7XG4gICAgICAgIHRoaXMudGFncyA9IG9wdGlvbnM/LnRhZ3MgPz8gdGhpcy50YWdzO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlVGFncyA9IG9wdGlvbnM/LmluaGVyaXRhYmxlVGFncyA/PyB0aGlzLmluaGVyaXRhYmxlVGFncztcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG9wdGlvbnM/Lm1ldGFkYXRhID8/IHRoaXMubWV0YWRhdGE7XG4gICAgICAgIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSA9XG4gICAgICAgICAgICBvcHRpb25zPy5pbmhlcml0YWJsZU1ldGFkYXRhID8/IHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YTtcbiAgICAgICAgdGhpcy5fcGFyZW50UnVuSWQgPSBwYXJlbnRSdW5JZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHJ1biBJRCwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcmVudCBydW4gSUQuXG4gICAgICovXG4gICAgZ2V0UGFyZW50UnVuSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnRSdW5JZDtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNU3RhcnQobGxtLCBwcm9tcHRzLCBydW5JZCA9IHVuZGVmaW5lZCwgX3BhcmVudFJ1bklkID0gdW5kZWZpbmVkLCBleHRyYVBhcmFtcyA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXB0cy5tYXAoYXN5bmMgKHByb21wdCwgaWR4KSA9PiB7XG4gICAgICAgICAgICAvLyBDYW4ndCBoYXZlIGR1cGxpY2F0ZSBydW5zIHdpdGggdGhlIHNhbWUgcnVuIElEIChpZiBwcm92aWRlZClcbiAgICAgICAgICAgIGNvbnN0IHJ1bklkXyA9IGlkeCA9PT0gMCAmJiBydW5JZCA/IHJ1bklkIDogdXVpZHY0KCk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlTExNKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUxMTVN0YXJ0Py4obGxtLCBbcHJvbXB0XSwgcnVuSWRfLCB0aGlzLl9wYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTVN0YXJ0OiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuKHJ1bklkXywgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGF0TW9kZWxTdGFydChsbG0sIG1lc3NhZ2VzLCBydW5JZCA9IHVuZGVmaW5lZCwgX3BhcmVudFJ1bklkID0gdW5kZWZpbmVkLCBleHRyYVBhcmFtcyA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobWVzc2FnZXMubWFwKGFzeW5jIChtZXNzYWdlR3JvdXAsIGlkeCkgPT4ge1xuICAgICAgICAgICAgLy8gQ2FuJ3QgaGF2ZSBkdXBsaWNhdGUgcnVucyB3aXRoIHRoZSBzYW1lIHJ1biBJRCAoaWYgcHJvdmlkZWQpXG4gICAgICAgICAgICBjb25zdCBydW5JZF8gPSBpZHggPT09IDAgJiYgcnVuSWQgPyBydW5JZCA6IHV1aWR2NCgpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUxMTSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuaGFuZGxlQ2hhdE1vZGVsU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUNoYXRNb2RlbFN0YXJ0Py4obGxtLCBbbWVzc2FnZUdyb3VwXSwgcnVuSWRfLCB0aGlzLl9wYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoYW5kbGVyLmhhbmRsZUxMTVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVN0cmluZyA9IGdldEJ1ZmZlclN0cmluZyhtZXNzYWdlR3JvdXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlTExNU3RhcnQ/LihsbG0sIFttZXNzYWdlU3RyaW5nXSwgcnVuSWRfLCB0aGlzLl9wYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTVN0YXJ0OiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuKHJ1bklkXywgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpblN0YXJ0KGNoYWluLCBpbnB1dHMsIHJ1bklkID0gdXVpZHY0KCksIHJ1blR5cGUgPSB1bmRlZmluZWQsIF90YWdzID0gdW5kZWZpbmVkLCBfbWV0YWRhdGEgPSB1bmRlZmluZWQsIHJ1bk5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQ2hhaW4pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUNoYWluU3RhcnQ/LihjaGFpbiwgaW5wdXRzLCBydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuVHlwZSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUNoYWluU3RhcnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgICAgICByZXR1cm4gbmV3IENhbGxiYWNrTWFuYWdlckZvckNoYWluUnVuKHJ1bklkLCB0aGlzLmhhbmRsZXJzLCB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMsIHRoaXMudGFncywgdGhpcy5pbmhlcml0YWJsZVRhZ3MsIHRoaXMubWV0YWRhdGEsIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5fcGFyZW50UnVuSWQpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUb29sU3RhcnQodG9vbCwgaW5wdXQsIHJ1bklkID0gdXVpZHY0KCksIF9wYXJlbnRSdW5JZCA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVBZ2VudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlVG9vbFN0YXJ0Py4odG9vbCwgaW5wdXQsIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlVG9vbFN0YXJ0OiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsYmFja01hbmFnZXJGb3JUb29sUnVuKHJ1bklkLCB0aGlzLmhhbmRsZXJzLCB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMsIHRoaXMudGFncywgdGhpcy5pbmhlcml0YWJsZVRhZ3MsIHRoaXMubWV0YWRhdGEsIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5fcGFyZW50UnVuSWQpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJTdGFydChyZXRyaWV2ZXIsIHF1ZXJ5LCBydW5JZCA9IHV1aWR2NCgpLCBfcGFyZW50UnVuSWQgPSB1bmRlZmluZWQsIF90YWdzID0gdW5kZWZpbmVkLCBfbWV0YWRhdGEgPSB1bmRlZmluZWQsIHJ1bk5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlUmV0cmlldmVyKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVSZXRyaWV2ZXJTdGFydD8uKHJldHJpZXZlciwgcXVlcnksIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlUmV0cmlldmVyU3RhcnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgICAgICByZXR1cm4gbmV3IENhbGxiYWNrTWFuYWdlckZvclJldHJpZXZlclJ1bihydW5JZCwgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICB9XG4gICAgYWRkSGFuZGxlcihoYW5kbGVyLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHRoaXMuaGFuZGxlcnMuZmlsdGVyKChfaGFuZGxlcikgPT4gX2hhbmRsZXIgIT09IGhhbmRsZXIpO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMgPSB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMuZmlsdGVyKChfaGFuZGxlcikgPT4gX2hhbmRsZXIgIT09IGhhbmRsZXIpO1xuICAgIH1cbiAgICBzZXRIYW5kbGVycyhoYW5kbGVycywgaW5oZXJpdCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEhhbmRsZXIoaGFuZGxlciwgaW5oZXJpdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVGFncyh0YWdzLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlbW92ZVRhZ3ModGFncyk7IC8vIFJlbW92ZSBkdXBsaWNhdGVzXG4gICAgICAgIHRoaXMudGFncy5wdXNoKC4uLnRhZ3MpO1xuICAgICAgICBpZiAoaW5oZXJpdCkge1xuICAgICAgICAgICAgdGhpcy5pbmhlcml0YWJsZVRhZ3MucHVzaCguLi50YWdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVUYWdzKHRhZ3MpIHtcbiAgICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiAhdGFncy5pbmNsdWRlcyh0YWcpKTtcbiAgICAgICAgdGhpcy5pbmhlcml0YWJsZVRhZ3MgPSB0aGlzLmluaGVyaXRhYmxlVGFncy5maWx0ZXIoKHRhZykgPT4gIXRhZ3MuaW5jbHVkZXModGFnKSk7XG4gICAgfVxuICAgIGFkZE1ldGFkYXRhKG1ldGFkYXRhLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0geyAuLi50aGlzLm1ldGFkYXRhLCAuLi5tZXRhZGF0YSB9O1xuICAgICAgICBpZiAoaW5oZXJpdCkge1xuICAgICAgICAgICAgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhID0geyAuLi50aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIC4uLm1ldGFkYXRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobWV0YWRhdGEpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5tZXRhZGF0YVtrZXldO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvcHkoYWRkaXRpb25hbEhhbmRsZXJzID0gW10sIGluaGVyaXQgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaGVyaXRhYmxlID0gdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLmluY2x1ZGVzKGhhbmRsZXIpO1xuICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKGhhbmRsZXIsIGluaGVyaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLnRhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaGVyaXRhYmxlID0gdGhpcy5pbmhlcml0YWJsZVRhZ3MuaW5jbHVkZXModGFnKTtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkVGFncyhbdGFnXSwgaW5oZXJpdGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMubWV0YWRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBpbmhlcml0YWJsZSA9IE9iamVjdC5rZXlzKHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSkuaW5jbHVkZXMoa2V5KTtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkTWV0YWRhdGEoeyBba2V5XTogdGhpcy5tZXRhZGF0YVtrZXldIH0sIGluaGVyaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgYWRkaXRpb25hbEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBQcmV2ZW50IG11bHRpcGxlIGNvcGllcyBvZiBjb25zb2xlX2NhbGxiYWNrX2hhbmRsZXJcbiAgICAgICAgICAgIG1hbmFnZXIuaGFuZGxlcnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChoKSA9PiBoLm5hbWUgPT09IFwiY29uc29sZV9jYWxsYmFja19oYW5kbGVyXCIpXG4gICAgICAgICAgICAgICAgLnNvbWUoKGgpID0+IGgubmFtZSA9PT0gaGFuZGxlci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKGhhbmRsZXIsIGluaGVyaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhhbmRsZXJzKGhhbmRsZXJzKSB7XG4gICAgICAgIGNsYXNzIEhhbmRsZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tIYW5kbGVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1dWlkdjQoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgaGFuZGxlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgdGhpcygpO1xuICAgICAgICBtYW5hZ2VyLmFkZEhhbmRsZXIobmV3IEhhbmRsZXIoKSk7XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY29uZmlndXJlKGluaGVyaXRhYmxlSGFuZGxlcnMsIGxvY2FsSGFuZGxlcnMsIGluaGVyaXRhYmxlVGFncywgbG9jYWxUYWdzLCBpbmhlcml0YWJsZU1ldGFkYXRhLCBsb2NhbE1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBjYWxsYmFja01hbmFnZXI7XG4gICAgICAgIGlmIChpbmhlcml0YWJsZUhhbmRsZXJzIHx8IGxvY2FsSGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluaGVyaXRhYmxlSGFuZGxlcnMpIHx8ICFpbmhlcml0YWJsZUhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyID0gbmV3IENhbGxiYWNrTWFuYWdlcigpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5zZXRIYW5kbGVycyhpbmhlcml0YWJsZUhhbmRsZXJzPy5tYXAoZW5zdXJlSGFuZGxlcikgPz8gW10sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyID0gaW5oZXJpdGFibGVIYW5kbGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlciA9IGNhbGxiYWNrTWFuYWdlci5jb3B5KEFycmF5LmlzQXJyYXkobG9jYWxIYW5kbGVycylcbiAgICAgICAgICAgICAgICA/IGxvY2FsSGFuZGxlcnMubWFwKGVuc3VyZUhhbmRsZXIpXG4gICAgICAgICAgICAgICAgOiBsb2NhbEhhbmRsZXJzPy5oYW5kbGVycywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZlcmJvc2VFbmFibGVkID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9WRVJCT1NFXCIpID09PSBcInRydWVcIiB8fFxuICAgICAgICAgICAgb3B0aW9ucz8udmVyYm9zZTtcbiAgICAgICAgY29uc3QgdHJhY2luZ1YyRW5hYmxlZCA9IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fVFJBQ0lOR19WMlwiKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIGNvbnN0IHRyYWNpbmdFbmFibGVkID0gdHJhY2luZ1YyRW5hYmxlZCB8fFxuICAgICAgICAgICAgKGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fVFJBQ0lOR1wiKSA/PyBmYWxzZSk7XG4gICAgICAgIGlmICh2ZXJib3NlRW5hYmxlZCB8fCB0cmFjaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgaWYgKCFjYWxsYmFja01hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmVyYm9zZUVuYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAhY2FsbGJhY2tNYW5hZ2VyLmhhbmRsZXJzLnNvbWUoKGhhbmRsZXIpID0+IGhhbmRsZXIubmFtZSA9PT0gQ29uc29sZUNhbGxiYWNrSGFuZGxlci5wcm90b3R5cGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25zb2xlSGFuZGxlciA9IG5ldyBDb25zb2xlQ2FsbGJhY2tIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLmFkZEhhbmRsZXIoY29uc29sZUhhbmRsZXIsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYWNpbmdFbmFibGVkICYmXG4gICAgICAgICAgICAgICAgIWNhbGxiYWNrTWFuYWdlci5oYW5kbGVycy5zb21lKChoYW5kbGVyKSA9PiBoYW5kbGVyLm5hbWUgPT09IFwibGFuZ2NoYWluX3RyYWNlclwiKSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFjaW5nVjJFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRIYW5kbGVyKGF3YWl0IGdldFRyYWNpbmdWMkNhbGxiYWNrSGFuZGxlcigpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaGVyaXRhYmxlVGFncyB8fCBsb2NhbFRhZ3MpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFja01hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkVGFncyhpbmhlcml0YWJsZVRhZ3MgPz8gW10pO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRUYWdzKGxvY2FsVGFncyA/PyBbXSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmhlcml0YWJsZU1ldGFkYXRhIHx8IGxvY2FsTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFja01hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkTWV0YWRhdGEoaW5oZXJpdGFibGVNZXRhZGF0YSA/PyB7fSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLmFkZE1ldGFkYXRhKGxvY2FsTWV0YWRhdGEgPz8ge30sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2tNYW5hZ2VyO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICBpZiAoXCJuYW1lXCIgaW4gaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICB9XG4gICAgcmV0dXJuIEJhc2VDYWxsYmFja0hhbmRsZXIuZnJvbU1ldGhvZHMoaGFuZGxlcik7XG59XG4vKipcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBwcm9tcHQgPSBQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoYFdoYXQgaXMgdGhlIGFuc3dlciB0byB7cXVlc3Rpb259P2ApO1xuICpcbiAqIC8vIEV4YW1wbGUgb2YgdXNpbmcgTExNQ2hhaW4gdG8gcHJvY2VzcyBhIHNlcmllcyBvZiBxdWVzdGlvbnNcbiAqIGNvbnN0IGNoYWluID0gbmV3IExMTUNoYWluKHtcbiAqICAgbGxtOiBuZXcgQ2hhdE9wZW5BSSh7IHRlbXBlcmF0dXJlOiAwLjkgfSksXG4gKiAgIHByb21wdCxcbiAqIH0pO1xuICpcbiAqIC8vIFByb2Nlc3MgcXVlc3Rpb25zIHVzaW5nIHRoZSBjaGFpblxuICogY29uc3QgcHJvY2Vzc1F1ZXN0aW9ucyA9IGFzeW5jIChxdWVzdGlvbnMpID0+IHtcbiAqICAgZm9yIChjb25zdCBxdWVzdGlvbiBvZiBxdWVzdGlvbnMpIHtcbiAqICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGFpbi5jYWxsKHsgcXVlc3Rpb24gfSk7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgfVxuICogfTtcbiAqXG4gKiAvLyBFeGFtcGxlIHF1ZXN0aW9uc1xuICogY29uc3QgcXVlc3Rpb25zID0gW1xuICogICBcIldoYXQgaXMgeW91ciBuYW1lP1wiLFxuICogICBcIldoYXQgaXMgeW91ciBxdWVzdD9cIixcbiAqICAgXCJXaGF0IGlzIHlvdXIgZmF2b3JpdGUgY29sb3I/XCIsXG4gKiBdO1xuICpcbiAqIC8vIFJ1biB0aGUgZXhhbXBsZVxuICogcHJvY2Vzc1F1ZXN0aW9ucyhxdWVzdGlvbnMpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICpcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgVHJhY2VHcm91cCB7XG4gICAgY29uc3RydWN0b3IoZ3JvdXBOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdyb3VwTmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZ3JvdXBOYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcHRpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5NYW5hZ2VyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYWNlR3JvdXBDYWxsYmFja01hbmFnZXIoZ3JvdXBfbmFtZSwgaW5wdXRzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNiID0gbmV3IExhbmdDaGFpblRyYWNlcihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY20gPSBhd2FpdCBDYWxsYmFja01hbmFnZXIuY29uZmlndXJlKFtjYl0pO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY20/LmhhbmRsZUNoYWluU3RhcnQoe1xuICAgICAgICAgICAgbGM6IDEsXG4gICAgICAgICAgICB0eXBlOiBcIm5vdF9pbXBsZW1lbnRlZFwiLFxuICAgICAgICAgICAgaWQ6IFtcImxhbmdjaGFpblwiLCBcImNhbGxiYWNrc1wiLCBcImdyb3Vwc1wiLCBncm91cF9uYW1lXSxcbiAgICAgICAgfSwgaW5wdXRzID8/IHt9KTtcbiAgICAgICAgaWYgKCFydW5NYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIHJ1biBncm91cCBjYWxsYmFjayBtYW5hZ2VyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuTWFuYWdlcjtcbiAgICB9XG4gICAgYXN5bmMgc3RhcnQoaW5wdXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5ydW5NYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bk1hbmFnZXIgPSBhd2FpdCB0aGlzLmdldFRyYWNlR3JvdXBDYWxsYmFja01hbmFnZXIodGhpcy5ncm91cE5hbWUsIGlucHV0cywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ydW5NYW5hZ2VyLmdldENoaWxkKCk7XG4gICAgfVxuICAgIGFzeW5jIGVycm9yKGVycikge1xuICAgICAgICBpZiAodGhpcy5ydW5NYW5hZ2VyKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJ1bk1hbmFnZXIuaGFuZGxlQ2hhaW5FcnJvcihlcnIpO1xuICAgICAgICAgICAgdGhpcy5ydW5NYW5hZ2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGVuZChvdXRwdXQpIHtcbiAgICAgICAgaWYgKHRoaXMucnVuTWFuYWdlcikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5NYW5hZ2VyLmhhbmRsZUNoYWluRW5kKG91dHB1dCA/PyB7fSk7XG4gICAgICAgICAgICB0aGlzLnJ1bk1hbmFnZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gX2NvZXJjZVRvRGljdCh2YWx1ZSwgZGVmYXVsdEtleSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiB7IFtkZWZhdWx0S2V5XTogdmFsdWUgfTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdHJhY2VBc0dyb3VwKGdyb3VwT3B0aW9ucywgZW5jbG9zZWRDb2RlLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgdHJhY2VHcm91cCA9IG5ldyBUcmFjZUdyb3VwKGdyb3VwT3B0aW9ucy5uYW1lLCBncm91cE9wdGlvbnMpO1xuICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlciA9IGF3YWl0IHRyYWNlR3JvdXAuc3RhcnQoeyAuLi5hcmdzIH0pO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVuY2xvc2VkQ29kZShjYWxsYmFja01hbmFnZXIsIC4uLmFyZ3MpO1xuICAgICAgICBhd2FpdCB0cmFjZUdyb3VwLmVuZChfY29lcmNlVG9EaWN0KHJlc3VsdCwgXCJvdXRwdXRcIikpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGF3YWl0IHRyYWNlR3JvdXAuZXJyb3IoZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/callbacks/manager.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/callbacks/promises.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/promises.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   awaitAllCallbacks: () => (/* binding */ awaitAllCallbacks),\n/* harmony export */   consumeCallback: () => (/* binding */ consumeCallback)\n/* harmony export */ });\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-queue */ \"(action-browser)/./node_modules/p-queue/dist/index.js\");\n\nlet queue;\n/**\n * Creates a queue using the p-queue library. The queue is configured to\n * auto-start and has a concurrency of 1, meaning it will process tasks\n * one at a time.\n */\nfunction createQueue() {\n    const PQueue =  true ? p_queue__WEBPACK_IMPORTED_MODULE_0__[\"default\"] : p_queue__WEBPACK_IMPORTED_MODULE_0__;\n    return new PQueue({\n        autoStart: true,\n        concurrency: 1,\n    });\n}\n/**\n * Consume a promise, either adding it to the queue or waiting for it to resolve\n * @param promise Promise to consume\n * @param wait Whether to wait for the promise to resolve or resolve immediately\n */\nasync function consumeCallback(promiseFn, wait) {\n    if (wait === true) {\n        await promiseFn();\n    }\n    else {\n        if (typeof queue === \"undefined\") {\n            queue = createQueue();\n        }\n        void queue.add(promiseFn);\n    }\n}\n/**\n * Waits for all promises in the queue to resolve. If the queue is\n * undefined, it immediately resolves a promise.\n */\nfunction awaitAllCallbacks() {\n    return typeof queue !== \"undefined\" ? queue.onIdle() : Promise.resolve();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9jYWxsYmFja3MvcHJvbWlzZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQXNCLEdBQUcsK0NBQWlCLEdBQUcsb0NBQVM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXGNhbGxiYWNrc1xccHJvbWlzZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBRdWV1ZU1vZCBmcm9tIFwicC1xdWV1ZVwiO1xubGV0IHF1ZXVlO1xuLyoqXG4gKiBDcmVhdGVzIGEgcXVldWUgdXNpbmcgdGhlIHAtcXVldWUgbGlicmFyeS4gVGhlIHF1ZXVlIGlzIGNvbmZpZ3VyZWQgdG9cbiAqIGF1dG8tc3RhcnQgYW5kIGhhcyBhIGNvbmN1cnJlbmN5IG9mIDEsIG1lYW5pbmcgaXQgd2lsbCBwcm9jZXNzIHRhc2tzXG4gKiBvbmUgYXQgYSB0aW1lLlxuICovXG5mdW5jdGlvbiBjcmVhdGVRdWV1ZSgpIHtcbiAgICBjb25zdCBQUXVldWUgPSBcImRlZmF1bHRcIiBpbiBQUXVldWVNb2QgPyBQUXVldWVNb2QuZGVmYXVsdCA6IFBRdWV1ZU1vZDtcbiAgICByZXR1cm4gbmV3IFBRdWV1ZSh7XG4gICAgICAgIGF1dG9TdGFydDogdHJ1ZSxcbiAgICAgICAgY29uY3VycmVuY3k6IDEsXG4gICAgfSk7XG59XG4vKipcbiAqIENvbnN1bWUgYSBwcm9taXNlLCBlaXRoZXIgYWRkaW5nIGl0IHRvIHRoZSBxdWV1ZSBvciB3YWl0aW5nIGZvciBpdCB0byByZXNvbHZlXG4gKiBAcGFyYW0gcHJvbWlzZSBQcm9taXNlIHRvIGNvbnN1bWVcbiAqIEBwYXJhbSB3YWl0IFdoZXRoZXIgdG8gd2FpdCBmb3IgdGhlIHByb21pc2UgdG8gcmVzb2x2ZSBvciByZXNvbHZlIGltbWVkaWF0ZWx5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25zdW1lQ2FsbGJhY2socHJvbWlzZUZuLCB3YWl0KSB7XG4gICAgaWYgKHdhaXQgPT09IHRydWUpIHtcbiAgICAgICAgYXdhaXQgcHJvbWlzZUZuKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBxdWV1ZSA9IGNyZWF0ZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdm9pZCBxdWV1ZS5hZGQocHJvbWlzZUZuKTtcbiAgICB9XG59XG4vKipcbiAqIFdhaXRzIGZvciBhbGwgcHJvbWlzZXMgaW4gdGhlIHF1ZXVlIHRvIHJlc29sdmUuIElmIHRoZSBxdWV1ZSBpc1xuICogdW5kZWZpbmVkLCBpdCBpbW1lZGlhdGVseSByZXNvbHZlcyBhIHByb21pc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhd2FpdEFsbENhbGxiYWNrcygpIHtcbiAgICByZXR1cm4gdHlwZW9mIHF1ZXVlICE9PSBcInVuZGVmaW5lZFwiID8gcXVldWUub25JZGxlKCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/callbacks/promises.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/documents/document.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/document.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Document: () => (/* binding */ Document)\n/* harmony export */ });\n/**\n * Interface for interacting with a document.\n */\nclass Document {\n    constructor(fields) {\n        Object.defineProperty(this, \"pageContent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.pageContent = fields.pageContent\n            ? fields.pageContent.toString()\n            : this.pageContent;\n        this.metadata = fields.metadata ?? {};\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9kb2N1bWVudHMvZG9jdW1lbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcZG9jdW1lbnRzXFxkb2N1bWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEludGVyZmFjZSBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhIGRvY3VtZW50LlxuICovXG5leHBvcnQgY2xhc3MgRG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYWdlQ29udGVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhZ2VDb250ZW50ID0gZmllbGRzLnBhZ2VDb250ZW50XG4gICAgICAgICAgICA/IGZpZWxkcy5wYWdlQ29udGVudC50b1N0cmluZygpXG4gICAgICAgICAgICA6IHRoaXMucGFnZUNvbnRlbnQ7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBmaWVsZHMubWV0YWRhdGEgPz8ge307XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/documents/document.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/documents/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseDocumentTransformer: () => (/* reexport safe */ _transformers_js__WEBPACK_IMPORTED_MODULE_1__.BaseDocumentTransformer),\n/* harmony export */   Document: () => (/* reexport safe */ _document_js__WEBPACK_IMPORTED_MODULE_0__.Document),\n/* harmony export */   MappingDocumentTransformer: () => (/* reexport safe */ _transformers_js__WEBPACK_IMPORTED_MODULE_1__.MappingDocumentTransformer)\n/* harmony export */ });\n/* harmony import */ var _document_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./document.js */ \"(action-browser)/./node_modules/@langchain/core/dist/documents/document.js\");\n/* harmony import */ var _transformers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transformers.js */ \"(action-browser)/./node_modules/@langchain/core/dist/documents/transformers.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9kb2N1bWVudHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBOEI7QUFDSSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXGRvY3VtZW50c1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4vZG9jdW1lbnQuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3RyYW5zZm9ybWVycy5qc1wiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/documents/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/documents/transformers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/transformers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseDocumentTransformer: () => (/* binding */ BaseDocumentTransformer),\n/* harmony export */   MappingDocumentTransformer: () => (/* binding */ MappingDocumentTransformer)\n/* harmony export */ });\n/* harmony import */ var _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runnables/base.js */ \"(action-browser)/./node_modules/@langchain/core/dist/runnables/base.js\");\n\n/**\n * Abstract base class for document transformation systems.\n *\n * A document transformation system takes an array of Documents and returns an\n * array of transformed Documents. These arrays do not necessarily have to have\n * the same length.\n *\n * One example of this is a text splitter that splits a large document into\n * many smaller documents.\n */\nclass BaseDocumentTransformer extends _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__.Runnable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"documents\", \"transformers\"]\n        });\n    }\n    /**\n     * Method to invoke the document transformation. This method calls the\n     * transformDocuments method with the provided input.\n     * @param input The input documents to be transformed.\n     * @param _options Optional configuration object to customize the behavior of callbacks.\n     * @returns A Promise that resolves to the transformed documents.\n     */\n    invoke(input, _options) {\n        return this.transformDocuments(input);\n    }\n}\n/**\n * Class for document transformers that return exactly one transformed document\n * for each input document.\n */\nclass MappingDocumentTransformer extends BaseDocumentTransformer {\n    async transformDocuments(documents) {\n        const newDocuments = [];\n        for (const document of documents) {\n            const transformedDocument = await this._transformDocument(document);\n            newDocuments.push(transformedDocument);\n        }\n        return newDocuments;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9kb2N1bWVudHMvdHJhbnNmb3JtZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQyx3REFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcZG9jdW1lbnRzXFx0cmFuc2Zvcm1lcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUnVubmFibGUgfSBmcm9tIFwiLi4vcnVubmFibGVzL2Jhc2UuanNcIjtcbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgZG9jdW1lbnQgdHJhbnNmb3JtYXRpb24gc3lzdGVtcy5cbiAqXG4gKiBBIGRvY3VtZW50IHRyYW5zZm9ybWF0aW9uIHN5c3RlbSB0YWtlcyBhbiBhcnJheSBvZiBEb2N1bWVudHMgYW5kIHJldHVybnMgYW5cbiAqIGFycmF5IG9mIHRyYW5zZm9ybWVkIERvY3VtZW50cy4gVGhlc2UgYXJyYXlzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGhhdmVcbiAqIHRoZSBzYW1lIGxlbmd0aC5cbiAqXG4gKiBPbmUgZXhhbXBsZSBvZiB0aGlzIGlzIGEgdGV4dCBzcGxpdHRlciB0aGF0IHNwbGl0cyBhIGxhcmdlIGRvY3VtZW50IGludG9cbiAqIG1hbnkgc21hbGxlciBkb2N1bWVudHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlRG9jdW1lbnRUcmFuc2Zvcm1lciBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcImRvY3VtZW50c1wiLCBcInRyYW5zZm9ybWVyc1wiXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGludm9rZSB0aGUgZG9jdW1lbnQgdHJhbnNmb3JtYXRpb24uIFRoaXMgbWV0aG9kIGNhbGxzIHRoZVxuICAgICAqIHRyYW5zZm9ybURvY3VtZW50cyBtZXRob2Qgd2l0aCB0aGUgcHJvdmlkZWQgaW5wdXQuXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBkb2N1bWVudHMgdG8gYmUgdHJhbnNmb3JtZWQuXG4gICAgICogQHBhcmFtIF9vcHRpb25zIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHRvIGN1c3RvbWl6ZSB0aGUgYmVoYXZpb3Igb2YgY2FsbGJhY2tzLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB0cmFuc2Zvcm1lZCBkb2N1bWVudHMuXG4gICAgICovXG4gICAgaW52b2tlKGlucHV0LCBfb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Eb2N1bWVudHMoaW5wdXQpO1xuICAgIH1cbn1cbi8qKlxuICogQ2xhc3MgZm9yIGRvY3VtZW50IHRyYW5zZm9ybWVycyB0aGF0IHJldHVybiBleGFjdGx5IG9uZSB0cmFuc2Zvcm1lZCBkb2N1bWVudFxuICogZm9yIGVhY2ggaW5wdXQgZG9jdW1lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXBwaW5nRG9jdW1lbnRUcmFuc2Zvcm1lciBleHRlbmRzIEJhc2VEb2N1bWVudFRyYW5zZm9ybWVyIHtcbiAgICBhc3luYyB0cmFuc2Zvcm1Eb2N1bWVudHMoZG9jdW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IG5ld0RvY3VtZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGRvY3VtZW50IG9mIGRvY3VtZW50cykge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWREb2N1bWVudCA9IGF3YWl0IHRoaXMuX3RyYW5zZm9ybURvY3VtZW50KGRvY3VtZW50KTtcbiAgICAgICAgICAgIG5ld0RvY3VtZW50cy5wdXNoKHRyYW5zZm9ybWVkRG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEb2N1bWVudHM7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/documents/transformers.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/load/map_keys.js":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/load/map_keys.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keyFromJson: () => (/* binding */ keyFromJson),\n/* harmony export */   keyToJson: () => (/* binding */ keyToJson),\n/* harmony export */   mapKeys: () => (/* binding */ mapKeys)\n/* harmony export */ });\n/* harmony import */ var decamelize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! decamelize */ \"(action-browser)/./node_modules/decamelize/index.js\");\n/* harmony import */ var camelcase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! camelcase */ \"(action-browser)/./node_modules/camelcase/index.js\");\n\n\nfunction keyToJson(key, map) {\n    return map?.[key] || decamelize__WEBPACK_IMPORTED_MODULE_0__(key);\n}\nfunction keyFromJson(key, map) {\n    return map?.[key] || camelcase__WEBPACK_IMPORTED_MODULE_1__(key);\n}\nfunction mapKeys(fields, mapper, map) {\n    const mapped = {};\n    for (const key in fields) {\n        if (Object.hasOwn(fields, key)) {\n            mapped[mapper(key, map)] = fields[key];\n        }\n    }\n    return mapped;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9sb2FkL21hcF9rZXlzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1DO0FBQ0Q7QUFDM0I7QUFDUCx5QkFBeUIsdUNBQVM7QUFDbEM7QUFDTztBQUNQLHlCQUF5QixzQ0FBUztBQUNsQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXGxvYWRcXG1hcF9rZXlzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzbmFrZUNhc2UgZnJvbSBcImRlY2FtZWxpemVcIjtcbmltcG9ydCBjYW1lbENhc2UgZnJvbSBcImNhbWVsY2FzZVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGtleVRvSnNvbihrZXksIG1hcCkge1xuICAgIHJldHVybiBtYXA/LltrZXldIHx8IHNuYWtlQ2FzZShrZXkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGtleUZyb21Kc29uKGtleSwgbWFwKSB7XG4gICAgcmV0dXJuIG1hcD8uW2tleV0gfHwgY2FtZWxDYXNlKGtleSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFwS2V5cyhmaWVsZHMsIG1hcHBlciwgbWFwKSB7XG4gICAgY29uc3QgbWFwcGVkID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZmllbGRzKSB7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKGZpZWxkcywga2V5KSkge1xuICAgICAgICAgICAgbWFwcGVkW21hcHBlcihrZXksIG1hcCldID0gZmllbGRzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcHBlZDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/load/map_keys.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/load/serializable.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/load/serializable.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Serializable: () => (/* binding */ Serializable),\n/* harmony export */   get_lc_unique_name: () => (/* binding */ get_lc_unique_name)\n/* harmony export */ });\n/* harmony import */ var _map_keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map_keys.js */ \"(action-browser)/./node_modules/@langchain/core/dist/load/map_keys.js\");\n\nfunction shallowCopy(obj) {\n    return Array.isArray(obj) ? [...obj] : { ...obj };\n}\nfunction replaceSecrets(root, secretsMap) {\n    const result = shallowCopy(root);\n    for (const [path, secretId] of Object.entries(secretsMap)) {\n        const [last, ...partsReverse] = path.split(\".\").reverse();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let current = result;\n        for (const part of partsReverse.reverse()) {\n            if (current[part] === undefined) {\n                break;\n            }\n            current[part] = shallowCopy(current[part]);\n            current = current[part];\n        }\n        if (current[last] !== undefined) {\n            current[last] = {\n                lc: 1,\n                type: \"secret\",\n                id: [secretId],\n            };\n        }\n    }\n    return result;\n}\n/**\n * Get a unique name for the module, rather than parent class implementations.\n * Should not be subclassed, subclass lc_name above instead.\n */\nfunction get_lc_unique_name(\n// eslint-disable-next-line @typescript-eslint/no-use-before-define\nserializableClass) {\n    // \"super\" here would refer to the parent class of Serializable,\n    // when we want the parent class of the module actually calling this method.\n    const parentClass = Object.getPrototypeOf(serializableClass);\n    const lcNameIsSubclassed = typeof serializableClass.lc_name === \"function\" &&\n        (typeof parentClass.lc_name !== \"function\" ||\n            serializableClass.lc_name() !== parentClass.lc_name());\n    if (lcNameIsSubclassed) {\n        return serializableClass.lc_name();\n    }\n    else {\n        return serializableClass.name;\n    }\n}\nclass Serializable {\n    /**\n     * The name of the serializable. Override to provide an alias or\n     * to preserve the serialized module name in minified environments.\n     *\n     * Implemented as a static method to support loading logic.\n     */\n    static lc_name() {\n        return this.name;\n    }\n    /**\n     * The final serialized identifier for the module.\n     */\n    get lc_id() {\n        return [\n            ...this.lc_namespace,\n            get_lc_unique_name(this.constructor),\n        ];\n    }\n    /**\n     * A map of secrets, which will be omitted from serialization.\n     * Keys are paths to the secret in constructor args, e.g. \"foo.bar.baz\".\n     * Values are the secret ids, which will be used when deserializing.\n     */\n    get lc_secrets() {\n        return undefined;\n    }\n    /**\n     * A map of additional attributes to merge with constructor args.\n     * Keys are the attribute names, e.g. \"foo\".\n     * Values are the attribute values, which will be serialized.\n     * These attributes need to be accepted by the constructor as arguments.\n     */\n    get lc_attributes() {\n        return undefined;\n    }\n    /**\n     * A map of aliases for constructor args.\n     * Keys are the attribute names, e.g. \"foo\".\n     * Values are the alias that will replace the key in serialization.\n     * This is used to eg. make argument names match Python.\n     */\n    get lc_aliases() {\n        return undefined;\n    }\n    constructor(kwargs, ..._args) {\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.lc_kwargs = kwargs || {};\n    }\n    toJSON() {\n        if (!this.lc_serializable) {\n            return this.toJSONNotImplemented();\n        }\n        if (\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        this.lc_kwargs instanceof Serializable ||\n            typeof this.lc_kwargs !== \"object\" ||\n            Array.isArray(this.lc_kwargs)) {\n            // We do not support serialization of classes with arg not a POJO\n            // I'm aware the check above isn't as strict as it could be\n            return this.toJSONNotImplemented();\n        }\n        const aliases = {};\n        const secrets = {};\n        const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {\n            acc[key] = key in this ? this[key] : this.lc_kwargs[key];\n            return acc;\n        }, {});\n        // get secrets, attributes and aliases from all superclasses\n        for (\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)) {\n            Object.assign(aliases, Reflect.get(current, \"lc_aliases\", this));\n            Object.assign(secrets, Reflect.get(current, \"lc_secrets\", this));\n            Object.assign(kwargs, Reflect.get(current, \"lc_attributes\", this));\n        }\n        // include all secrets used, even if not in kwargs,\n        // will be replaced with sentinel value in replaceSecrets\n        Object.keys(secrets).forEach((keyPath) => {\n            // eslint-disable-next-line @typescript-eslint/no-this-alias, @typescript-eslint/no-explicit-any\n            let read = this;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            let write = kwargs;\n            const [last, ...partsReverse] = keyPath.split(\".\").reverse();\n            for (const key of partsReverse.reverse()) {\n                if (!(key in read) || read[key] === undefined)\n                    return;\n                if (!(key in write) || write[key] === undefined) {\n                    if (typeof read[key] === \"object\" && read[key] != null) {\n                        write[key] = {};\n                    }\n                    else if (Array.isArray(read[key])) {\n                        write[key] = [];\n                    }\n                }\n                read = read[key];\n                write = write[key];\n            }\n            if (last in read && read[last] !== undefined) {\n                write[last] = write[last] || read[last];\n            }\n        });\n        return {\n            lc: 1,\n            type: \"constructor\",\n            id: this.lc_id,\n            kwargs: (0,_map_keys_js__WEBPACK_IMPORTED_MODULE_0__.mapKeys)(Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs, _map_keys_js__WEBPACK_IMPORTED_MODULE_0__.keyToJson, aliases),\n        };\n    }\n    toJSONNotImplemented() {\n        return {\n            lc: 1,\n            type: \"not_implemented\",\n            id: this.lc_id,\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9sb2FkL3NlcmlhbGl6YWJsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUQ7QUFDbkQ7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFPLHlFQUF5RSxtREFBUztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXGxvYWRcXHNlcmlhbGl6YWJsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZXlUb0pzb24sIG1hcEtleXMgfSBmcm9tIFwiLi9tYXBfa2V5cy5qc1wiO1xuZnVuY3Rpb24gc2hhbGxvd0NvcHkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSA/IFsuLi5vYmpdIDogeyAuLi5vYmogfTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VTZWNyZXRzKHJvb3QsIHNlY3JldHNNYXApIHtcbiAgICBjb25zdCByZXN1bHQgPSBzaGFsbG93Q29weShyb290KTtcbiAgICBmb3IgKGNvbnN0IFtwYXRoLCBzZWNyZXRJZF0gb2YgT2JqZWN0LmVudHJpZXMoc2VjcmV0c01hcCkpIHtcbiAgICAgICAgY29uc3QgW2xhc3QsIC4uLnBhcnRzUmV2ZXJzZV0gPSBwYXRoLnNwbGl0KFwiLlwiKS5yZXZlcnNlKCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCBjdXJyZW50ID0gcmVzdWx0O1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHNSZXZlcnNlLnJldmVyc2UoKSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRbcGFydF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFtwYXJ0XSA9IHNoYWxsb3dDb3B5KGN1cnJlbnRbcGFydF0pO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFydF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRbbGFzdF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY3VycmVudFtsYXN0XSA9IHtcbiAgICAgICAgICAgICAgICBsYzogMSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNlY3JldFwiLFxuICAgICAgICAgICAgICAgIGlkOiBbc2VjcmV0SWRdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBHZXQgYSB1bmlxdWUgbmFtZSBmb3IgdGhlIG1vZHVsZSwgcmF0aGVyIHRoYW4gcGFyZW50IGNsYXNzIGltcGxlbWVudGF0aW9ucy5cbiAqIFNob3VsZCBub3QgYmUgc3ViY2xhc3NlZCwgc3ViY2xhc3MgbGNfbmFtZSBhYm92ZSBpbnN0ZWFkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2xjX3VuaXF1ZV9uYW1lKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuc2VyaWFsaXphYmxlQ2xhc3MpIHtcbiAgICAvLyBcInN1cGVyXCIgaGVyZSB3b3VsZCByZWZlciB0byB0aGUgcGFyZW50IGNsYXNzIG9mIFNlcmlhbGl6YWJsZSxcbiAgICAvLyB3aGVuIHdlIHdhbnQgdGhlIHBhcmVudCBjbGFzcyBvZiB0aGUgbW9kdWxlIGFjdHVhbGx5IGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gICAgY29uc3QgcGFyZW50Q2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2VyaWFsaXphYmxlQ2xhc3MpO1xuICAgIGNvbnN0IGxjTmFtZUlzU3ViY2xhc3NlZCA9IHR5cGVvZiBzZXJpYWxpemFibGVDbGFzcy5sY19uYW1lID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgKHR5cGVvZiBwYXJlbnRDbGFzcy5sY19uYW1lICE9PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgICAgIHNlcmlhbGl6YWJsZUNsYXNzLmxjX25hbWUoKSAhPT0gcGFyZW50Q2xhc3MubGNfbmFtZSgpKTtcbiAgICBpZiAobGNOYW1lSXNTdWJjbGFzc2VkKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemFibGVDbGFzcy5sY19uYW1lKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXphYmxlQ2xhc3MubmFtZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU2VyaWFsaXphYmxlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgc2VyaWFsaXphYmxlLiBPdmVycmlkZSB0byBwcm92aWRlIGFuIGFsaWFzIG9yXG4gICAgICogdG8gcHJlc2VydmUgdGhlIHNlcmlhbGl6ZWQgbW9kdWxlIG5hbWUgaW4gbWluaWZpZWQgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogSW1wbGVtZW50ZWQgYXMgYSBzdGF0aWMgbWV0aG9kIHRvIHN1cHBvcnQgbG9hZGluZyBsb2dpYy5cbiAgICAgKi9cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpbmFsIHNlcmlhbGl6ZWQgaWRlbnRpZmllciBmb3IgdGhlIG1vZHVsZS5cbiAgICAgKi9cbiAgICBnZXQgbGNfaWQoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi50aGlzLmxjX25hbWVzcGFjZSxcbiAgICAgICAgICAgIGdldF9sY191bmlxdWVfbmFtZSh0aGlzLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBtYXAgb2Ygc2VjcmV0cywgd2hpY2ggd2lsbCBiZSBvbWl0dGVkIGZyb20gc2VyaWFsaXphdGlvbi5cbiAgICAgKiBLZXlzIGFyZSBwYXRocyB0byB0aGUgc2VjcmV0IGluIGNvbnN0cnVjdG9yIGFyZ3MsIGUuZy4gXCJmb28uYmFyLmJhelwiLlxuICAgICAqIFZhbHVlcyBhcmUgdGhlIHNlY3JldCBpZHMsIHdoaWNoIHdpbGwgYmUgdXNlZCB3aGVuIGRlc2VyaWFsaXppbmcuXG4gICAgICovXG4gICAgZ2V0IGxjX3NlY3JldHMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIGFkZGl0aW9uYWwgYXR0cmlidXRlcyB0byBtZXJnZSB3aXRoIGNvbnN0cnVjdG9yIGFyZ3MuXG4gICAgICogS2V5cyBhcmUgdGhlIGF0dHJpYnV0ZSBuYW1lcywgZS5nLiBcImZvb1wiLlxuICAgICAqIFZhbHVlcyBhcmUgdGhlIGF0dHJpYnV0ZSB2YWx1ZXMsIHdoaWNoIHdpbGwgYmUgc2VyaWFsaXplZC5cbiAgICAgKiBUaGVzZSBhdHRyaWJ1dGVzIG5lZWQgdG8gYmUgYWNjZXB0ZWQgYnkgdGhlIGNvbnN0cnVjdG9yIGFzIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBnZXQgbGNfYXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBtYXAgb2YgYWxpYXNlcyBmb3IgY29uc3RydWN0b3IgYXJncy5cbiAgICAgKiBLZXlzIGFyZSB0aGUgYXR0cmlidXRlIG5hbWVzLCBlLmcuIFwiZm9vXCIuXG4gICAgICogVmFsdWVzIGFyZSB0aGUgYWxpYXMgdGhhdCB3aWxsIHJlcGxhY2UgdGhlIGtleSBpbiBzZXJpYWxpemF0aW9uLlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBlZy4gbWFrZSBhcmd1bWVudCBuYW1lcyBtYXRjaCBQeXRob24uXG4gICAgICovXG4gICAgZ2V0IGxjX2FsaWFzZXMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGt3YXJncywgLi4uX2FyZ3MpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfa3dhcmdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGNfa3dhcmdzID0ga3dhcmdzIHx8IHt9O1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghdGhpcy5sY19zZXJpYWxpemFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSlNPTk5vdEltcGxlbWVudGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgIHRoaXMubGNfa3dhcmdzIGluc3RhbmNlb2YgU2VyaWFsaXphYmxlIHx8XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5sY19rd2FyZ3MgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5sY19rd2FyZ3MpKSB7XG4gICAgICAgICAgICAvLyBXZSBkbyBub3Qgc3VwcG9ydCBzZXJpYWxpemF0aW9uIG9mIGNsYXNzZXMgd2l0aCBhcmcgbm90IGEgUE9KT1xuICAgICAgICAgICAgLy8gSSdtIGF3YXJlIHRoZSBjaGVjayBhYm92ZSBpc24ndCBhcyBzdHJpY3QgYXMgaXQgY291bGQgYmVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSlNPTk5vdEltcGxlbWVudGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxpYXNlcyA9IHt9O1xuICAgICAgICBjb25zdCBzZWNyZXRzID0ge307XG4gICAgICAgIGNvbnN0IGt3YXJncyA9IE9iamVjdC5rZXlzKHRoaXMubGNfa3dhcmdzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGtleSBpbiB0aGlzID8gdGhpc1trZXldIDogdGhpcy5sY19rd2FyZ3Nba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgLy8gZ2V0IHNlY3JldHMsIGF0dHJpYnV0ZXMgYW5kIGFsaWFzZXMgZnJvbSBhbGwgc3VwZXJjbGFzc2VzXG4gICAgICAgIGZvciAoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBsZXQgY3VycmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTsgY3VycmVudDsgY3VycmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXJyZW50KSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihhbGlhc2VzLCBSZWZsZWN0LmdldChjdXJyZW50LCBcImxjX2FsaWFzZXNcIiwgdGhpcykpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZWNyZXRzLCBSZWZsZWN0LmdldChjdXJyZW50LCBcImxjX3NlY3JldHNcIiwgdGhpcykpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihrd2FyZ3MsIFJlZmxlY3QuZ2V0KGN1cnJlbnQsIFwibGNfYXR0cmlidXRlc1wiLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5jbHVkZSBhbGwgc2VjcmV0cyB1c2VkLCBldmVuIGlmIG5vdCBpbiBrd2FyZ3MsXG4gICAgICAgIC8vIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBzZW50aW5lbCB2YWx1ZSBpbiByZXBsYWNlU2VjcmV0c1xuICAgICAgICBPYmplY3Qua2V5cyhzZWNyZXRzKS5mb3JFYWNoKChrZXlQYXRoKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGxldCByZWFkID0gdGhpcztcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBsZXQgd3JpdGUgPSBrd2FyZ3M7XG4gICAgICAgICAgICBjb25zdCBbbGFzdCwgLi4ucGFydHNSZXZlcnNlXSA9IGtleVBhdGguc3BsaXQoXCIuXCIpLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHBhcnRzUmV2ZXJzZS5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gcmVhZCkgfHwgcmVhZFtrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gd3JpdGUpIHx8IHdyaXRlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlYWRba2V5XSA9PT0gXCJvYmplY3RcIiAmJiByZWFkW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVhZFtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlYWQgPSByZWFkW2tleV07XG4gICAgICAgICAgICAgICAgd3JpdGUgPSB3cml0ZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3QgaW4gcmVhZCAmJiByZWFkW2xhc3RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB3cml0ZVtsYXN0XSA9IHdyaXRlW2xhc3RdIHx8IHJlYWRbbGFzdF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGM6IDEsXG4gICAgICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICBpZDogdGhpcy5sY19pZCxcbiAgICAgICAgICAgIGt3YXJnczogbWFwS2V5cyhPYmplY3Qua2V5cyhzZWNyZXRzKS5sZW5ndGggPyByZXBsYWNlU2VjcmV0cyhrd2FyZ3MsIHNlY3JldHMpIDoga3dhcmdzLCBrZXlUb0pzb24sIGFsaWFzZXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0b0pTT05Ob3RJbXBsZW1lbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxjOiAxLFxuICAgICAgICAgICAgdHlwZTogXCJub3RfaW1wbGVtZW50ZWRcIixcbiAgICAgICAgICAgIGlkOiB0aGlzLmxjX2lkLFxuICAgICAgICB9O1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/load/serializable.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/messages/ai.js":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/ai.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIMessage: () => (/* binding */ AIMessage),\n/* harmony export */   AIMessageChunk: () => (/* binding */ AIMessageChunk),\n/* harmony export */   isAIMessage: () => (/* binding */ isAIMessage)\n/* harmony export */ });\n/* harmony import */ var _utils_json_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/json.js */ \"(action-browser)/./node_modules/@langchain/core/dist/utils/json.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/base.js\");\n/* harmony import */ var _tool_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tool.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/tool.js\");\n\n\n\n/**\n * Represents an AI message in a conversation.\n */\nclass AIMessage extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseMessage {\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            ...super.lc_aliases,\n            tool_calls: \"tool_calls\",\n            invalid_tool_calls: \"invalid_tool_calls\",\n        };\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        let initParams;\n        if (typeof fields === \"string\") {\n            initParams = {\n                content: fields,\n                tool_calls: [],\n                invalid_tool_calls: [],\n                additional_kwargs: kwargs ?? {},\n            };\n        }\n        else {\n            initParams = fields;\n            const rawToolCalls = initParams.additional_kwargs?.tool_calls;\n            const toolCalls = initParams.tool_calls;\n            if (!(rawToolCalls == null) &&\n                rawToolCalls.length > 0 &&\n                (toolCalls === undefined || toolCalls.length === 0)) {\n                console.warn([\n                    \"New LangChain packages are available that more efficiently handle\",\n                    \"tool calling.\\n\\nPlease upgrade your packages to versions that set\",\n                    \"message tool calls. e.g., `yarn add @langchain/anthropic`,\",\n                    \"yarn add @langchain/openai`, etc.\",\n                ].join(\" \"));\n            }\n            try {\n                if (!(rawToolCalls == null) && toolCalls === undefined) {\n                    const [toolCalls, invalidToolCalls] = (0,_tool_js__WEBPACK_IMPORTED_MODULE_2__.defaultToolCallParser)(rawToolCalls);\n                    initParams.tool_calls = toolCalls ?? [];\n                    initParams.invalid_tool_calls = invalidToolCalls ?? [];\n                }\n                else {\n                    initParams.tool_calls = initParams.tool_calls ?? [];\n                    initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];\n                }\n            }\n            catch (e) {\n                // Do nothing if parsing fails\n                initParams.tool_calls = [];\n                initParams.invalid_tool_calls = [];\n            }\n        }\n        // Sadly, TypeScript only allows super() calls at root if the class has\n        // properties with initializers, so we have to check types twice.\n        super(initParams);\n        // These are typed as optional to avoid breaking changes and allow for casting\n        // from BaseMessage.\n        Object.defineProperty(this, \"tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"invalid_tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        if (typeof initParams !== \"string\") {\n            this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n            this.invalid_tool_calls =\n                initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n        }\n    }\n    static lc_name() {\n        return \"AIMessage\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n}\nfunction isAIMessage(x) {\n    return x._getType() === \"ai\";\n}\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nclass AIMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseMessageChunk {\n    constructor(fields) {\n        let initParams;\n        if (typeof fields === \"string\") {\n            initParams = {\n                content: fields,\n                tool_calls: [],\n                invalid_tool_calls: [],\n                tool_call_chunks: [],\n            };\n        }\n        else if (fields.tool_call_chunks === undefined) {\n            initParams = {\n                ...fields,\n                tool_calls: [],\n                invalid_tool_calls: [],\n                tool_call_chunks: [],\n            };\n        }\n        else {\n            const toolCalls = [];\n            const invalidToolCalls = [];\n            for (const toolCallChunk of fields.tool_call_chunks) {\n                let parsedArgs = {};\n                try {\n                    parsedArgs = (0,_utils_json_js__WEBPACK_IMPORTED_MODULE_0__.parsePartialJson)(toolCallChunk.args ?? \"{}\") ?? {};\n                    if (typeof parsedArgs !== \"object\" || Array.isArray(parsedArgs)) {\n                        throw new Error(\"Malformed tool call chunk args.\");\n                    }\n                    toolCalls.push({\n                        name: toolCallChunk.name ?? \"\",\n                        args: parsedArgs,\n                        id: toolCallChunk.id,\n                    });\n                }\n                catch (e) {\n                    invalidToolCalls.push({\n                        name: toolCallChunk.name,\n                        args: toolCallChunk.args,\n                        id: toolCallChunk.id,\n                        error: \"Malformed args.\",\n                    });\n                }\n            }\n            initParams = {\n                ...fields,\n                tool_calls: toolCalls,\n                invalid_tool_calls: invalidToolCalls,\n            };\n        }\n        // Sadly, TypeScript only allows super() calls at root if the class has\n        // properties with initializers, so we have to check types twice.\n        super(initParams);\n        // Must redeclare tool call fields since there is no multiple inheritance in JS.\n        // These are typed as optional to avoid breaking changes and allow for casting\n        // from BaseMessage.\n        Object.defineProperty(this, \"tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"invalid_tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"tool_call_chunks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        this.tool_call_chunks =\n            initParams?.tool_call_chunks ?? this.tool_call_chunks;\n        this.tool_calls = initParams?.tool_calls ?? this.tool_calls;\n        this.invalid_tool_calls =\n            initParams?.invalid_tool_calls ?? this.invalid_tool_calls;\n    }\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            ...super.lc_aliases,\n            tool_calls: \"tool_calls\",\n            invalid_tool_calls: \"invalid_tool_calls\",\n            tool_call_chunks: \"tool_call_chunks\",\n        };\n    }\n    static lc_name() {\n        return \"AIMessageChunk\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n    concat(chunk) {\n        const combinedFields = {\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_1__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_1__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_1__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            tool_call_chunks: [],\n        };\n        if (this.tool_call_chunks !== undefined ||\n            chunk.tool_call_chunks !== undefined) {\n            const rawToolCalls = (0,_base_js__WEBPACK_IMPORTED_MODULE_1__._mergeLists)(this.tool_call_chunks, chunk.tool_call_chunks);\n            if (rawToolCalls !== undefined && rawToolCalls.length > 0) {\n                combinedFields.tool_call_chunks = rawToolCalls;\n            }\n        }\n        return new AIMessageChunk(combinedFields);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9haS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0Q7QUFDK0M7QUFDaEQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ08sd0JBQXdCLGlEQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELCtEQUFxQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNkJBQTZCLHNEQUFnQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0VBQWdCLDBCQUEwQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBWTtBQUNqQywrQkFBK0IscURBQVc7QUFDMUMsK0JBQStCLHFEQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFEQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcbWVzc2FnZXNcXGFpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlUGFydGlhbEpzb24gfSBmcm9tIFwiLi4vdXRpbHMvanNvbi5qc1wiO1xuaW1wb3J0IHsgQmFzZU1lc3NhZ2UsIEJhc2VNZXNzYWdlQ2h1bmssIG1lcmdlQ29udGVudCwgX21lcmdlRGljdHMsIF9tZXJnZUxpc3RzLCB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbmltcG9ydCB7IGRlZmF1bHRUb29sQ2FsbFBhcnNlciwgfSBmcm9tIFwiLi90b29sLmpzXCI7XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gQUkgbWVzc2FnZSBpbiBhIGNvbnZlcnNhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEFJTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgLy8gZXhjbHVkZSBzbmFrZSBjYXNlIGNvbnZlcnNpb24gdG8gcGFzY2FsIGNhc2VcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLmxjX2FsaWFzZXMsXG4gICAgICAgICAgICB0b29sX2NhbGxzOiBcInRvb2xfY2FsbHNcIixcbiAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogXCJpbnZhbGlkX3Rvb2xfY2FsbHNcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBrd2FyZ3MpIHtcbiAgICAgICAgbGV0IGluaXRQYXJhbXM7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpbml0UGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGZpZWxkcyxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiBbXSxcbiAgICAgICAgICAgICAgICBpbnZhbGlkX3Rvb2xfY2FsbHM6IFtdLFxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiBrd2FyZ3MgPz8ge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5pdFBhcmFtcyA9IGZpZWxkcztcbiAgICAgICAgICAgIGNvbnN0IHJhd1Rvb2xDYWxscyA9IGluaXRQYXJhbXMuYWRkaXRpb25hbF9rd2FyZ3M/LnRvb2xfY2FsbHM7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBpbml0UGFyYW1zLnRvb2xfY2FsbHM7XG4gICAgICAgICAgICBpZiAoIShyYXdUb29sQ2FsbHMgPT0gbnVsbCkgJiZcbiAgICAgICAgICAgICAgICByYXdUb29sQ2FsbHMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICh0b29sQ2FsbHMgPT09IHVuZGVmaW5lZCB8fCB0b29sQ2FsbHMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihbXG4gICAgICAgICAgICAgICAgICAgIFwiTmV3IExhbmdDaGFpbiBwYWNrYWdlcyBhcmUgYXZhaWxhYmxlIHRoYXQgbW9yZSBlZmZpY2llbnRseSBoYW5kbGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0b29sIGNhbGxpbmcuXFxuXFxuUGxlYXNlIHVwZ3JhZGUgeW91ciBwYWNrYWdlcyB0byB2ZXJzaW9ucyB0aGF0IHNldFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm1lc3NhZ2UgdG9vbCBjYWxscy4gZS5nLiwgYHlhcm4gYWRkIEBsYW5nY2hhaW4vYW50aHJvcGljYCxcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ5YXJuIGFkZCBAbGFuZ2NoYWluL29wZW5haWAsIGV0Yy5cIixcbiAgICAgICAgICAgICAgICBdLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmF3VG9vbENhbGxzID09IG51bGwpICYmIHRvb2xDYWxscyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFt0b29sQ2FsbHMsIGludmFsaWRUb29sQ2FsbHNdID0gZGVmYXVsdFRvb2xDYWxsUGFyc2VyKHJhd1Rvb2xDYWxscyk7XG4gICAgICAgICAgICAgICAgICAgIGluaXRQYXJhbXMudG9vbF9jYWxscyA9IHRvb2xDYWxscyA/PyBbXTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFBhcmFtcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPSBpbnZhbGlkVG9vbENhbGxzID8/IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFBhcmFtcy50b29sX2NhbGxzID0gaW5pdFBhcmFtcy50b29sX2NhbGxzID8/IFtdO1xuICAgICAgICAgICAgICAgICAgICBpbml0UGFyYW1zLmludmFsaWRfdG9vbF9jYWxscyA9IGluaXRQYXJhbXMuaW52YWxpZF90b29sX2NhbGxzID8/IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBwYXJzaW5nIGZhaWxzXG4gICAgICAgICAgICAgICAgaW5pdFBhcmFtcy50b29sX2NhbGxzID0gW107XG4gICAgICAgICAgICAgICAgaW5pdFBhcmFtcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTYWRseSwgVHlwZVNjcmlwdCBvbmx5IGFsbG93cyBzdXBlcigpIGNhbGxzIGF0IHJvb3QgaWYgdGhlIGNsYXNzIGhhc1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIHdpdGggaW5pdGlhbGl6ZXJzLCBzbyB3ZSBoYXZlIHRvIGNoZWNrIHR5cGVzIHR3aWNlLlxuICAgICAgICBzdXBlcihpbml0UGFyYW1zKTtcbiAgICAgICAgLy8gVGhlc2UgYXJlIHR5cGVkIGFzIG9wdGlvbmFsIHRvIGF2b2lkIGJyZWFraW5nIGNoYW5nZXMgYW5kIGFsbG93IGZvciBjYXN0aW5nXG4gICAgICAgIC8vIGZyb20gQmFzZU1lc3NhZ2UuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvb2xfY2FsbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnZhbGlkX3Rvb2xfY2FsbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIGluaXRQYXJhbXMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMudG9vbF9jYWxscyA9IGluaXRQYXJhbXMudG9vbF9jYWxscyA/PyB0aGlzLnRvb2xfY2FsbHM7XG4gICAgICAgICAgICB0aGlzLmludmFsaWRfdG9vbF9jYWxscyA9XG4gICAgICAgICAgICAgICAgaW5pdFBhcmFtcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPz8gdGhpcy5pbnZhbGlkX3Rvb2xfY2FsbHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkFJTWVzc2FnZVwiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiYWlcIjtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBSU1lc3NhZ2UoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwiYWlcIjtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGFuIEFJIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aFxuICogb3RoZXIgQUkgbWVzc2FnZSBjaHVua3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBBSU1lc3NhZ2VDaHVuayBleHRlbmRzIEJhc2VNZXNzYWdlQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBsZXQgaW5pdFBhcmFtcztcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGluaXRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY29udGVudDogZmllbGRzLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IFtdLFxuICAgICAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogW10sXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsX2NodW5rczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpZWxkcy50b29sX2NhbGxfY2h1bmtzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluaXRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IFtdLFxuICAgICAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogW10sXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsX2NodW5rczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGxzID0gW107XG4gICAgICAgICAgICBjb25zdCBpbnZhbGlkVG9vbENhbGxzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsQ2h1bmsgb2YgZmllbGRzLnRvb2xfY2FsbF9jaHVua3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkQXJncyA9IHt9O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFyZ3MgPSBwYXJzZVBhcnRpYWxKc29uKHRvb2xDYWxsQ2h1bmsuYXJncyA/PyBcInt9XCIpID8/IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlZEFyZ3MgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShwYXJzZWRBcmdzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHRvb2wgY2FsbCBjaHVuayBhcmdzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sQ2FsbENodW5rLm5hbWUgPz8gXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHBhcnNlZEFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGxDaHVuay5pZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRUb29sQ2FsbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sQ2FsbENodW5rLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiB0b29sQ2FsbENodW5rLmFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGxDaHVuay5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBcIk1hbGZvcm1lZCBhcmdzLlwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbml0UGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiB0b29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiBpbnZhbGlkVG9vbENhbGxzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTYWRseSwgVHlwZVNjcmlwdCBvbmx5IGFsbG93cyBzdXBlcigpIGNhbGxzIGF0IHJvb3QgaWYgdGhlIGNsYXNzIGhhc1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIHdpdGggaW5pdGlhbGl6ZXJzLCBzbyB3ZSBoYXZlIHRvIGNoZWNrIHR5cGVzIHR3aWNlLlxuICAgICAgICBzdXBlcihpbml0UGFyYW1zKTtcbiAgICAgICAgLy8gTXVzdCByZWRlY2xhcmUgdG9vbCBjYWxsIGZpZWxkcyBzaW5jZSB0aGVyZSBpcyBubyBtdWx0aXBsZSBpbmhlcml0YW5jZSBpbiBKUy5cbiAgICAgICAgLy8gVGhlc2UgYXJlIHR5cGVkIGFzIG9wdGlvbmFsIHRvIGF2b2lkIGJyZWFraW5nIGNoYW5nZXMgYW5kIGFsbG93IGZvciBjYXN0aW5nXG4gICAgICAgIC8vIGZyb20gQmFzZU1lc3NhZ2UuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvb2xfY2FsbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnZhbGlkX3Rvb2xfY2FsbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b29sX2NhbGxfY2h1bmtzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b29sX2NhbGxfY2h1bmtzID1cbiAgICAgICAgICAgIGluaXRQYXJhbXM/LnRvb2xfY2FsbF9jaHVua3MgPz8gdGhpcy50b29sX2NhbGxfY2h1bmtzO1xuICAgICAgICB0aGlzLnRvb2xfY2FsbHMgPSBpbml0UGFyYW1zPy50b29sX2NhbGxzID8/IHRoaXMudG9vbF9jYWxscztcbiAgICAgICAgdGhpcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPVxuICAgICAgICAgICAgaW5pdFBhcmFtcz8uaW52YWxpZF90b29sX2NhbGxzID8/IHRoaXMuaW52YWxpZF90b29sX2NhbGxzO1xuICAgIH1cbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgLy8gZXhjbHVkZSBzbmFrZSBjYXNlIGNvbnZlcnNpb24gdG8gcGFzY2FsIGNhc2VcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLmxjX2FsaWFzZXMsXG4gICAgICAgICAgICB0b29sX2NhbGxzOiBcInRvb2xfY2FsbHNcIixcbiAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogXCJpbnZhbGlkX3Rvb2xfY2FsbHNcIixcbiAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IFwidG9vbF9jYWxsX2NodW5rc1wiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQUlNZXNzYWdlQ2h1bmtcIjtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImFpXCI7XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICBjb25zdCBjb21iaW5lZEZpZWxkcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1lcmdlQ29udGVudCh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IF9tZXJnZURpY3RzKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiBfbWVyZ2VEaWN0cyh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMudG9vbF9jYWxsX2NodW5rcyAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBjaHVuay50b29sX2NhbGxfY2h1bmtzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhd1Rvb2xDYWxscyA9IF9tZXJnZUxpc3RzKHRoaXMudG9vbF9jYWxsX2NodW5rcywgY2h1bmsudG9vbF9jYWxsX2NodW5rcyk7XG4gICAgICAgICAgICBpZiAocmF3VG9vbENhbGxzICE9PSB1bmRlZmluZWQgJiYgcmF3VG9vbENhbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb21iaW5lZEZpZWxkcy50b29sX2NhbGxfY2h1bmtzID0gcmF3VG9vbENhbGxzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQUlNZXNzYWdlQ2h1bmsoY29tYmluZWRGaWVsZHMpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/messages/ai.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/messages/base.js":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/base.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseMessage: () => (/* binding */ BaseMessage),\n/* harmony export */   BaseMessageChunk: () => (/* binding */ BaseMessageChunk),\n/* harmony export */   _mergeDicts: () => (/* binding */ _mergeDicts),\n/* harmony export */   _mergeLists: () => (/* binding */ _mergeLists),\n/* harmony export */   isBaseMessage: () => (/* binding */ isBaseMessage),\n/* harmony export */   isBaseMessageChunk: () => (/* binding */ isBaseMessageChunk),\n/* harmony export */   isOpenAIToolCallArray: () => (/* binding */ isOpenAIToolCallArray),\n/* harmony export */   mergeContent: () => (/* binding */ mergeContent)\n/* harmony export */ });\n/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../load/serializable.js */ \"(action-browser)/./node_modules/@langchain/core/dist/load/serializable.js\");\n\nfunction mergeContent(firstContent, secondContent) {\n    // If first content is a string\n    if (typeof firstContent === \"string\") {\n        if (typeof secondContent === \"string\") {\n            return firstContent + secondContent;\n        }\n        else {\n            return [{ type: \"text\", text: firstContent }, ...secondContent];\n        }\n        // If both are arrays\n    }\n    else if (Array.isArray(secondContent)) {\n        return [...firstContent, ...secondContent];\n        // If the first content is a list and second is a string\n    }\n    else {\n        // Otherwise, add the second content as a new element of the list\n        return [...firstContent, { type: \"text\", text: secondContent }];\n    }\n}\n/**\n * Base class for all types of messages in a conversation. It includes\n * properties like `content`, `name`, and `additional_kwargs`. It also\n * includes methods like `toDict()` and `_getType()`.\n */\nclass BaseMessage extends _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.Serializable {\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            additional_kwargs: \"additional_kwargs\",\n            response_metadata: \"response_metadata\",\n        };\n    }\n    /**\n     * @deprecated\n     * Use {@link BaseMessage.content} instead.\n     */\n    get text() {\n        return typeof this.content === \"string\" ? this.content : \"\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            fields = {\n                content: fields,\n                additional_kwargs: kwargs,\n                response_metadata: {},\n            };\n        }\n        // Make sure the default value for additional_kwargs is passed into super() for serialization\n        if (!fields.additional_kwargs) {\n            // eslint-disable-next-line no-param-reassign\n            fields.additional_kwargs = {};\n        }\n        if (!fields.response_metadata) {\n            // eslint-disable-next-line no-param-reassign\n            fields.response_metadata = {};\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"messages\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /** The content of the message. */\n        Object.defineProperty(this, \"content\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** The name of the message sender in a multi-user chat. */\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Additional keyword arguments */\n        Object.defineProperty(this, \"additional_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Response metadata. For example: response headers, logprobs, token counts. */\n        Object.defineProperty(this, \"response_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.content = fields.content;\n        this.additional_kwargs = fields.additional_kwargs;\n        this.response_metadata = fields.response_metadata;\n    }\n    toDict() {\n        return {\n            type: this._getType(),\n            data: this.toJSON()\n                .kwargs,\n        };\n    }\n}\nfunction isOpenAIToolCallArray(value) {\n    return (Array.isArray(value) &&\n        value.every((v) => typeof v.index === \"number\"));\n}\nfunction _mergeDicts(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nleft, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nright\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    const merged = { ...left };\n    for (const [key, value] of Object.entries(right)) {\n        if (merged[key] == null) {\n            merged[key] = value;\n        }\n        else if (value == null) {\n            continue;\n        }\n        else if (typeof merged[key] !== typeof value ||\n            Array.isArray(merged[key]) !== Array.isArray(value)) {\n            throw new Error(`field[${key}] already exists in the message chunk, but with a different type.`);\n        }\n        else if (typeof merged[key] === \"string\") {\n            merged[key] = merged[key] + value;\n        }\n        else if (!Array.isArray(merged[key]) && typeof merged[key] === \"object\") {\n            merged[key] = _mergeDicts(merged[key], value);\n        }\n        else if (Array.isArray(merged[key])) {\n            merged[key] = _mergeLists(merged[key], value);\n        }\n        else if (merged[key] === value) {\n            continue;\n        }\n        else {\n            console.warn(`field[${key}] already exists in this message chunk and value has unsupported type.`);\n        }\n    }\n    return merged;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _mergeLists(left, right) {\n    if (left === undefined && right === undefined) {\n        return undefined;\n    }\n    else if (left === undefined || right === undefined) {\n        return left || right;\n    }\n    else {\n        const merged = [...left];\n        for (const item of right) {\n            if (typeof item === \"object\" &&\n                \"index\" in item &&\n                typeof item.index === \"number\") {\n                const toMerge = merged.findIndex((leftItem) => leftItem.index === item.index);\n                if (toMerge !== -1) {\n                    merged[toMerge] = _mergeDicts(merged[toMerge], item);\n                }\n                else {\n                    merged.push(item);\n                }\n            }\n            else {\n                merged.push(item);\n            }\n        }\n        return merged;\n    }\n}\n/**\n * Represents a chunk of a message, which can be concatenated with other\n * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n * additional keyword arguments from another `BaseMessageChunk` into this\n * one. It also overrides the `__add__()` method to support concatenation\n * of `BaseMessageChunk` instances.\n */\nclass BaseMessageChunk extends BaseMessage {\n}\nfunction isBaseMessage(messageLike) {\n    return typeof messageLike?._getType === \"function\";\n}\nfunction isBaseMessageChunk(messageLike) {\n    return (isBaseMessage(messageLike) &&\n        typeof messageLike.concat === \"function\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9iYXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF1RDtBQUNoRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQ0FBa0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1DQUFtQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBCQUEwQiwrREFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLElBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcbWVzc2FnZXNcXGJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2VyaWFsaXphYmxlIH0gZnJvbSBcIi4uL2xvYWQvc2VyaWFsaXphYmxlLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VDb250ZW50KGZpcnN0Q29udGVudCwgc2Vjb25kQ29udGVudCkge1xuICAgIC8vIElmIGZpcnN0IGNvbnRlbnQgaXMgYSBzdHJpbmdcbiAgICBpZiAodHlwZW9mIGZpcnN0Q29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIHNlY29uZENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdENvbnRlbnQgKyBzZWNvbmRDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBmaXJzdENvbnRlbnQgfSwgLi4uc2Vjb25kQ29udGVudF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYm90aCBhcmUgYXJyYXlzXG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2Vjb25kQ29udGVudCkpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5maXJzdENvbnRlbnQsIC4uLnNlY29uZENvbnRlbnRdO1xuICAgICAgICAvLyBJZiB0aGUgZmlyc3QgY29udGVudCBpcyBhIGxpc3QgYW5kIHNlY29uZCBpcyBhIHN0cmluZ1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBhZGQgdGhlIHNlY29uZCBjb250ZW50IGFzIGEgbmV3IGVsZW1lbnQgb2YgdGhlIGxpc3RcbiAgICAgICAgcmV0dXJuIFsuLi5maXJzdENvbnRlbnQsIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHNlY29uZENvbnRlbnQgfV07XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgdHlwZXMgb2YgbWVzc2FnZXMgaW4gYSBjb252ZXJzYXRpb24uIEl0IGluY2x1ZGVzXG4gKiBwcm9wZXJ0aWVzIGxpa2UgYGNvbnRlbnRgLCBgbmFtZWAsIGFuZCBgYWRkaXRpb25hbF9rd2FyZ3NgLiBJdCBhbHNvXG4gKiBpbmNsdWRlcyBtZXRob2RzIGxpa2UgYHRvRGljdCgpYCBhbmQgYF9nZXRUeXBlKClgLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZU1lc3NhZ2UgZXh0ZW5kcyBTZXJpYWxpemFibGUge1xuICAgIGdldCBsY19hbGlhc2VzKCkge1xuICAgICAgICAvLyBleGNsdWRlIHNuYWtlIGNhc2UgY29udmVyc2lvbiB0byBwYXNjYWwgY2FzZVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IFwiYWRkaXRpb25hbF9rd2FyZ3NcIixcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiBcInJlc3BvbnNlX21ldGFkYXRhXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogVXNlIHtAbGluayBCYXNlTWVzc2FnZS5jb250ZW50fSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuY29udGVudCA9PT0gXCJzdHJpbmdcIiA/IHRoaXMuY29udGVudCA6IFwiXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAga3dhcmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGZpZWxkcyA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBmaWVsZHMsXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IGt3YXJncyxcbiAgICAgICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YToge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgYWRkaXRpb25hbF9rd2FyZ3MgaXMgcGFzc2VkIGludG8gc3VwZXIoKSBmb3Igc2VyaWFsaXphdGlvblxuICAgICAgICBpZiAoIWZpZWxkcy5hZGRpdGlvbmFsX2t3YXJncykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMuYWRkaXRpb25hbF9rd2FyZ3MgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZpZWxkcy5yZXNwb25zZV9tZXRhZGF0YSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMucmVzcG9uc2VfbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwibWVzc2FnZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFRoZSBjb250ZW50IG9mIHRoZSBtZXNzYWdlLiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250ZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgbWVzc2FnZSBzZW5kZXIgaW4gYSBtdWx0aS11c2VyIGNoYXQuICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEFkZGl0aW9uYWwga2V5d29yZCBhcmd1bWVudHMgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWRkaXRpb25hbF9rd2FyZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFJlc3BvbnNlIG1ldGFkYXRhLiBGb3IgZXhhbXBsZTogcmVzcG9uc2UgaGVhZGVycywgbG9ncHJvYnMsIHRva2VuIGNvdW50cy4gKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzcG9uc2VfbWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gZmllbGRzLm5hbWU7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGZpZWxkcy5jb250ZW50O1xuICAgICAgICB0aGlzLmFkZGl0aW9uYWxfa3dhcmdzID0gZmllbGRzLmFkZGl0aW9uYWxfa3dhcmdzO1xuICAgICAgICB0aGlzLnJlc3BvbnNlX21ldGFkYXRhID0gZmllbGRzLnJlc3BvbnNlX21ldGFkYXRhO1xuICAgIH1cbiAgICB0b0RpY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLl9nZXRUeXBlKCksXG4gICAgICAgICAgICBkYXRhOiB0aGlzLnRvSlNPTigpXG4gICAgICAgICAgICAgICAgLmt3YXJncyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNPcGVuQUlUb29sQ2FsbEFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxuICAgICAgICB2YWx1ZS5ldmVyeSgodikgPT4gdHlwZW9mIHYuaW5kZXggPT09IFwibnVtYmVyXCIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfbWVyZ2VEaWN0cyhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5sZWZ0LCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5yaWdodFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbikge1xuICAgIGNvbnN0IG1lcmdlZCA9IHsgLi4ubGVmdCB9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJpZ2h0KSkge1xuICAgICAgICBpZiAobWVyZ2VkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVyZ2VkW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVyZ2VkW2tleV0gIT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShtZXJnZWRba2V5XSkgIT09IEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZpZWxkWyR7a2V5fV0gYWxyZWFkeSBleGlzdHMgaW4gdGhlIG1lc3NhZ2UgY2h1bmssIGJ1dCB3aXRoIGEgZGlmZmVyZW50IHR5cGUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1lcmdlZFtrZXldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtZXJnZWRba2V5XSA9IG1lcmdlZFtrZXldICsgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWVyZ2VkW2tleV0pICYmIHR5cGVvZiBtZXJnZWRba2V5XSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgbWVyZ2VkW2tleV0gPSBfbWVyZ2VEaWN0cyhtZXJnZWRba2V5XSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobWVyZ2VkW2tleV0pKSB7XG4gICAgICAgICAgICBtZXJnZWRba2V5XSA9IF9tZXJnZUxpc3RzKG1lcmdlZFtrZXldLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWVyZ2VkW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgZmllbGRbJHtrZXl9XSBhbHJlYWR5IGV4aXN0cyBpbiB0aGlzIG1lc3NhZ2UgY2h1bmsgYW5kIHZhbHVlIGhhcyB1bnN1cHBvcnRlZCB0eXBlLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWQ7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGZ1bmN0aW9uIF9tZXJnZUxpc3RzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPT09IHVuZGVmaW5lZCAmJiByaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlZnQgPT09IHVuZGVmaW5lZCB8fCByaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWZ0IHx8IHJpZ2h0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gWy4uLmxlZnRdO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcmlnaHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIFwiaW5kZXhcIiBpbiBpdGVtICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGl0ZW0uaW5kZXggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b01lcmdlID0gbWVyZ2VkLmZpbmRJbmRleCgobGVmdEl0ZW0pID0+IGxlZnRJdGVtLmluZGV4ID09PSBpdGVtLmluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAodG9NZXJnZSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkW3RvTWVyZ2VdID0gX21lcmdlRGljdHMobWVyZ2VkW3RvTWVyZ2VdLCBpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlZC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSBtZXNzYWdlLCB3aGljaCBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbiAqIG1lc3NhZ2UgY2h1bmtzLiBJdCBpbmNsdWRlcyBhIG1ldGhvZCBgX21lcmdlX2t3YXJnc19kaWN0KClgIGZvciBtZXJnaW5nXG4gKiBhZGRpdGlvbmFsIGtleXdvcmQgYXJndW1lbnRzIGZyb20gYW5vdGhlciBgQmFzZU1lc3NhZ2VDaHVua2AgaW50byB0aGlzXG4gKiBvbmUuIEl0IGFsc28gb3ZlcnJpZGVzIHRoZSBgX19hZGRfXygpYCBtZXRob2QgdG8gc3VwcG9ydCBjb25jYXRlbmF0aW9uXG4gKiBvZiBgQmFzZU1lc3NhZ2VDaHVua2AgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZU1lc3NhZ2VDaHVuayBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Jhc2VNZXNzYWdlKG1lc3NhZ2VMaWtlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlTGlrZT8uX2dldFR5cGUgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Jhc2VNZXNzYWdlQ2h1bmsobWVzc2FnZUxpa2UpIHtcbiAgICByZXR1cm4gKGlzQmFzZU1lc3NhZ2UobWVzc2FnZUxpa2UpICYmXG4gICAgICAgIHR5cGVvZiBtZXNzYWdlTGlrZS5jb25jYXQgPT09IFwiZnVuY3Rpb25cIik7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/messages/base.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/messages/chat.js":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/chat.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatMessage: () => (/* binding */ ChatMessage),\n/* harmony export */   ChatMessageChunk: () => (/* binding */ ChatMessageChunk)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/base.js\");\n\n/**\n * Represents a chat message in a conversation.\n */\nclass ChatMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage {\n    static lc_name() {\n        return \"ChatMessage\";\n    }\n    static _chatMessageClass() {\n        return ChatMessage;\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"generic\";\n    }\n}\n/**\n * Represents a chunk of a chat message, which can be concatenated with\n * other chat message chunks.\n */\nclass ChatMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk {\n    static lc_name() {\n        return \"ChatMessageChunk\";\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    concat(chunk) {\n        return new ChatMessageChunk({\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            role: this.role,\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9jaGF0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDTywwQkFBMEIsaURBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLHNEQUFnQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQVk7QUFDakMsK0JBQStCLHFEQUFXO0FBQzFDLCtCQUErQixxREFBVztBQUMxQztBQUNBLFNBQVM7QUFDVDtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcbWVzc2FnZXNcXGNoYXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZU1lc3NhZ2UsIEJhc2VNZXNzYWdlQ2h1bmssIG1lcmdlQ29udGVudCwgX21lcmdlRGljdHMsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2hhdCBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgQ2hhdE1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkNoYXRNZXNzYWdlXCI7XG4gICAgfVxuICAgIHN0YXRpYyBfY2hhdE1lc3NhZ2VDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIENoYXRNZXNzYWdlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHJvbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZmllbGRzID0geyBjb250ZW50OiBmaWVsZHMsIHJvbGU6IHJvbGUgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb2xlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucm9sZSA9IGZpZWxkcy5yb2xlO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2VuZXJpY1wiO1xuICAgIH1cbiAgICBzdGF0aWMgaXNJbnN0YW5jZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLl9nZXRUeXBlKCkgPT09IFwiZ2VuZXJpY1wiO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGEgY2hhdCBtZXNzYWdlLCB3aGljaCBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGhcbiAqIG90aGVyIGNoYXQgbWVzc2FnZSBjaHVua3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBDaGF0TWVzc2FnZUNodW5rIGV4dGVuZHMgQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkNoYXRNZXNzYWdlQ2h1bmtcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCByb2xlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsgY29udGVudDogZmllbGRzLCByb2xlOiByb2xlIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicm9sZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJvbGUgPSBmaWVsZHMucm9sZTtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImdlbmVyaWNcIjtcbiAgICB9XG4gICAgY29uY2F0KGNodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhdE1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICBjb250ZW50OiBtZXJnZUNvbnRlbnQodGhpcy5jb250ZW50LCBjaHVuay5jb250ZW50KSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiBfbWVyZ2VEaWN0cyh0aGlzLmFkZGl0aW9uYWxfa3dhcmdzLCBjaHVuay5hZGRpdGlvbmFsX2t3YXJncyksXG4gICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogX21lcmdlRGljdHModGhpcy5yZXNwb25zZV9tZXRhZGF0YSwgY2h1bmsucmVzcG9uc2VfbWV0YWRhdGEpLFxuICAgICAgICAgICAgcm9sZTogdGhpcy5yb2xlLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/messages/chat.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/messages/function.js":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/function.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionMessage: () => (/* binding */ FunctionMessage),\n/* harmony export */   FunctionMessageChunk: () => (/* binding */ FunctionMessageChunk)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/base.js\");\n\n/**\n * Represents a function message in a conversation.\n */\nclass FunctionMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage {\n    static lc_name() {\n        return \"FunctionMessage\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name: name };\n        }\n        super(fields);\n    }\n    _getType() {\n        return \"function\";\n    }\n}\n/**\n * Represents a chunk of a function message, which can be concatenated\n * with other function message chunks.\n */\nclass FunctionMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk {\n    static lc_name() {\n        return \"FunctionMessageChunk\";\n    }\n    _getType() {\n        return \"function\";\n    }\n    concat(chunk) {\n        return new FunctionMessageChunk({\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            name: this.name ?? \"\",\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9mdW5jdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ08sOEJBQThCLGlEQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQyxzREFBZ0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBWTtBQUNqQywrQkFBK0IscURBQVc7QUFDMUMsK0JBQStCLHFEQUFXO0FBQzFDO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxtZXNzYWdlc1xcZnVuY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZU1lc3NhZ2UsIEJhc2VNZXNzYWdlQ2h1bmssIG1lcmdlQ29udGVudCwgX21lcmdlRGljdHMsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgZnVuY3Rpb24gbWVzc2FnZSBpbiBhIGNvbnZlcnNhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiRnVuY3Rpb25NZXNzYWdlXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgbmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBmaWVsZHMgPSB7IGNvbnRlbnQ6IGZpZWxkcywgbmFtZTogbmFtZSB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGEgZnVuY3Rpb24gbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZFxuICogd2l0aCBvdGhlciBmdW5jdGlvbiBtZXNzYWdlIGNodW5rcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uTWVzc2FnZUNodW5rIGV4dGVuZHMgQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkZ1bmN0aW9uTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbk1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICBjb250ZW50OiBtZXJnZUNvbnRlbnQodGhpcy5jb250ZW50LCBjaHVuay5jb250ZW50KSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiBfbWVyZ2VEaWN0cyh0aGlzLmFkZGl0aW9uYWxfa3dhcmdzLCBjaHVuay5hZGRpdGlvbmFsX2t3YXJncyksXG4gICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogX21lcmdlRGljdHModGhpcy5yZXNwb25zZV9tZXRhZGF0YSwgY2h1bmsucmVzcG9uc2VfbWV0YWRhdGEpLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lID8/IFwiXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/messages/function.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/messages/human.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/human.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HumanMessage: () => (/* binding */ HumanMessage),\n/* harmony export */   HumanMessageChunk: () => (/* binding */ HumanMessageChunk)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/base.js\");\n\n/**\n * Represents a human message in a conversation.\n */\nclass HumanMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage {\n    static lc_name() {\n        return \"HumanMessage\";\n    }\n    _getType() {\n        return \"human\";\n    }\n}\n/**\n * Represents a chunk of a human message, which can be concatenated with\n * other human message chunks.\n */\nclass HumanMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk {\n    static lc_name() {\n        return \"HumanMessageChunk\";\n    }\n    _getType() {\n        return \"human\";\n    }\n    concat(chunk) {\n        return new HumanMessageChunk({\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9odW1hbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ08sMkJBQTJCLGlEQUFXO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0Msc0RBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQVk7QUFDakMsK0JBQStCLHFEQUFXO0FBQzFDLCtCQUErQixxREFBVztBQUMxQyxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXG1lc3NhZ2VzXFxodW1hbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlTWVzc2FnZSwgQmFzZU1lc3NhZ2VDaHVuaywgbWVyZ2VDb250ZW50LCBfbWVyZ2VEaWN0cywgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBodW1hbiBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgSHVtYW5NZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJIdW1hbk1lc3NhZ2VcIjtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImh1bWFuXCI7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSBodW1hbiBtZXNzYWdlLCB3aGljaCBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGhcbiAqIG90aGVyIGh1bWFuIG1lc3NhZ2UgY2h1bmtzLlxuICovXG5leHBvcnQgY2xhc3MgSHVtYW5NZXNzYWdlQ2h1bmsgZXh0ZW5kcyBCYXNlTWVzc2FnZUNodW5rIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSHVtYW5NZXNzYWdlQ2h1bmtcIjtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImh1bWFuXCI7XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IEh1bWFuTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1lcmdlQ29udGVudCh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IF9tZXJnZURpY3RzKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiBfbWVyZ2VEaWN0cyh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/messages/human.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/messages/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIMessage: () => (/* reexport safe */ _ai_js__WEBPACK_IMPORTED_MODULE_0__.AIMessage),\n/* harmony export */   AIMessageChunk: () => (/* reexport safe */ _ai_js__WEBPACK_IMPORTED_MODULE_0__.AIMessageChunk),\n/* harmony export */   BaseMessage: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseMessage),\n/* harmony export */   BaseMessageChunk: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseMessageChunk),\n/* harmony export */   ChatMessage: () => (/* reexport safe */ _chat_js__WEBPACK_IMPORTED_MODULE_2__.ChatMessage),\n/* harmony export */   ChatMessageChunk: () => (/* reexport safe */ _chat_js__WEBPACK_IMPORTED_MODULE_2__.ChatMessageChunk),\n/* harmony export */   FunctionMessage: () => (/* reexport safe */ _function_js__WEBPACK_IMPORTED_MODULE_3__.FunctionMessage),\n/* harmony export */   FunctionMessageChunk: () => (/* reexport safe */ _function_js__WEBPACK_IMPORTED_MODULE_3__.FunctionMessageChunk),\n/* harmony export */   HumanMessage: () => (/* reexport safe */ _human_js__WEBPACK_IMPORTED_MODULE_4__.HumanMessage),\n/* harmony export */   HumanMessageChunk: () => (/* reexport safe */ _human_js__WEBPACK_IMPORTED_MODULE_4__.HumanMessageChunk),\n/* harmony export */   SystemMessage: () => (/* reexport safe */ _system_js__WEBPACK_IMPORTED_MODULE_5__.SystemMessage),\n/* harmony export */   SystemMessageChunk: () => (/* reexport safe */ _system_js__WEBPACK_IMPORTED_MODULE_5__.SystemMessageChunk),\n/* harmony export */   ToolMessage: () => (/* reexport safe */ _tool_js__WEBPACK_IMPORTED_MODULE_7__.ToolMessage),\n/* harmony export */   ToolMessageChunk: () => (/* reexport safe */ _tool_js__WEBPACK_IMPORTED_MODULE_7__.ToolMessageChunk),\n/* harmony export */   _mergeDicts: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__._mergeDicts),\n/* harmony export */   _mergeLists: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__._mergeLists),\n/* harmony export */   coerceMessageLikeToMessage: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.coerceMessageLikeToMessage),\n/* harmony export */   convertToChunk: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.convertToChunk),\n/* harmony export */   getBufferString: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.getBufferString),\n/* harmony export */   isAIMessage: () => (/* reexport safe */ _ai_js__WEBPACK_IMPORTED_MODULE_0__.isAIMessage),\n/* harmony export */   isBaseMessage: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.isBaseMessage),\n/* harmony export */   isBaseMessageChunk: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.isBaseMessageChunk),\n/* harmony export */   isOpenAIToolCallArray: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.isOpenAIToolCallArray),\n/* harmony export */   mapChatMessagesToStoredMessages: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapChatMessagesToStoredMessages),\n/* harmony export */   mapStoredMessageToChatMessage: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapStoredMessageToChatMessage),\n/* harmony export */   mapStoredMessagesToChatMessages: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.mapStoredMessagesToChatMessages),\n/* harmony export */   mergeContent: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.mergeContent)\n/* harmony export */ });\n/* harmony import */ var _ai_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ai.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/ai.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/base.js\");\n/* harmony import */ var _chat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chat.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/chat.js\");\n/* harmony import */ var _function_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./function.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/function.js\");\n/* harmony import */ var _human_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./human.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/human.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./system.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/system.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/utils.js\");\n/* harmony import */ var _tool_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tool.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/tool.js\");\n\n\n\n\n\n\n\n// TODO: Use a star export when we deprecate the\n// existing \"ToolCall\" type in \"base.js\".\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QjtBQUNFO0FBQ0E7QUFDSTtBQUNIO0FBQ0M7QUFDRDtBQUMzQjtBQUNBO0FBQzJEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcbWVzc2FnZXNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL2FpLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9iYXNlLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jaGF0LmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9mdW5jdGlvbi5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaHVtYW4uanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3N5c3RlbS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8vIFRPRE86IFVzZSBhIHN0YXIgZXhwb3J0IHdoZW4gd2UgZGVwcmVjYXRlIHRoZVxuLy8gZXhpc3RpbmcgXCJUb29sQ2FsbFwiIHR5cGUgaW4gXCJiYXNlLmpzXCIuXG5leHBvcnQgeyBUb29sTWVzc2FnZSwgVG9vbE1lc3NhZ2VDaHVuaywgfSBmcm9tIFwiLi90b29sLmpzXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/messages/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/messages/system.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/system.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SystemMessage: () => (/* binding */ SystemMessage),\n/* harmony export */   SystemMessageChunk: () => (/* binding */ SystemMessageChunk)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/base.js\");\n\n/**\n * Represents a system message in a conversation.\n */\nclass SystemMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage {\n    static lc_name() {\n        return \"SystemMessage\";\n    }\n    _getType() {\n        return \"system\";\n    }\n}\n/**\n * Represents a chunk of a system message, which can be concatenated with\n * other system message chunks.\n */\nclass SystemMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk {\n    static lc_name() {\n        return \"SystemMessageChunk\";\n    }\n    _getType() {\n        return \"system\";\n    }\n    concat(chunk) {\n        return new SystemMessageChunk({\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9zeXN0ZW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNPLDRCQUE0QixpREFBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08saUNBQWlDLHNEQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNEQUFZO0FBQ2pDLCtCQUErQixxREFBVztBQUMxQywrQkFBK0IscURBQVc7QUFDMUMsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxtZXNzYWdlc1xcc3lzdGVtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VNZXNzYWdlLCBCYXNlTWVzc2FnZUNodW5rLCBtZXJnZUNvbnRlbnQsIF9tZXJnZURpY3RzLCB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbi8qKlxuICogUmVwcmVzZW50cyBhIHN5c3RlbSBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgU3lzdGVtTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3lzdGVtTWVzc2FnZVwiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwic3lzdGVtXCI7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSBzeXN0ZW0gbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoXG4gKiBvdGhlciBzeXN0ZW0gbWVzc2FnZSBjaHVua3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBTeXN0ZW1NZXNzYWdlQ2h1bmsgZXh0ZW5kcyBCYXNlTWVzc2FnZUNodW5rIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3lzdGVtTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJzeXN0ZW1cIjtcbiAgICB9XG4gICAgY29uY2F0KGNodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3lzdGVtTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1lcmdlQ29udGVudCh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IF9tZXJnZURpY3RzKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiBfbWVyZ2VEaWN0cyh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/messages/system.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/messages/tool.js":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/tool.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ToolMessage: () => (/* binding */ ToolMessage),\n/* harmony export */   ToolMessageChunk: () => (/* binding */ ToolMessageChunk),\n/* harmony export */   defaultToolCallParser: () => (/* binding */ defaultToolCallParser)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/base.js\");\n\n/**\n * Represents a tool message in a conversation.\n */\nclass ToolMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage {\n    static lc_name() {\n        return \"ToolMessage\";\n    }\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return { tool_call_id: \"tool_call_id\" };\n    }\n    constructor(fields, tool_call_id, name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name, tool_call_id: tool_call_id };\n        }\n        super(fields);\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n    }\n    _getType() {\n        return \"tool\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"tool\";\n    }\n}\n/**\n * Represents a chunk of a tool message, which can be concatenated\n * with other tool message chunks.\n */\nclass ToolMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n    }\n    static lc_name() {\n        return \"ToolMessageChunk\";\n    }\n    _getType() {\n        return \"tool\";\n    }\n    concat(chunk) {\n        return new ToolMessageChunk({\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            tool_call_id: this.tool_call_id,\n        });\n    }\n}\nfunction defaultToolCallParser(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrawToolCalls) {\n    const toolCalls = [];\n    const invalidToolCalls = [];\n    for (const toolCall of rawToolCalls) {\n        if (!toolCall.function) {\n            continue;\n        }\n        else {\n            const functionName = toolCall.function.name;\n            try {\n                const functionArgs = JSON.parse(toolCall.function.arguments);\n                const parsed = {\n                    name: functionName || \"\",\n                    args: functionArgs || {},\n                    id: toolCall.id,\n                };\n                toolCalls.push(parsed);\n            }\n            catch (error) {\n                invalidToolCalls.push({\n                    name: functionName,\n                    args: toolCall.function.arguments,\n                    id: toolCall.id,\n                    error: \"Malformed args.\",\n                });\n            }\n        }\n    }\n    return [toolCalls, invalidToolCalls];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy90b29sLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ08sMEJBQTBCLGlEQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0Isc0RBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNEQUFZO0FBQ2pDLCtCQUErQixxREFBVztBQUMxQywrQkFBK0IscURBQVc7QUFDMUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcbWVzc2FnZXNcXHRvb2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZU1lc3NhZ2UsIEJhc2VNZXNzYWdlQ2h1bmssIG1lcmdlQ29udGVudCwgX21lcmdlRGljdHMsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgdG9vbCBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgVG9vbE1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlRvb2xNZXNzYWdlXCI7XG4gICAgfVxuICAgIGdldCBsY19hbGlhc2VzKCkge1xuICAgICAgICAvLyBleGNsdWRlIHNuYWtlIGNhc2UgY29udmVyc2lvbiB0byBwYXNjYWwgY2FzZVxuICAgICAgICByZXR1cm4geyB0b29sX2NhbGxfaWQ6IFwidG9vbF9jYWxsX2lkXCIgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCB0b29sX2NhbGxfaWQsIG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZmllbGRzID0geyBjb250ZW50OiBmaWVsZHMsIG5hbWUsIHRvb2xfY2FsbF9pZDogdG9vbF9jYWxsX2lkIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9vbF9jYWxsX2lkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9vbF9jYWxsX2lkID0gZmllbGRzLnRvb2xfY2FsbF9pZDtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcInRvb2xcIjtcbiAgICB9XG4gICAgc3RhdGljIGlzSW5zdGFuY2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZS5fZ2V0VHlwZSgpID09PSBcInRvb2xcIjtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaHVuayBvZiBhIHRvb2wgbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZFxuICogd2l0aCBvdGhlciB0b29sIG1lc3NhZ2UgY2h1bmtzLlxuICovXG5leHBvcnQgY2xhc3MgVG9vbE1lc3NhZ2VDaHVuayBleHRlbmRzIEJhc2VNZXNzYWdlQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b29sX2NhbGxfaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b29sX2NhbGxfaWQgPSBmaWVsZHMudG9vbF9jYWxsX2lkO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiVG9vbE1lc3NhZ2VDaHVua1wiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwidG9vbFwiO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb29sTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1lcmdlQ29udGVudCh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IF9tZXJnZURpY3RzKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiBfbWVyZ2VEaWN0cyh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHRoaXMudG9vbF9jYWxsX2lkLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFRvb2xDYWxsUGFyc2VyKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnJhd1Rvb2xDYWxscykge1xuICAgIGNvbnN0IHRvb2xDYWxscyA9IFtdO1xuICAgIGNvbnN0IGludmFsaWRUb29sQ2FsbHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIHJhd1Rvb2xDYWxscykge1xuICAgICAgICBpZiAoIXRvb2xDYWxsLmZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQXJncyA9IEpTT04ucGFyc2UodG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uTmFtZSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBmdW5jdGlvbkFyZ3MgfHwge30sXG4gICAgICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRvb2xDYWxscy5wdXNoKHBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpbnZhbGlkVG9vbENhbGxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogXCJNYWxmb3JtZWQgYXJncy5cIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3Rvb2xDYWxscywgaW52YWxpZFRvb2xDYWxsc107XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/messages/tool.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/messages/utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/utils.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   coerceMessageLikeToMessage: () => (/* binding */ coerceMessageLikeToMessage),\n/* harmony export */   convertToChunk: () => (/* binding */ convertToChunk),\n/* harmony export */   getBufferString: () => (/* binding */ getBufferString),\n/* harmony export */   mapChatMessagesToStoredMessages: () => (/* binding */ mapChatMessagesToStoredMessages),\n/* harmony export */   mapStoredMessageToChatMessage: () => (/* binding */ mapStoredMessageToChatMessage),\n/* harmony export */   mapStoredMessagesToChatMessages: () => (/* binding */ mapStoredMessagesToChatMessages)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/base.js\");\n/* harmony import */ var _human_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./human.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/human.js\");\n/* harmony import */ var _ai_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ai.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/ai.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./system.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/system.js\");\n/* harmony import */ var _chat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chat.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/chat.js\");\n/* harmony import */ var _function_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./function.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/function.js\");\n/* harmony import */ var _tool_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tool.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/tool.js\");\n\n\n\n\n\n\n\nfunction coerceMessageLikeToMessage(messageLike) {\n    if (typeof messageLike === \"string\") {\n        return new _human_js__WEBPACK_IMPORTED_MODULE_1__.HumanMessage(messageLike);\n    }\n    else if ((0,_base_js__WEBPACK_IMPORTED_MODULE_0__.isBaseMessage)(messageLike)) {\n        return messageLike;\n    }\n    const [type, content] = messageLike;\n    if (type === \"human\" || type === \"user\") {\n        return new _human_js__WEBPACK_IMPORTED_MODULE_1__.HumanMessage({ content });\n    }\n    else if (type === \"ai\" || type === \"assistant\") {\n        return new _ai_js__WEBPACK_IMPORTED_MODULE_2__.AIMessage({ content });\n    }\n    else if (type === \"system\") {\n        return new _system_js__WEBPACK_IMPORTED_MODULE_3__.SystemMessage({ content });\n    }\n    else {\n        throw new Error(`Unable to coerce message from array: only human, AI, or system message coercion is currently supported.`);\n    }\n}\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nfunction getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n    const string_messages = [];\n    for (const m of messages) {\n        let role;\n        if (m._getType() === \"human\") {\n            role = humanPrefix;\n        }\n        else if (m._getType() === \"ai\") {\n            role = aiPrefix;\n        }\n        else if (m._getType() === \"system\") {\n            role = \"System\";\n        }\n        else if (m._getType() === \"function\") {\n            role = \"Function\";\n        }\n        else if (m._getType() === \"tool\") {\n            role = \"Tool\";\n        }\n        else if (m._getType() === \"generic\") {\n            role = m.role;\n        }\n        else {\n            throw new Error(`Got unsupported message type: ${m._getType()}`);\n        }\n        const nameStr = m.name ? `${m.name}, ` : \"\";\n        string_messages.push(`${role}: ${nameStr}${m.content}`);\n    }\n    return string_messages.join(\"\\n\");\n}\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(message) {\n    // TODO: Remove this mapper when we deprecate the old message format.\n    if (message.data !== undefined) {\n        return message;\n    }\n    else {\n        const v1Message = message;\n        return {\n            type: v1Message.type,\n            data: {\n                content: v1Message.text,\n                role: v1Message.role,\n                name: undefined,\n                tool_call_id: undefined,\n            },\n        };\n    }\n}\nfunction mapStoredMessageToChatMessage(message) {\n    const storedMessage = mapV1MessageToStoredMessage(message);\n    switch (storedMessage.type) {\n        case \"human\":\n            return new _human_js__WEBPACK_IMPORTED_MODULE_1__.HumanMessage(storedMessage.data);\n        case \"ai\":\n            return new _ai_js__WEBPACK_IMPORTED_MODULE_2__.AIMessage(storedMessage.data);\n        case \"system\":\n            return new _system_js__WEBPACK_IMPORTED_MODULE_3__.SystemMessage(storedMessage.data);\n        case \"function\":\n            if (storedMessage.data.name === undefined) {\n                throw new Error(\"Name must be defined for function messages\");\n            }\n            return new _function_js__WEBPACK_IMPORTED_MODULE_5__.FunctionMessage(storedMessage.data);\n        case \"tool\":\n            if (storedMessage.data.tool_call_id === undefined) {\n                throw new Error(\"Tool call ID must be defined for tool messages\");\n            }\n            return new _tool_js__WEBPACK_IMPORTED_MODULE_6__.ToolMessage(storedMessage.data);\n        case \"chat\": {\n            if (storedMessage.data.role === undefined) {\n                throw new Error(\"Role must be defined for chat messages\");\n            }\n            return new _chat_js__WEBPACK_IMPORTED_MODULE_4__.ChatMessage(storedMessage.data);\n        }\n        default:\n            throw new Error(`Got unexpected type: ${storedMessage.type}`);\n    }\n}\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nfunction mapStoredMessagesToChatMessages(messages) {\n    return messages.map(mapStoredMessageToChatMessage);\n}\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nfunction mapChatMessagesToStoredMessages(messages) {\n    return messages.map((message) => message.toDict());\n}\nfunction convertToChunk(message) {\n    const type = message._getType();\n    if (type === \"human\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new _human_js__WEBPACK_IMPORTED_MODULE_1__.HumanMessageChunk({ ...message });\n    }\n    else if (type === \"ai\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new _ai_js__WEBPACK_IMPORTED_MODULE_2__.AIMessageChunk({ ...message });\n    }\n    else if (type === \"system\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new _system_js__WEBPACK_IMPORTED_MODULE_3__.SystemMessageChunk({ ...message });\n    }\n    else if (type === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new _function_js__WEBPACK_IMPORTED_MODULE_5__.FunctionMessageChunk({ ...message });\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    }\n    else if (_chat_js__WEBPACK_IMPORTED_MODULE_4__.ChatMessage.isInstance(message)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new _chat_js__WEBPACK_IMPORTED_MODULE_4__.ChatMessageChunk({ ...message });\n    }\n    else {\n        throw new Error(\"Unknown message type.\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQ2tCO0FBQ1Q7QUFDWTtBQUNMO0FBQ1k7QUFDL0I7QUFDakM7QUFDUDtBQUNBLG1CQUFtQixtREFBWTtBQUMvQjtBQUNBLGFBQWEsdURBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbURBQVksR0FBRyxTQUFTO0FBQzNDO0FBQ0E7QUFDQSxtQkFBbUIsNkNBQVMsR0FBRyxTQUFTO0FBQ3hDO0FBQ0E7QUFDQSxtQkFBbUIscURBQWEsR0FBRyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsYUFBYTtBQUMxRTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDLGdDQUFnQyxLQUFLLElBQUksUUFBUSxFQUFFLFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFZO0FBQ25DO0FBQ0EsdUJBQXVCLDZDQUFTO0FBQ2hDO0FBQ0EsdUJBQXVCLHFEQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFXO0FBQ2xDO0FBQ0E7QUFDQSxvREFBb0QsbUJBQW1CO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQWlCLEdBQUcsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQWMsR0FBRyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwREFBa0IsR0FBRyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4REFBb0IsR0FBRyxZQUFZO0FBQ3REO0FBQ0E7QUFDQSxhQUFhLGlEQUFXO0FBQ3hCO0FBQ0EsbUJBQW1CLHNEQUFnQixHQUFHLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXG1lc3NhZ2VzXFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0Jhc2VNZXNzYWdlLCB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbmltcG9ydCB7IEh1bWFuTWVzc2FnZSwgSHVtYW5NZXNzYWdlQ2h1bmsgfSBmcm9tIFwiLi9odW1hbi5qc1wiO1xuaW1wb3J0IHsgQUlNZXNzYWdlLCBBSU1lc3NhZ2VDaHVuayB9IGZyb20gXCIuL2FpLmpzXCI7XG5pbXBvcnQgeyBTeXN0ZW1NZXNzYWdlLCBTeXN0ZW1NZXNzYWdlQ2h1bmsgfSBmcm9tIFwiLi9zeXN0ZW0uanNcIjtcbmltcG9ydCB7IENoYXRNZXNzYWdlLCBDaGF0TWVzc2FnZUNodW5rLCB9IGZyb20gXCIuL2NoYXQuanNcIjtcbmltcG9ydCB7IEZ1bmN0aW9uTWVzc2FnZSwgRnVuY3Rpb25NZXNzYWdlQ2h1bmssIH0gZnJvbSBcIi4vZnVuY3Rpb24uanNcIjtcbmltcG9ydCB7IFRvb2xNZXNzYWdlIH0gZnJvbSBcIi4vdG9vbC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlKG1lc3NhZ2VMaWtlKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlTGlrZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbmV3IEh1bWFuTWVzc2FnZShtZXNzYWdlTGlrZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQmFzZU1lc3NhZ2UobWVzc2FnZUxpa2UpKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlTGlrZTtcbiAgICB9XG4gICAgY29uc3QgW3R5cGUsIGNvbnRlbnRdID0gbWVzc2FnZUxpa2U7XG4gICAgaWYgKHR5cGUgPT09IFwiaHVtYW5cIiB8fCB0eXBlID09PSBcInVzZXJcIikge1xuICAgICAgICByZXR1cm4gbmV3IEh1bWFuTWVzc2FnZSh7IGNvbnRlbnQgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiYWlcIiB8fCB0eXBlID09PSBcImFzc2lzdGFudFwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgQUlNZXNzYWdlKHsgY29udGVudCB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJzeXN0ZW1cIikge1xuICAgICAgICByZXR1cm4gbmV3IFN5c3RlbU1lc3NhZ2UoeyBjb250ZW50IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY29lcmNlIG1lc3NhZ2UgZnJvbSBhcnJheTogb25seSBodW1hbiwgQUksIG9yIHN5c3RlbSBtZXNzYWdlIGNvZXJjaW9uIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuYCk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgbWVtb3J5IGNsYXNzZXMgdG8gZ2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBvZiB0aGUgY2hhdCBtZXNzYWdlIGhpc3RvcnksIGJhc2VkIG9uIHRoZSBtZXNzYWdlIGNvbnRlbnQgYW5kIHJvbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCdWZmZXJTdHJpbmcobWVzc2FnZXMsIGh1bWFuUHJlZml4ID0gXCJIdW1hblwiLCBhaVByZWZpeCA9IFwiQUlcIikge1xuICAgIGNvbnN0IHN0cmluZ19tZXNzYWdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbSBvZiBtZXNzYWdlcykge1xuICAgICAgICBsZXQgcm9sZTtcbiAgICAgICAgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJodW1hblwiKSB7XG4gICAgICAgICAgICByb2xlID0gaHVtYW5QcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobS5fZ2V0VHlwZSgpID09PSBcImFpXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBhaVByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLl9nZXRUeXBlKCkgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBcIlN5c3RlbVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByb2xlID0gXCJGdW5jdGlvblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJ0b29sXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBcIlRvb2xcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLl9nZXRUeXBlKCkgPT09IFwiZ2VuZXJpY1wiKSB7XG4gICAgICAgICAgICByb2xlID0gbS5yb2xlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgdW5zdXBwb3J0ZWQgbWVzc2FnZSB0eXBlOiAke20uX2dldFR5cGUoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lU3RyID0gbS5uYW1lID8gYCR7bS5uYW1lfSwgYCA6IFwiXCI7XG4gICAgICAgIHN0cmluZ19tZXNzYWdlcy5wdXNoKGAke3JvbGV9OiAke25hbWVTdHJ9JHttLmNvbnRlbnR9YCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdfbWVzc2FnZXMuam9pbihcIlxcblwiKTtcbn1cbi8qKlxuICogTWFwcyBtZXNzYWdlcyBmcm9tIGFuIG9sZGVyIGZvcm1hdCAoVjEpIHRvIHRoZSBjdXJyZW50IGBTdG9yZWRNZXNzYWdlYFxuICogZm9ybWF0LiBJZiB0aGUgbWVzc2FnZSBpcyBhbHJlYWR5IGluIHRoZSBgU3RvcmVkTWVzc2FnZWAgZm9ybWF0LCBpdCBpc1xuICogcmV0dXJuZWQgYXMgaXMuIE90aGVyd2lzZSwgaXQgdHJhbnNmb3JtcyB0aGUgVjEgbWVzc2FnZSBpbnRvIGFcbiAqIGBTdG9yZWRNZXNzYWdlYC4gVGhpcyBmdW5jdGlvbiBpcyBpbXBvcnRhbnQgZm9yIG1haW50YWluaW5nXG4gKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgbWVzc2FnZSBmb3JtYXRzLlxuICovXG5mdW5jdGlvbiBtYXBWMU1lc3NhZ2VUb1N0b3JlZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIG1hcHBlciB3aGVuIHdlIGRlcHJlY2F0ZSB0aGUgb2xkIG1lc3NhZ2UgZm9ybWF0LlxuICAgIGlmIChtZXNzYWdlLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHYxTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB2MU1lc3NhZ2UudHlwZSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiB2MU1lc3NhZ2UudGV4dCxcbiAgICAgICAgICAgICAgICByb2xlOiB2MU1lc3NhZ2Uucm9sZSxcbiAgICAgICAgICAgICAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBtYXBTdG9yZWRNZXNzYWdlVG9DaGF0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3Qgc3RvcmVkTWVzc2FnZSA9IG1hcFYxTWVzc2FnZVRvU3RvcmVkTWVzc2FnZShtZXNzYWdlKTtcbiAgICBzd2l0Y2ggKHN0b3JlZE1lc3NhZ2UudHlwZSkge1xuICAgICAgICBjYXNlIFwiaHVtYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSHVtYW5NZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGNhc2UgXCJhaVwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBSU1lc3NhZ2Uoc3RvcmVkTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgY2FzZSBcInN5c3RlbVwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTeXN0ZW1NZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgaWYgKHN0b3JlZE1lc3NhZ2UuZGF0YS5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lIG11c3QgYmUgZGVmaW5lZCBmb3IgZnVuY3Rpb24gbWVzc2FnZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uTWVzc2FnZShzdG9yZWRNZXNzYWdlLmRhdGEpO1xuICAgICAgICBjYXNlIFwidG9vbFwiOlxuICAgICAgICAgICAgaWYgKHN0b3JlZE1lc3NhZ2UuZGF0YS50b29sX2NhbGxfaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvb2wgY2FsbCBJRCBtdXN0IGJlIGRlZmluZWQgZm9yIHRvb2wgbWVzc2FnZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRvb2xNZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGNhc2UgXCJjaGF0XCI6IHtcbiAgICAgICAgICAgIGlmIChzdG9yZWRNZXNzYWdlLmRhdGEucm9sZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9sZSBtdXN0IGJlIGRlZmluZWQgZm9yIGNoYXQgbWVzc2FnZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYXRNZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHVuZXhwZWN0ZWQgdHlwZTogJHtzdG9yZWRNZXNzYWdlLnR5cGV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIGFycmF5IG9mIGBTdG9yZWRNZXNzYWdlYCBpbnN0YW5jZXMgaW50byBhbiBhcnJheSBvZlxuICogYEJhc2VNZXNzYWdlYCBpbnN0YW5jZXMuIEl0IHVzZXMgdGhlIGBtYXBWMU1lc3NhZ2VUb1N0b3JlZE1lc3NhZ2VgXG4gKiBmdW5jdGlvbiB0byBlbnN1cmUgYWxsIG1lc3NhZ2VzIGFyZSBpbiB0aGUgYFN0b3JlZE1lc3NhZ2VgIGZvcm1hdCwgdGhlblxuICogY3JlYXRlcyBuZXcgaW5zdGFuY2VzIG9mIHRoZSBhcHByb3ByaWF0ZSBgQmFzZU1lc3NhZ2VgIHN1YmNsYXNzIGJhc2VkXG4gKiBvbiB0aGUgdHlwZSBvZiBlYWNoIG1lc3NhZ2UuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBwcmVwYXJlIHN0b3JlZFxuICogbWVzc2FnZXMgZm9yIHVzZSBpbiBhIGNoYXQgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFN0b3JlZE1lc3NhZ2VzVG9DaGF0TWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICByZXR1cm4gbWVzc2FnZXMubWFwKG1hcFN0b3JlZE1lc3NhZ2VUb0NoYXRNZXNzYWdlKTtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiBgQmFzZU1lc3NhZ2VgIGluc3RhbmNlcyBpbnRvIGFuIGFycmF5IG9mXG4gKiBgU3RvcmVkTWVzc2FnZWAgaW5zdGFuY2VzLiBJdCBkb2VzIHRoaXMgYnkgY2FsbGluZyB0aGUgYHRvRGljdGAgbWV0aG9kXG4gKiBvbiBlYWNoIGBCYXNlTWVzc2FnZWAsIHdoaWNoIHJldHVybnMgYSBgU3RvcmVkTWVzc2FnZWAuIFRoaXMgZnVuY3Rpb25cbiAqIGlzIHVzZWQgdG8gcHJlcGFyZSBjaGF0IG1lc3NhZ2VzIGZvciBzdG9yYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwQ2hhdE1lc3NhZ2VzVG9TdG9yZWRNZXNzYWdlcyhtZXNzYWdlcykge1xuICAgIHJldHVybiBtZXNzYWdlcy5tYXAoKG1lc3NhZ2UpID0+IG1lc3NhZ2UudG9EaWN0KCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb0NodW5rKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5fZ2V0VHlwZSgpO1xuICAgIGlmICh0eXBlID09PSBcImh1bWFuXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IEh1bWFuTWVzc2FnZUNodW5rKHsgLi4ubWVzc2FnZSB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJhaVwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBBSU1lc3NhZ2VDaHVuayh7IC4uLm1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFN5c3RlbU1lc3NhZ2VDaHVuayh7IC4uLm1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25NZXNzYWdlQ2h1bmsoeyAuLi5tZXNzYWdlIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgfVxuICAgIGVsc2UgaWYgKENoYXRNZXNzYWdlLmlzSW5zdGFuY2UobWVzc2FnZSkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IENoYXRNZXNzYWdlQ2h1bmsoeyAuLi5tZXNzYWdlIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBtZXNzYWdlIHR5cGUuXCIpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/messages/utils.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/runnables/base.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/base.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Runnable: () => (/* binding */ Runnable),\n/* harmony export */   RunnableAssign: () => (/* binding */ RunnableAssign),\n/* harmony export */   RunnableBinding: () => (/* binding */ RunnableBinding),\n/* harmony export */   RunnableEach: () => (/* binding */ RunnableEach),\n/* harmony export */   RunnableLambda: () => (/* binding */ RunnableLambda),\n/* harmony export */   RunnableMap: () => (/* binding */ RunnableMap),\n/* harmony export */   RunnableParallel: () => (/* binding */ RunnableParallel),\n/* harmony export */   RunnablePick: () => (/* binding */ RunnablePick),\n/* harmony export */   RunnableRetry: () => (/* binding */ RunnableRetry),\n/* harmony export */   RunnableSequence: () => (/* binding */ RunnableSequence),\n/* harmony export */   RunnableWithFallbacks: () => (/* binding */ RunnableWithFallbacks),\n/* harmony export */   _coerceToDict: () => (/* binding */ _coerceToDict),\n/* harmony export */   _coerceToRunnable: () => (/* binding */ _coerceToRunnable)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/lib/index.mjs\");\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(action-browser)/./node_modules/p-retry/index.js\");\n/* harmony import */ var _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../callbacks/manager.js */ \"(action-browser)/./node_modules/@langchain/core/dist/callbacks/manager.js\");\n/* harmony import */ var _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tracers/log_stream.js */ \"(action-browser)/./node_modules/@langchain/core/dist/tracers/log_stream.js\");\n/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../load/serializable.js */ \"(action-browser)/./node_modules/@langchain/core/dist/load/serializable.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/stream.js */ \"(action-browser)/./node_modules/@langchain/core/dist/utils/stream.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config.js */ \"(action-browser)/./node_modules/@langchain/core/dist/runnables/config.js\");\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/async_caller.js */ \"(action-browser)/./node_modules/@langchain/core/dist/utils/async_caller.js\");\n/* harmony import */ var _tracers_root_listener_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tracers/root_listener.js */ \"(action-browser)/./node_modules/@langchain/core/dist/tracers/root_listener.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@langchain/core/dist/runnables/utils.js\");\n/* harmony import */ var _singletons_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../singletons/index.js */ \"(action-browser)/./node_modules/@langchain/core/dist/singletons/index.js\");\n/* harmony import */ var _graph_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./graph.js */ \"(action-browser)/./node_modules/@langchain/core/dist/runnables/graph.js\");\n/* harmony import */ var _wrappers_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./wrappers.js */ \"(action-browser)/./node_modules/@langchain/core/dist/runnables/wrappers.js\");\n/* harmony import */ var _iter_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./iter.js */ \"(action-browser)/./node_modules/@langchain/core/dist/runnables/iter.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value &&\n        !Array.isArray(value) &&\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        !(value instanceof Date) &&\n        typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nclass Runnable extends _load_serializable_js__WEBPACK_IMPORTED_MODULE_3__.Serializable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    getName(suffix) {\n        const name = \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.name ?? this.constructor.lc_name() ?? this.constructor.name;\n        return suffix ? `${name}${suffix}` : name;\n    }\n    /**\n     * Bind arguments to a Runnable, returning a new Runnable.\n     * @param kwargs\n     * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n     */\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({ bound: this, kwargs, config: {} });\n    }\n    /**\n     * Return a new Runnable that maps a list of inputs to a list of outputs,\n     * by calling invoke() with each input.\n     */\n    map() {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableEach({ bound: this });\n    }\n    /**\n     * Add retry logic to an existing runnable.\n     * @param kwargs\n     * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n     */\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableRetry({\n            bound: this,\n            kwargs: {},\n            config: {},\n            maxAttemptNumber: fields?.stopAfterAttempt,\n            ...fields,\n        });\n    }\n    /**\n     * Bind config to a Runnable, returning a new Runnable.\n     * @param config New configuration parameters to attach to the new runnable.\n     * @returns A new RunnableBinding with a config matching what's passed.\n     */\n    withConfig(config) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config,\n            kwargs: {},\n        });\n    }\n    /**\n     * Create a new runnable from the current one that will try invoking\n     * other passed fallback runnables if the initial invocation fails.\n     * @param fields.fallbacks Other runnables to call if the runnable errors.\n     * @returns A new RunnableWithFallbacks.\n     */\n    withFallbacks(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableWithFallbacks({\n            runnable: this,\n            fallbacks: fields.fallbacks,\n        });\n    }\n    _getOptionsList(options, length = 0) {\n        if (Array.isArray(options) && options.length !== length) {\n            throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n        }\n        if (Array.isArray(options)) {\n            return options.map(_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig);\n        }\n        if (length > 1 && !Array.isArray(options) && options.runId) {\n            console.warn(\"Provided runId will be used only for the first element of the batch.\");\n            const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== \"runId\"));\n            return Array.from({ length }, (_, i) => (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(i === 0 ? options : subsequent));\n        }\n        return Array.from({ length }, () => (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(options));\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_6__.AsyncCaller({\n            maxConcurrency,\n            onFailedAttempt: (e) => {\n                throw e;\n            },\n        });\n        const batchCalls = inputs.map((input, i) => caller.call(async () => {\n            try {\n                const result = await this.invoke(input, configList[i]);\n                return result;\n            }\n            catch (e) {\n                if (batchOptions?.returnExceptions) {\n                    return e;\n                }\n                throw e;\n            }\n        }));\n        return Promise.all(batchCalls);\n    }\n    /**\n     * Default streaming implementation.\n     * Subclasses should override this method if they support streaming output.\n     * @param input\n     * @param options\n     */\n    async *_streamIterator(input, options) {\n        yield this.invoke(input, options);\n    }\n    /**\n     * Stream output in chunks.\n     * @param input\n     * @param options\n     * @returns A readable stream that is also an iterable.\n     */\n    async stream(input, options) {\n        // Buffer the first streamed chunk to allow for initial errors\n        // to surface immediately.\n        const wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.AsyncGeneratorWithSetup(this._streamIterator(input, (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(options)));\n        await wrappedGenerator.setup;\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n    _separateRunnableConfigFromCallOptions(options) {\n        let runnableConfig;\n        if (options === undefined) {\n            runnableConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(options);\n        }\n        else {\n            runnableConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)({\n                callbacks: options.callbacks,\n                tags: options.tags,\n                metadata: options.metadata,\n                runName: options.runName,\n                configurable: options.configurable,\n                recursionLimit: options.recursionLimit,\n                maxConcurrency: options.maxConcurrency,\n                runId: options.runId,\n            });\n        }\n        const callOptions = { ...options };\n        delete callOptions.callbacks;\n        delete callOptions.tags;\n        delete callOptions.metadata;\n        delete callOptions.runName;\n        delete callOptions.configurable;\n        delete callOptions.recursionLimit;\n        delete callOptions.maxConcurrency;\n        delete callOptions.runId;\n        return [runnableConfig, callOptions];\n    }\n    async _callWithConfig(func, input, options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(options);\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, config?.runType, undefined, undefined, config?.runName ?? this.getName());\n        delete config.runId;\n        let output;\n        try {\n            output = await func.call(this, input, config, runManager);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n    }\n    /**\n     * Internal method that handles batching and configuration for a runnable\n     * It takes a function, input values, and optional configuration, and\n     * returns a promise that resolves to the output values.\n     * @param func The function to be executed for each input value.\n     * @param input The input values to be processed.\n     * @param config Optional configuration for the function execution.\n     * @returns A promise that resolves to the output values.\n     */\n    async _batchWithConfig(func, inputs, options, batchOptions) {\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(optionsList.map(_config_js__WEBPACK_IMPORTED_MODULE_5__.getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), optionsList[i].runId, optionsList[i].runType, undefined, undefined, optionsList[i].runName ?? this.getName());\n            delete optionsList[i].runId;\n            return handleStartRes;\n        }));\n        let outputs;\n        try {\n            outputs = await func.call(this, inputs, optionsList, runManagers, batchOptions);\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))));\n        return outputs;\n    }\n    /**\n     * Helper method to transform an Iterator of Input values into an Iterator of\n     * Output values, with callbacks.\n     * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n     */\n    async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n        let finalInput;\n        let finalInputSupported = true;\n        let finalOutput;\n        let finalOutputSupported = true;\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(options);\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.getCallbackManagerForConfig)(config);\n        async function* wrapInputForTracing() {\n            for await (const chunk of inputGenerator) {\n                if (finalInputSupported) {\n                    if (finalInput === undefined) {\n                        finalInput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalInput = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.concat)(finalInput, chunk);\n                        }\n                        catch {\n                            finalInput = undefined;\n                            finalInputSupported = false;\n                        }\n                    }\n                }\n                yield chunk;\n            }\n        }\n        let runManager;\n        try {\n            const pipe = await (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.pipeGeneratorWithSetup)(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), { input: \"\" }, config.runId, config.runType, undefined, undefined, config.runName ?? this.getName()), config);\n            delete config.runId;\n            runManager = pipe.setup;\n            const isLogStreamHandler = (handler) => handler.name === \"log_stream_tracer\";\n            const streamLogHandler = runManager?.handlers.find(isLogStreamHandler);\n            let iterator = pipe.output;\n            if (streamLogHandler !== undefined && runManager !== undefined) {\n                iterator = await streamLogHandler.tapOutputIterable(runManager.runId, pipe.output);\n            }\n            for await (const chunk of iterator) {\n                yield chunk;\n                if (finalOutputSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.concat)(finalOutput, chunk);\n                        }\n                        catch {\n                            finalOutput = undefined;\n                            finalOutputSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e, undefined, undefined, undefined, {\n                inputs: _coerceToDict(finalInput, \"input\"),\n            });\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, { inputs: _coerceToDict(finalInput, \"input\") });\n    }\n    getGraph(_) {\n        const graph = new _graph_js__WEBPACK_IMPORTED_MODULE_10__.Graph();\n        // TODO: Add input schema for runnables\n        const inputNode = graph.addNode({\n            name: `${this.getName()}Input`,\n            schema: zod__WEBPACK_IMPORTED_MODULE_13__.z.any(),\n        });\n        const runnableNode = graph.addNode(this);\n        // TODO: Add output schemas for runnables\n        const outputNode = graph.addNode({\n            name: `${this.getName()}Output`,\n            schema: zod__WEBPACK_IMPORTED_MODULE_13__.z.any(),\n        });\n        graph.addEdge(inputNode, runnableNode);\n        graph.addEdge(runnableNode, outputNode);\n        return graph;\n    }\n    /**\n     * Create a new runnable sequence that runs each individual runnable in series,\n     * piping the output of one runnable into another runnable or runnable-like.\n     * @param coerceable A runnable, function, or object whose values are functions or runnables.\n     * @returns A new runnable sequence.\n     */\n    pipe(coerceable) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableSequence({\n            first: this,\n            last: _coerceToRunnable(coerceable),\n        });\n    }\n    /**\n     * Pick keys from the dict output of this runnable. Returns a new runnable.\n     */\n    pick(keys) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return this.pipe(new RunnablePick(keys));\n    }\n    /**\n     * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n     */\n    assign(mapping) {\n        return this.pipe(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableAssign(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableMap({ steps: mapping })));\n    }\n    /**\n     * Default implementation of transform, which buffers input and then calls stream.\n     * Subclasses should override this method if they can start producing output while\n     * input is still being generated.\n     * @param generator\n     * @param options\n     */\n    async *transform(generator, options) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                // This method should throw an error if gathering fails.\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                finalChunk = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.concat)(finalChunk, chunk);\n            }\n        }\n        yield* this._streamIterator(finalChunk, (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(options));\n    }\n    /**\n     * Stream all output from a runnable, as reported to the callback system.\n     * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n     * Output is streamed as Log objects, which include a list of\n     * jsonpatch ops that describe how the state of the run has changed in each\n     * step, and the final state of the run.\n     * The jsonpatch ops can be applied in order to construct state.\n     * @param input\n     * @param options\n     * @param streamOptions\n     */\n    async *streamLog(input, options, streamOptions) {\n        const logStreamCallbackHandler = new _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"original\",\n        });\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(options);\n        yield* this._streamLog(input, logStreamCallbackHandler, config);\n    }\n    async *_streamLog(input, logStreamCallbackHandler, config) {\n        const { callbacks } = config;\n        if (callbacks === undefined) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = [logStreamCallbackHandler];\n        }\n        else if (Array.isArray(callbacks)) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.inheritableHandlers.push(logStreamCallbackHandler);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        const runnableStreamPromise = this.stream(input, config);\n        async function consumeRunnableStream() {\n            try {\n                const runnableStream = await runnableStreamPromise;\n                for await (const chunk of runnableStream) {\n                    const patch = new _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: \"/streamed_output/-\",\n                                value: chunk,\n                            },\n                        ],\n                    });\n                    await logStreamCallbackHandler.writer.write(patch);\n                }\n            }\n            finally {\n                await logStreamCallbackHandler.writer.close();\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        try {\n            for await (const log of logStreamCallbackHandler) {\n                yield log;\n            }\n        }\n        finally {\n            await runnableStreamConsumePromise;\n        }\n    }\n    async *streamEvents(input, options, streamOptions) {\n        if (options.encoding === \"text/event-stream\") {\n            const stream = await this._streamEvents(input, options, streamOptions);\n            yield* (0,_wrappers_js__WEBPACK_IMPORTED_MODULE_11__.convertToHttpEventStream)(stream);\n        }\n        else {\n            yield* this._streamEvents(input, options, streamOptions);\n        }\n    }\n    async *_streamEvents(input, options, streamOptions) {\n        if (options.version !== \"v1\") {\n            throw new Error(`Only version \"v1\" of the events schema is currently supported.`);\n        }\n        let runLog;\n        let hasEncounteredStartEvent = false;\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(options);\n        const rootTags = config.tags ?? [];\n        const rootMetadata = config.metadata ?? {};\n        const rootName = config.runName ?? this.getName();\n        const logStreamCallbackHandler = new _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"streaming_events\",\n        });\n        const rootEventFilter = new _utils_js__WEBPACK_IMPORTED_MODULE_8__._RootEventFilter({\n            ...streamOptions,\n        });\n        const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n        for await (const log of logStream) {\n            if (!runLog) {\n                runLog = _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.RunLog.fromRunLogPatch(log);\n            }\n            else {\n                runLog = runLog.concat(log);\n            }\n            if (runLog.state === undefined) {\n                throw new Error(`Internal error: \"streamEvents\" state is missing. Please open a bug report.`);\n            }\n            // Yield the start event for the root runnable if it hasn't been seen.\n            // The root run is never filtered out\n            if (!hasEncounteredStartEvent) {\n                hasEncounteredStartEvent = true;\n                const state = { ...runLog.state };\n                const event = {\n                    run_id: state.id,\n                    event: `on_${state.type}_start`,\n                    name: rootName,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    data: {\n                        input,\n                    },\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n            const paths = log.ops\n                .filter((op) => op.path.startsWith(\"/logs/\"))\n                .map((op) => op.path.split(\"/\")[2]);\n            const dedupedPaths = [...new Set(paths)];\n            for (const path of dedupedPaths) {\n                let eventType;\n                let data = {};\n                const logEntry = runLog.state.logs[path];\n                if (logEntry.end_time === undefined) {\n                    if (logEntry.streamed_output.length > 0) {\n                        eventType = \"stream\";\n                    }\n                    else {\n                        eventType = \"start\";\n                    }\n                }\n                else {\n                    eventType = \"end\";\n                }\n                if (eventType === \"start\") {\n                    // Include the inputs with the start event if they are available.\n                    // Usually they will NOT be available for components that operate\n                    // on streams, since those components stream the input and\n                    // don't know its final value until the end of the stream.\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                }\n                else if (eventType === \"end\") {\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                    data.output = logEntry.final_output;\n                }\n                else if (eventType === \"stream\") {\n                    const chunkCount = logEntry.streamed_output.length;\n                    if (chunkCount !== 1) {\n                        throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`);\n                    }\n                    data = { chunk: logEntry.streamed_output[0] };\n                    // Clean up the stream, we don't need it anymore.\n                    // And this avoids duplicates as well!\n                    logEntry.streamed_output = [];\n                }\n                yield {\n                    event: `on_${logEntry.type}_${eventType}`,\n                    name: logEntry.name,\n                    run_id: logEntry.id,\n                    tags: logEntry.tags,\n                    metadata: logEntry.metadata,\n                    data,\n                };\n            }\n            // Finally, we take care of the streaming output from the root chain\n            // if there is any.\n            const { state } = runLog;\n            if (state.streamed_output.length > 0) {\n                const chunkCount = state.streamed_output.length;\n                if (chunkCount !== 1) {\n                    throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`);\n                }\n                const data = { chunk: state.streamed_output[0] };\n                // Clean up the stream, we don't need it anymore.\n                state.streamed_output = [];\n                const event = {\n                    event: `on_${state.type}_stream`,\n                    run_id: state.id,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    name: rootName,\n                    data,\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n        }\n        const state = runLog?.state;\n        if (state !== undefined) {\n            // Finally, yield the end event for the root runnable.\n            const event = {\n                event: `on_${state.type}_end`,\n                name: rootName,\n                run_id: state.id,\n                tags: rootTags,\n                metadata: rootMetadata,\n                data: {\n                    output: state.final_output,\n                },\n            };\n            if (rootEventFilter.includeEvent(event, state.type))\n                yield event;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnable(thing) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_8__.isRunnableInterface)(thing);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config: {},\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new _tracers_root_listener_js__WEBPACK_IMPORTED_MODULE_7__.RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n}\n/**\n * A runnable that delegates calls to another runnable with a set of kwargs.\n */\nclass RunnableBinding extends Runnable {\n    static lc_name() {\n        return \"RunnableBinding\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"configFactories\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n        this.kwargs = fields.kwargs;\n        this.config = fields.config;\n        this.configFactories = fields.configFactories;\n    }\n    getName(suffix) {\n        return this.bound.getName(suffix);\n    }\n    async _mergeConfig(...options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.mergeConfigs)(this.config, ...options);\n        return (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.mergeConfigs)(config, ...(this.configFactories\n            ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config)))\n            : []));\n    }\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: { ...this.kwargs, ...kwargs },\n            config: this.config,\n        });\n    }\n    withConfig(config) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: { ...this.config, ...config },\n        });\n    }\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound.withRetry(fields),\n            kwargs: this.kwargs,\n            config: this.config,\n        });\n    }\n    async invoke(input, options) {\n        return this.bound.invoke(input, await this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(options), this.kwargs));\n    }\n    async batch(inputs, options, batchOptions) {\n        const mergedOptions = Array.isArray(options)\n            ? await Promise.all(options.map(async (individualOption) => this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(individualOption), this.kwargs)))\n            : await this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(options), this.kwargs);\n        return this.bound.batch(inputs, mergedOptions, batchOptions);\n    }\n    async *_streamIterator(input, options) {\n        yield* this.bound._streamIterator(input, await this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(options), this.kwargs));\n    }\n    async stream(input, options) {\n        return this.bound.stream(input, await this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(options), this.kwargs));\n    }\n    async *transform(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    generator, options) {\n        yield* this.bound.transform(generator, await this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(options), this.kwargs));\n    }\n    async *streamEvents(input, options, streamOptions) {\n        yield* this.bound.streamEvents(input, {\n            ...(await this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(options), this.kwargs)),\n            version: options.version,\n        }, streamOptions);\n    }\n    static isRunnableBinding(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    thing\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        return thing.bound && Runnable.isRunnable(thing.bound);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableBinding({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new _tracers_root_listener_js__WEBPACK_IMPORTED_MODULE_7__.RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n}\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n */\nclass RunnableEach extends Runnable {\n    static lc_name() {\n        return \"RunnableEach\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n    }\n    /**\n     * Binds the runnable with the specified arguments.\n     * @param kwargs The arguments to bind the runnable with.\n     * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.\n     */\n    bind(kwargs) {\n        return new RunnableEach({\n            bound: this.bound.bind(kwargs),\n        });\n    }\n    /**\n     * Invokes the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(inputs, config) {\n        return this._callWithConfig(this._invoke, inputs, config);\n    }\n    /**\n     * A helper method that is used to invoke the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async _invoke(inputs, config, runManager) {\n        return this.bound.batch(inputs, (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.patchConfig)(config, { callbacks: runManager?.getChild() }));\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableEach({\n            bound: this.bound.withListeners({ onStart, onEnd, onError }),\n        });\n    }\n}\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n */\nclass RunnableRetry extends RunnableBinding {\n    static lc_name() {\n        return \"RunnableRetry\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"maxAttemptNumber\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 3\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"onFailedAttempt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: () => { }\n        });\n        this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n        this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n    }\n    _patchConfigForRetry(attempt, config, runManager) {\n        const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n        return (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.patchConfig)(config, { callbacks: runManager?.getChild(tag) });\n    }\n    async _invoke(input, config, runManager) {\n        return p_retry__WEBPACK_IMPORTED_MODULE_0__((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onFailedAttempt: (error) => this.onFailedAttempt(error, input),\n            retries: Math.max(this.maxAttemptNumber - 1, 0),\n            randomize: true,\n        });\n    }\n    /**\n     * Method that invokes the runnable with the specified input, run manager,\n     * and config. It handles the retry logic by catching any errors and\n     * recursively invoking itself with the updated config for the next retry\n     * attempt.\n     * @param input The input for the runnable.\n     * @param runManager The run manager for the runnable.\n     * @param config The config for the runnable.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(input, config) {\n        return this._callWithConfig(this._invoke, input, config);\n    }\n    async _batch(inputs, configs, runManagers, batchOptions) {\n        const resultsMap = {};\n        try {\n            await p_retry__WEBPACK_IMPORTED_MODULE_0__(async (attemptNumber) => {\n                const remainingIndexes = inputs\n                    .map((_, i) => i)\n                    .filter((i) => resultsMap[i.toString()] === undefined ||\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    resultsMap[i.toString()] instanceof Error);\n                const remainingInputs = remainingIndexes.map((i) => inputs[i]);\n                const patchedConfigs = remainingIndexes.map((i) => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));\n                const results = await super.batch(remainingInputs, patchedConfigs, {\n                    ...batchOptions,\n                    returnExceptions: true,\n                });\n                let firstException;\n                for (let i = 0; i < results.length; i += 1) {\n                    const result = results[i];\n                    const resultMapIndex = remainingIndexes[i];\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (result instanceof Error) {\n                        if (firstException === undefined) {\n                            firstException = result;\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            firstException.input = remainingInputs[i];\n                        }\n                    }\n                    resultsMap[resultMapIndex.toString()] = result;\n                }\n                if (firstException) {\n                    throw firstException;\n                }\n                return results;\n            }, {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                onFailedAttempt: (error) => this.onFailedAttempt(error, error.input),\n                retries: Math.max(this.maxAttemptNumber - 1, 0),\n                randomize: true,\n            });\n        }\n        catch (e) {\n            if (batchOptions?.returnExceptions !== true) {\n                throw e;\n            }\n        }\n        return Object.keys(resultsMap)\n            .sort((a, b) => parseInt(a, 10) - parseInt(b, 10))\n            .map((key) => resultsMap[parseInt(key, 10)]);\n    }\n    async batch(inputs, options, batchOptions) {\n        return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n    }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({})]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nclass RunnableSequence extends Runnable {\n    static lc_name() {\n        return \"RunnableSequence\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"first\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"middle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"last\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        this.first = fields.first;\n        this.middle = fields.middle ?? this.middle;\n        this.last = fields.last;\n        this.name = fields.name;\n    }\n    get steps() {\n        return [this.first, ...this.middle, this.last];\n    }\n    async invoke(input, options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(options);\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        let nextStepInput = input;\n        let finalOutput;\n        try {\n            const initialSteps = [this.first, ...this.middle];\n            for (let i = 0; i < initialSteps.length; i += 1) {\n                const step = initialSteps[i];\n                nextStepInput = await step.invoke(nextStepInput, (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.patchConfig)(config, {\n                    callbacks: runManager?.getChild(`seq:step:${i + 1}`),\n                }));\n            }\n            // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n            finalOutput = await this.last.invoke(nextStepInput, (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.patchConfig)(config, {\n                callbacks: runManager?.getChild(`seq:step:${this.steps.length}`),\n            }));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n        return finalOutput;\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map(_config_js__WEBPACK_IMPORTED_MODULE_5__.getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let nextStepInputs = inputs;\n        try {\n            for (let i = 0; i < this.steps.length; i += 1) {\n                const step = this.steps[i];\n                nextStepInputs = await step.batch(nextStepInputs, runManagers.map((runManager, j) => {\n                    const childRunManager = runManager?.getChild(`seq:step:${i + 1}`);\n                    return (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.patchConfig)(configList[j], { callbacks: childRunManager });\n                }), batchOptions);\n            }\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))));\n        return nextStepInputs;\n    }\n    async *_streamIterator(input, options) {\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.getCallbackManagerForConfig)(options);\n        const { runId, ...otherOptions } = options ?? {};\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherOptions?.runName);\n        const steps = [this.first, ...this.middle, this.last];\n        let concatSupported = true;\n        let finalOutput;\n        async function* inputGenerator() {\n            yield input;\n        }\n        try {\n            let finalGenerator = steps[0].transform(inputGenerator(), (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.patchConfig)(otherOptions, {\n                callbacks: runManager?.getChild(`seq:step:1`),\n            }));\n            for (let i = 1; i < steps.length; i += 1) {\n                const step = steps[i];\n                finalGenerator = await step.transform(finalGenerator, (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.patchConfig)(otherOptions, {\n                    callbacks: runManager?.getChild(`seq:step:${i + 1}`),\n                }));\n            }\n            for await (const chunk of finalGenerator) {\n                yield chunk;\n                if (concatSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.concat)(finalOutput, chunk);\n                        }\n                        catch (e) {\n                            finalOutput = undefined;\n                            concatSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    }\n    getGraph(config) {\n        const graph = new _graph_js__WEBPACK_IMPORTED_MODULE_10__.Graph();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let currentLastNode = null;\n        this.steps.forEach((step, index) => {\n            const stepGraph = step.getGraph(config);\n            if (index !== 0) {\n                stepGraph.trimFirstNode();\n            }\n            if (index !== this.steps.length - 1) {\n                stepGraph.trimLastNode();\n            }\n            graph.extend(stepGraph);\n            const stepFirstNode = stepGraph.firstNode();\n            if (!stepFirstNode) {\n                throw new Error(`Runnable ${step} has no first node`);\n            }\n            if (currentLastNode) {\n                graph.addEdge(currentLastNode, stepFirstNode);\n            }\n            currentLastNode = stepGraph.lastNode();\n        });\n        return graph;\n    }\n    pipe(coerceable) {\n        if (RunnableSequence.isRunnableSequence(coerceable)) {\n            return new RunnableSequence({\n                first: this.first,\n                middle: this.middle.concat([\n                    this.last,\n                    coerceable.first,\n                    ...coerceable.middle,\n                ]),\n                last: coerceable.last,\n                name: this.name ?? coerceable.name,\n            });\n        }\n        else {\n            return new RunnableSequence({\n                first: this.first,\n                middle: [...this.middle, this.last],\n                last: _coerceToRunnable(coerceable),\n                name: this.name,\n            });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnableSequence(thing) {\n        return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from([first, ...runnables], name) {\n        return new RunnableSequence({\n            first: _coerceToRunnable(first),\n            middle: runnables.slice(0, -1).map(_coerceToRunnable),\n            last: _coerceToRunnable(runnables[runnables.length - 1]),\n            name,\n        });\n    }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nclass RunnableMap extends Runnable {\n    static lc_name() {\n        return \"RunnableMap\";\n    }\n    getStepsKeys() {\n        return Object.keys(this.steps);\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"steps\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.steps = {};\n        for (const [key, value] of Object.entries(fields.steps)) {\n            this.steps[key] = _coerceToRunnable(value);\n        }\n    }\n    static from(steps) {\n        return new RunnableMap({ steps });\n    }\n    async invoke(input, options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.ensureConfig)(options);\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n            input,\n        }, config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const output = {};\n        try {\n            await Promise.all(Object.entries(this.steps).map(async ([key, runnable]) => {\n                output[key] = await runnable.invoke(input, (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.patchConfig)(config, {\n                    callbacks: runManager?.getChild(`map:key:${key}`),\n                }));\n            }));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(output);\n        return output;\n    }\n    async *_transform(generator, runManager, options) {\n        // shallow copy steps to ignore changes while iterating\n        const steps = { ...this.steps };\n        // each step gets a copy of the input iterator\n        const inputCopies = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.atee)(generator, Object.keys(steps).length);\n        // start the first iteration of each output iterator\n        const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {\n            const gen = runnable.transform(inputCopies[i], (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.patchConfig)(options, {\n                callbacks: runManager?.getChild(`map:key:${key}`),\n            }));\n            return [key, gen.next().then((result) => ({ key, gen, result }))];\n        }));\n        // yield chunks as they become available,\n        // starting new iterations as needed,\n        // until all iterators are done\n        while (tasks.size) {\n            const { key, result, gen } = await Promise.race(tasks.values());\n            tasks.delete(key);\n            if (!result.done) {\n                yield { [key]: result.value };\n                tasks.set(key, gen.next().then((result) => ({ key, gen, result })));\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.AsyncGeneratorWithSetup(this.transform(generator(), options));\n        await wrappedGenerator.setup;\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that runs a callable.\n */\nclass RunnableLambda extends Runnable {\n    static lc_name() {\n        return \"RunnableLambda\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.func = fields.func;\n    }\n    static from(func) {\n        return new RunnableLambda({\n            func,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        return new Promise((resolve, reject) => {\n            const childConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.patchConfig)(config, {\n                callbacks: runManager?.getChild(),\n                recursionLimit: (config?.recursionLimit ?? _config_js__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_RECURSION_LIMIT) - 1,\n            });\n            void _singletons_index_js__WEBPACK_IMPORTED_MODULE_9__.AsyncLocalStorageProviderSingleton.getInstance().run(childConfig, async () => {\n                try {\n                    let output = await this.func(input, {\n                        ...childConfig,\n                        config: childConfig,\n                    });\n                    if (output && Runnable.isRunnable(output)) {\n                        if (config?.recursionLimit === 0) {\n                            throw new Error(\"Recursion limit reached.\");\n                        }\n                        output = await output.invoke(input, {\n                            ...childConfig,\n                            recursionLimit: (childConfig.recursionLimit ?? _config_js__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_RECURSION_LIMIT) - 1,\n                        });\n                    }\n                    else if ((0,_iter_js__WEBPACK_IMPORTED_MODULE_12__.isAsyncIterable)(output)) {\n                        let finalOutput;\n                        for await (const chunk of (0,_iter_js__WEBPACK_IMPORTED_MODULE_12__.consumeAsyncIterableInContext)(childConfig, output)) {\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    finalOutput = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.concat)(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    else if ((0,_iter_js__WEBPACK_IMPORTED_MODULE_12__.isIterator)(output)) {\n                        let finalOutput;\n                        for (const chunk of (0,_iter_js__WEBPACK_IMPORTED_MODULE_12__.consumeIteratorInContext)(childConfig, output)) {\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    finalOutput = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.concat)(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    resolve(output);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._invoke, input, options);\n    }\n    async *_transform(generator, runManager, config) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    finalChunk = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.concat)(finalChunk, chunk);\n                }\n                catch (e) {\n                    finalChunk = chunk;\n                }\n            }\n        }\n        const output = await new Promise((resolve, reject) => {\n            void _singletons_index_js__WEBPACK_IMPORTED_MODULE_9__.AsyncLocalStorageProviderSingleton.getInstance().run(config, async () => {\n                try {\n                    const res = await this.func(finalChunk, {\n                        ...config,\n                        config,\n                    });\n                    resolve(res);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n        if (output && Runnable.isRunnable(output)) {\n            if (config?.recursionLimit === 0) {\n                throw new Error(\"Recursion limit reached.\");\n            }\n            const stream = await output.stream(finalChunk, (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.patchConfig)(config, {\n                callbacks: runManager?.getChild(),\n                recursionLimit: (config?.recursionLimit ?? _config_js__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_RECURSION_LIMIT) - 1,\n            }));\n            for await (const chunk of stream) {\n                yield chunk;\n            }\n        }\n        else if ((0,_iter_js__WEBPACK_IMPORTED_MODULE_12__.isAsyncIterable)(output)) {\n            for await (const chunk of (0,_iter_js__WEBPACK_IMPORTED_MODULE_12__.consumeAsyncIterableInContext)(config, output)) {\n                yield chunk;\n            }\n        }\n        else if ((0,_iter_js__WEBPACK_IMPORTED_MODULE_12__.isIterator)(output)) {\n            for (const chunk of (0,_iter_js__WEBPACK_IMPORTED_MODULE_12__.consumeIteratorInContext)(config, output)) {\n                yield chunk;\n            }\n        }\n        else {\n            yield output;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.AsyncGeneratorWithSetup(this.transform(generator(), options));\n        await wrappedGenerator.setup;\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nclass RunnableParallel extends RunnableMap {\n}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n */\nclass RunnableWithFallbacks extends Runnable {\n    static lc_name() {\n        return \"RunnableWithFallbacks\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fallbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.fallbacks = fields.fallbacks;\n    }\n    *runnables() {\n        yield this.runnable;\n        for (const fallback of this.fallbacks) {\n            yield fallback;\n        }\n    }\n    async invoke(input, options) {\n        const callbackManager_ = await _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_1__.CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const { runId, ...otherOptions } = options ?? {};\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherOptions?.runName);\n        let firstError;\n        for (const runnable of this.runnables()) {\n            try {\n                const output = await runnable.invoke(input, (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.patchConfig)(otherOptions, { callbacks: runManager?.getChild() }));\n                await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n                return output;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (firstError === undefined) {\n            throw new Error(\"No error stored at end of fallback.\");\n        }\n        await runManager?.handleChainError(firstError);\n        throw firstError;\n    }\n    async batch(inputs, options, batchOptions) {\n        if (batchOptions?.returnExceptions) {\n            throw new Error(\"Not implemented.\");\n        }\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map((config) => _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_1__.CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata)));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let firstError;\n        for (const runnable of this.runnables()) {\n            try {\n                const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.patchConfig)(configList[j], {\n                    callbacks: runManager?.getChild(),\n                })), batchOptions);\n                await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n                return outputs;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (!firstError) {\n            throw new Error(\"No error stored at end of fallbacks.\");\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(firstError)));\n        throw firstError;\n    }\n}\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nfunction _coerceToRunnable(coerceable) {\n    if (typeof coerceable === \"function\") {\n        return new RunnableLambda({ func: coerceable });\n    }\n    else if (Runnable.isRunnable(coerceable)) {\n        return coerceable;\n    }\n    else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n        const runnables = {};\n        for (const [key, value] of Object.entries(coerceable)) {\n            runnables[key] = _coerceToRunnable(value);\n        }\n        return new RunnableMap({\n            steps: runnables,\n        });\n    }\n    else {\n        throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n */\nclass RunnableAssign extends Runnable {\n    static lc_name() {\n        return \"RunnableAssign\";\n    }\n    constructor(fields) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (fields instanceof RunnableMap) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { mapper: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"mapper\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.mapper = fields.mapper;\n    }\n    async invoke(input, options) {\n        const mapperResult = await this.mapper.invoke(input, options);\n        return {\n            ...input,\n            ...mapperResult,\n        };\n    }\n    async *_transform(generator, runManager, options) {\n        // collect mapper keys\n        const mapperKeys = this.mapper.getStepsKeys();\n        // create two input gens, one for the mapper, one for the input\n        const [forPassthrough, forMapper] = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.atee)(generator);\n        // create mapper output gen\n        const mapperOutput = this.mapper.transform(forMapper, (0,_config_js__WEBPACK_IMPORTED_MODULE_5__.patchConfig)(options, { callbacks: runManager?.getChild() }));\n        // start the mapper\n        const firstMapperChunkPromise = mapperOutput.next();\n        // yield the passthrough\n        for await (const chunk of forPassthrough) {\n            if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n                throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);\n            }\n            const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));\n            if (Object.keys(filtered).length > 0) {\n                yield filtered;\n            }\n        }\n        // yield the mapper output\n        yield (await firstMapperChunkPromise).value;\n        for await (const chunk of mapperOutput) {\n            yield chunk;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.AsyncGeneratorWithSetup(this.transform(generator(), options));\n        await wrappedGenerator.setup;\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n */\nclass RunnablePick extends Runnable {\n    static lc_name() {\n        return \"RunnablePick\";\n    }\n    constructor(fields) {\n        if (typeof fields === \"string\" || Array.isArray(fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { keys: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"keys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.keys = fields.keys;\n    }\n    async _pick(input) {\n        if (typeof this.keys === \"string\") {\n            return input[this.keys];\n        }\n        else {\n            const picked = this.keys\n                .map((key) => [key, input[key]])\n                .filter((v) => v[1] !== undefined);\n            return picked.length === 0 ? undefined : Object.fromEntries(picked);\n        }\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._pick.bind(this), input, options);\n    }\n    async *_transform(generator) {\n        for await (const chunk of generator) {\n            const picked = await this._pick(chunk);\n            if (picked !== undefined) {\n                yield picked;\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.AsyncGeneratorWithSetup(this.transform(generator(), options));\n        await wrappedGenerator.setup;\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvYmFzZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0I7QUFDSztBQUM4QjtBQUMrQjtBQUNuQztBQUNxRTtBQUNDO0FBQ3RFO0FBQ1c7QUFDQztBQUNTO0FBQ3pDO0FBQ3NCO0FBQ3lEO0FBQ2xIO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVCQUF1QiwrREFBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSyxFQUFFLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQ0FBaUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHLGdCQUFnQixjQUFjLFFBQVE7QUFDbko7QUFDQTtBQUNBLCtCQUErQixvREFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRLFlBQVksd0RBQVk7QUFDaEU7QUFDQSw0QkFBNEIsUUFBUSxRQUFRLHdEQUFZO0FBQ3hEO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSwyQkFBMkIsK0RBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUVBQXVCLDZCQUE2Qix3REFBWTtBQUNyRztBQUNBLGVBQWUsb0VBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdEQUFZO0FBQ3pDO0FBQ0E7QUFDQSw2QkFBNkIsd0RBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFZO0FBQ25DLHVDQUF1Qyx1RUFBMkI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCxtRUFBbUUsbUVBQTJCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBWTtBQUNuQyx1Q0FBdUMsdUVBQTJCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx3REFBTTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0VBQXNCLGdIQUFnSCxXQUFXO0FBQ2hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0RBQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwREFBMEQscUNBQXFDLDRDQUE0QztBQUMzSTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUFLO0FBQy9CO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQyxvQkFBb0IsbUNBQUM7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDLG9CQUFvQixtQ0FBQztBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0RBQU07QUFDbkM7QUFDQTtBQUNBLGdEQUFnRCx3REFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw0RUFBd0I7QUFDckU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHVCQUF1Qix3REFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywrREFBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUVBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDRFQUF3QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLHVEQUFnQjtBQUNwRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMERBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsWUFBWSw0QkFBNEIsY0FBYztBQUNwSjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWMsR0FBRyxVQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixZQUFZLDRCQUE0QixXQUFXO0FBQzdJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOERBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBFQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFZO0FBQ25DLGVBQWUsd0RBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnRUFBZ0Usd0RBQVk7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLHdEQUFZO0FBQ3RHLHNDQUFzQyx3REFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsd0RBQVk7QUFDckY7QUFDQTtBQUNBLGdFQUFnRSx3REFBWTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSx3REFBWTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msd0RBQVk7QUFDcEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQztBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEVBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdURBQVcsV0FBVyxtQ0FBbUM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0EsOENBQThDLHlCQUF5QjtBQUN2RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNELGVBQWUsdURBQVcsV0FBVyxzQ0FBc0M7QUFDM0U7QUFDQTtBQUNBLGVBQWUsb0NBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQ0FBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBLHlFQUF5RTtBQUN6RSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVk7QUFDbkMsdUNBQXVDLHVFQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0EsaUVBQWlFLHVEQUFXO0FBQzVFLGdFQUFnRSxNQUFNO0FBQ3RFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0VBQWdFLHVEQUFXO0FBQzNFLDREQUE0RCxrQkFBa0I7QUFDOUUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxrRUFBa0UsbUVBQTJCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBLDZFQUE2RSxNQUFNO0FBQ25GLDJCQUEyQix1REFBVyxrQkFBa0IsNEJBQTRCO0FBQ3BGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1RUFBMkI7QUFDbEUsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHVEQUFXO0FBQ2pGO0FBQ0EsYUFBYTtBQUNiLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQSxzRUFBc0UsdURBQVc7QUFDakYsZ0VBQWdFLE1BQU07QUFDdEUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdEQUFNO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELE1BQU07QUFDcEUsMkJBQTJCO0FBQzNCO0FBQ0EsbUVBQW1FLE1BQU07QUFDekUsMkJBQTJCO0FBQzNCO0FBQ0EsSUFBSTtBQUNKLDBDQUEwQyxlQUFlO0FBQ3pEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0EsdUJBQXVCLHdEQUFZO0FBQ25DLHVDQUF1Qyx1RUFBMkI7QUFDbEU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHVEQUFXO0FBQ3RFLCtEQUErRCxJQUFJO0FBQ25FLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSw0QkFBNEIsc0RBQUk7QUFDaEM7QUFDQTtBQUNBLDJEQUEyRCx1REFBVztBQUN0RSwyREFBMkQsSUFBSTtBQUMvRCxhQUFhO0FBQ2Isd0RBQXdELGtCQUFrQjtBQUMxRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsOERBQThELGtCQUFrQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxRUFBdUI7QUFDNUQ7QUFDQSxlQUFlLG9FQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVEQUFXO0FBQzNDO0FBQ0EsMkRBQTJELCtEQUF1QjtBQUNsRixhQUFhO0FBQ2IsaUJBQWlCLG9GQUFrQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsK0RBQXVCO0FBQ2xHLHlCQUF5QjtBQUN6QjtBQUNBLDZCQUE2QiwwREFBZTtBQUM1QztBQUNBLGtEQUFrRCx3RUFBNkI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsd0RBQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxREFBVTtBQUN2QztBQUNBLDRDQUE0QyxtRUFBd0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsd0RBQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsd0RBQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0ZBQWtDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHVEQUFXO0FBQ3RFO0FBQ0EsMkRBQTJELCtEQUF1QjtBQUNsRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMERBQWU7QUFDaEMsc0NBQXNDLHdFQUE2QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscURBQVU7QUFDM0IsZ0NBQWdDLG1FQUF3QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFFQUF1QjtBQUM1RDtBQUNBLGVBQWUsb0VBQXNCO0FBQ3JDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrRUFBZTtBQUN0RCxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHVEQUFXLGlCQUFpQixtQ0FBbUM7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsOEVBQThFLGtFQUFlO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLHVEQUFXO0FBQzNHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxzREFBSTtBQUNoRDtBQUNBLDhEQUE4RCx1REFBVyxZQUFZLG1DQUFtQztBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGFBQWE7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUVBQXVCO0FBQzVEO0FBQ0EsZUFBZSxvRUFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxRUFBdUI7QUFDNUQ7QUFDQSxlQUFlLG9FQUFzQjtBQUNyQztBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxccnVubmFibGVzXFxiYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHogfSBmcm9tIFwiem9kXCI7XG5pbXBvcnQgcFJldHJ5IGZyb20gXCJwLXJldHJ5XCI7XG5pbXBvcnQgeyBDYWxsYmFja01hbmFnZXIsIH0gZnJvbSBcIi4uL2NhbGxiYWNrcy9tYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBMb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIsIFJ1bkxvZywgUnVuTG9nUGF0Y2gsIH0gZnJvbSBcIi4uL3RyYWNlcnMvbG9nX3N0cmVhbS5qc1wiO1xuaW1wb3J0IHsgU2VyaWFsaXphYmxlIH0gZnJvbSBcIi4uL2xvYWQvc2VyaWFsaXphYmxlLmpzXCI7XG5pbXBvcnQgeyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLCBjb25jYXQsIGF0ZWUsIHBpcGVHZW5lcmF0b3JXaXRoU2V0dXAsIEFzeW5jR2VuZXJhdG9yV2l0aFNldHVwLCB9IGZyb20gXCIuLi91dGlscy9zdHJlYW0uanNcIjtcbmltcG9ydCB7IERFRkFVTFRfUkVDVVJTSU9OX0xJTUlULCBlbnN1cmVDb25maWcsIGdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZywgbWVyZ2VDb25maWdzLCBwYXRjaENvbmZpZywgfSBmcm9tIFwiLi9jb25maWcuanNcIjtcbmltcG9ydCB7IEFzeW5jQ2FsbGVyIH0gZnJvbSBcIi4uL3V0aWxzL2FzeW5jX2NhbGxlci5qc1wiO1xuaW1wb3J0IHsgUm9vdExpc3RlbmVyc1RyYWNlciB9IGZyb20gXCIuLi90cmFjZXJzL3Jvb3RfbGlzdGVuZXIuanNcIjtcbmltcG9ydCB7IF9Sb290RXZlbnRGaWx0ZXIsIGlzUnVubmFibGVJbnRlcmZhY2UgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiB9IGZyb20gXCIuLi9zaW5nbGV0b25zL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gXCIuL2dyYXBoLmpzXCI7XG5pbXBvcnQgeyBjb252ZXJ0VG9IdHRwRXZlbnRTdHJlYW0gfSBmcm9tIFwiLi93cmFwcGVycy5qc1wiO1xuaW1wb3J0IHsgY29uc3VtZUFzeW5jSXRlcmFibGVJbkNvbnRleHQsIGNvbnN1bWVJdGVyYXRvckluQ29udGV4dCwgaXNBc3luY0l0ZXJhYmxlLCBpc0l0ZXJhdG9yLCB9IGZyb20gXCIuL2l0ZXIuanNcIjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gX2NvZXJjZVRvRGljdCh2YWx1ZSwgZGVmYXVsdEtleSkge1xuICAgIHJldHVybiB2YWx1ZSAmJlxuICAgICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiB7IFtkZWZhdWx0S2V5XTogdmFsdWUgfTtcbn1cbi8qKlxuICogQSBSdW5uYWJsZSBpcyBhIGdlbmVyaWMgdW5pdCBvZiB3b3JrIHRoYXQgY2FuIGJlIGludm9rZWQsIGJhdGNoZWQsIHN0cmVhbWVkLCBhbmQvb3JcbiAqIHRyYW5zZm9ybWVkLlxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGUgZXh0ZW5kcyBTZXJpYWxpemFibGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19ydW5uYWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXROYW1lKHN1ZmZpeCkge1xuICAgICAgICBjb25zdCBuYW1lID0gXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHRoaXMubmFtZSA/PyB0aGlzLmNvbnN0cnVjdG9yLmxjX25hbWUoKSA/PyB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHJldHVybiBzdWZmaXggPyBgJHtuYW1lfSR7c3VmZml4fWAgOiBuYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIGFyZ3VtZW50cyB0byBhIFJ1bm5hYmxlLCByZXR1cm5pbmcgYSBuZXcgUnVubmFibGUuXG4gICAgICogQHBhcmFtIGt3YXJnc1xuICAgICAqIEByZXR1cm5zIEEgbmV3IFJ1bm5hYmxlQmluZGluZyB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgYXBwbHkgdGhlIGJvdW5kIGFyZ3MuXG4gICAgICovXG4gICAgYmluZChrd2FyZ3MpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlQmluZGluZyh7IGJvdW5kOiB0aGlzLCBrd2FyZ3MsIGNvbmZpZzoge30gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBSdW5uYWJsZSB0aGF0IG1hcHMgYSBsaXN0IG9mIGlucHV0cyB0byBhIGxpc3Qgb2Ygb3V0cHV0cyxcbiAgICAgKiBieSBjYWxsaW5nIGludm9rZSgpIHdpdGggZWFjaCBpbnB1dC5cbiAgICAgKi9cbiAgICBtYXAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUVhY2goeyBib3VuZDogdGhpcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHJldHJ5IGxvZ2ljIHRvIGFuIGV4aXN0aW5nIHJ1bm5hYmxlLlxuICAgICAqIEBwYXJhbSBrd2FyZ3NcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBSdW5uYWJsZVJldHJ5IHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCByZXRyeSBhY2NvcmRpbmcgdG8gdGhlIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgd2l0aFJldHJ5KGZpZWxkcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVSZXRyeSh7XG4gICAgICAgICAgICBib3VuZDogdGhpcyxcbiAgICAgICAgICAgIGt3YXJnczoge30sXG4gICAgICAgICAgICBjb25maWc6IHt9LFxuICAgICAgICAgICAgbWF4QXR0ZW1wdE51bWJlcjogZmllbGRzPy5zdG9wQWZ0ZXJBdHRlbXB0LFxuICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCBjb25maWcgdG8gYSBSdW5uYWJsZSwgcmV0dXJuaW5nIGEgbmV3IFJ1bm5hYmxlLlxuICAgICAqIEBwYXJhbSBjb25maWcgTmV3IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyB0byBhdHRhY2ggdG8gdGhlIG5ldyBydW5uYWJsZS5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBSdW5uYWJsZUJpbmRpbmcgd2l0aCBhIGNvbmZpZyBtYXRjaGluZyB3aGF0J3MgcGFzc2VkLlxuICAgICAqL1xuICAgIHdpdGhDb25maWcoY29uZmlnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUJpbmRpbmcoe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMsXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBrd2FyZ3M6IHt9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHJ1bm5hYmxlIGZyb20gdGhlIGN1cnJlbnQgb25lIHRoYXQgd2lsbCB0cnkgaW52b2tpbmdcbiAgICAgKiBvdGhlciBwYXNzZWQgZmFsbGJhY2sgcnVubmFibGVzIGlmIHRoZSBpbml0aWFsIGludm9jYXRpb24gZmFpbHMuXG4gICAgICogQHBhcmFtIGZpZWxkcy5mYWxsYmFja3MgT3RoZXIgcnVubmFibGVzIHRvIGNhbGwgaWYgdGhlIHJ1bm5hYmxlIGVycm9ycy5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBSdW5uYWJsZVdpdGhGYWxsYmFja3MuXG4gICAgICovXG4gICAgd2l0aEZhbGxiYWNrcyhmaWVsZHMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlV2l0aEZhbGxiYWNrcyh7XG4gICAgICAgICAgICBydW5uYWJsZTogdGhpcyxcbiAgICAgICAgICAgIGZhbGxiYWNrczogZmllbGRzLmZhbGxiYWNrcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRPcHRpb25zTGlzdChvcHRpb25zLCBsZW5ndGggPSAwKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpICYmIG9wdGlvbnMubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFzc2VkIFwib3B0aW9uc1wiIG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIGlucHV0cywgYnV0IGdvdCAke29wdGlvbnMubGVuZ3RofSBvcHRpb25zIGZvciAke2xlbmd0aH0gaW5wdXRzYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLm1hcChlbnN1cmVDb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPiAxICYmICFBcnJheS5pc0FycmF5KG9wdGlvbnMpICYmIG9wdGlvbnMucnVuSWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlByb3ZpZGVkIHJ1bklkIHdpbGwgYmUgdXNlZCBvbmx5IGZvciB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgYmF0Y2guXCIpO1xuICAgICAgICAgICAgY29uc3Qgc3Vic2VxdWVudCA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhvcHRpb25zKS5maWx0ZXIoKFtrZXldKSA9PiBrZXkgIT09IFwicnVuSWRcIikpO1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGggfSwgKF8sIGkpID0+IGVuc3VyZUNvbmZpZyhpID09PSAwID8gb3B0aW9ucyA6IHN1YnNlcXVlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aCB9LCAoKSA9PiBlbnN1cmVDb25maWcob3B0aW9ucykpO1xuICAgIH1cbiAgICBhc3luYyBiYXRjaChpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWdMaXN0ID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IG1heENvbmN1cnJlbmN5ID0gY29uZmlnTGlzdFswXT8ubWF4Q29uY3VycmVuY3kgPz8gYmF0Y2hPcHRpb25zPy5tYXhDb25jdXJyZW5jeTtcbiAgICAgICAgY29uc3QgY2FsbGVyID0gbmV3IEFzeW5jQ2FsbGVyKHtcbiAgICAgICAgICAgIG1heENvbmN1cnJlbmN5LFxuICAgICAgICAgICAgb25GYWlsZWRBdHRlbXB0OiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYmF0Y2hDYWxscyA9IGlucHV0cy5tYXAoKGlucHV0LCBpKSA9PiBjYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuaW52b2tlKGlucHV0LCBjb25maWdMaXN0W2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmF0Y2hPcHRpb25zPy5yZXR1cm5FeGNlcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChiYXRjaENhbGxzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBzdHJlYW1pbmcgaW1wbGVtZW50YXRpb24uXG4gICAgICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBzdXBwb3J0IHN0cmVhbWluZyBvdXRwdXQuXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuaW52b2tlKGlucHV0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RyZWFtIG91dHB1dCBpbiBjaHVua3MuXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyBBIHJlYWRhYmxlIHN0cmVhbSB0aGF0IGlzIGFsc28gYW4gaXRlcmFibGUuXG4gICAgICovXG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIEJ1ZmZlciB0aGUgZmlyc3Qgc3RyZWFtZWQgY2h1bmsgdG8gYWxsb3cgZm9yIGluaXRpYWwgZXJyb3JzXG4gICAgICAgIC8vIHRvIHN1cmZhY2UgaW1tZWRpYXRlbHkuXG4gICAgICAgIGNvbnN0IHdyYXBwZWRHZW5lcmF0b3IgPSBuZXcgQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAodGhpcy5fc3RyZWFtSXRlcmF0b3IoaW5wdXQsIGVuc3VyZUNvbmZpZyhvcHRpb25zKSkpO1xuICAgICAgICBhd2FpdCB3cmFwcGVkR2VuZXJhdG9yLnNldHVwO1xuICAgICAgICByZXR1cm4gSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Iod3JhcHBlZEdlbmVyYXRvcik7XG4gICAgfVxuICAgIF9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHJ1bm5hYmxlQ29uZmlnO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW5uYWJsZUNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJ1bm5hYmxlQ29uZmlnID0gZW5zdXJlQ29uZmlnKHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IG9wdGlvbnMuY2FsbGJhY2tzLFxuICAgICAgICAgICAgICAgIHRhZ3M6IG9wdGlvbnMudGFncyxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogb3B0aW9ucy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBydW5OYW1lOiBvcHRpb25zLnJ1bk5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBvcHRpb25zLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgICAgICByZWN1cnNpb25MaW1pdDogb3B0aW9ucy5yZWN1cnNpb25MaW1pdCxcbiAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW5jeTogb3B0aW9ucy5tYXhDb25jdXJyZW5jeSxcbiAgICAgICAgICAgICAgICBydW5JZDogb3B0aW9ucy5ydW5JZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGxPcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5jYWxsYmFja3M7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy50YWdzO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMubWV0YWRhdGE7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5ydW5OYW1lO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMuY29uZmlndXJhYmxlO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMucmVjdXJzaW9uTGltaXQ7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5tYXhDb25jdXJyZW5jeTtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLnJ1bklkO1xuICAgICAgICByZXR1cm4gW3J1bm5hYmxlQ29uZmlnLCBjYWxsT3B0aW9uc107XG4gICAgfVxuICAgIGFzeW5jIF9jYWxsV2l0aENvbmZpZyhmdW5jLCBpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcoY29uZmlnKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dCwgXCJpbnB1dFwiKSwgY29uZmlnLnJ1bklkLCBjb25maWc/LnJ1blR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWc/LnJ1bk5hbWUgPz8gdGhpcy5nZXROYW1lKCkpO1xuICAgICAgICBkZWxldGUgY29uZmlnLnJ1bklkO1xuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb3V0cHV0ID0gYXdhaXQgZnVuYy5jYWxsKHRoaXMsIGlucHV0LCBjb25maWcsIHJ1bk1hbmFnZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KG91dHB1dCwgXCJvdXRwdXRcIikpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdGhhdCBoYW5kbGVzIGJhdGNoaW5nIGFuZCBjb25maWd1cmF0aW9uIGZvciBhIHJ1bm5hYmxlXG4gICAgICogSXQgdGFrZXMgYSBmdW5jdGlvbiwgaW5wdXQgdmFsdWVzLCBhbmQgb3B0aW9uYWwgY29uZmlndXJhdGlvbiwgYW5kXG4gICAgICogcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgZm9yIGVhY2ggaW5wdXQgdmFsdWUuXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB2YWx1ZXMgdG8gYmUgcHJvY2Vzc2VkLlxuICAgICAqIEBwYXJhbSBjb25maWcgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBmb3IgdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IHZhbHVlcy5cbiAgICAgKi9cbiAgICBhc3luYyBfYmF0Y2hXaXRoQ29uZmlnKGZ1bmMsIGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNMaXN0ID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChvcHRpb25zTGlzdC5tYXAoZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY2FsbGJhY2tNYW5hZ2Vycy5tYXAoYXN5bmMgKGNhbGxiYWNrTWFuYWdlciwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlU3RhcnRSZXMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXI/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dHNbaV0sIFwiaW5wdXRcIiksIG9wdGlvbnNMaXN0W2ldLnJ1bklkLCBvcHRpb25zTGlzdFtpXS5ydW5UeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3B0aW9uc0xpc3RbaV0ucnVuTmFtZSA/PyB0aGlzLmdldE5hbWUoKSk7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9uc0xpc3RbaV0ucnVuSWQ7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RhcnRSZXM7XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IG91dHB1dHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvdXRwdXRzID0gYXdhaXQgZnVuYy5jYWxsKHRoaXMsIGlucHV0cywgb3B0aW9uc0xpc3QsIHJ1bk1hbmFnZXJzLCBiYXRjaE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSkpKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KG91dHB1dHMsIFwib3V0cHV0XCIpKSkpO1xuICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byB0cmFuc2Zvcm0gYW4gSXRlcmF0b3Igb2YgSW5wdXQgdmFsdWVzIGludG8gYW4gSXRlcmF0b3Igb2ZcbiAgICAgKiBPdXRwdXQgdmFsdWVzLCB3aXRoIGNhbGxiYWNrcy5cbiAgICAgKiBVc2UgdGhpcyB0byBpbXBsZW1lbnQgYHN0cmVhbSgpYCBvciBgdHJhbnNmb3JtKClgIGluIFJ1bm5hYmxlIHN1YmNsYXNzZXMuXG4gICAgICovXG4gICAgYXN5bmMgKl90cmFuc2Zvcm1TdHJlYW1XaXRoQ29uZmlnKGlucHV0R2VuZXJhdG9yLCB0cmFuc2Zvcm1lciwgb3B0aW9ucykge1xuICAgICAgICBsZXQgZmluYWxJbnB1dDtcbiAgICAgICAgbGV0IGZpbmFsSW5wdXRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgIGxldCBmaW5hbE91dHB1dFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IGdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZyhjb25maWcpO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiogd3JhcElucHV0Rm9yVHJhY2luZygpIHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaW5wdXRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxJbnB1dFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxJbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbElucHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxJbnB1dCA9IGNvbmNhdChmaW5hbElucHV0LCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxJbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbElucHV0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJ1bk1hbmFnZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwaXBlID0gYXdhaXQgcGlwZUdlbmVyYXRvcldpdGhTZXR1cCh0cmFuc2Zvcm1lci5iaW5kKHRoaXMpLCB3cmFwSW5wdXRGb3JUcmFjaW5nKCksIGFzeW5jICgpID0+IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgeyBpbnB1dDogXCJcIiB9LCBjb25maWcucnVuSWQsIGNvbmZpZy5ydW5UeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnLnJ1bk5hbWUgPz8gdGhpcy5nZXROYW1lKCkpLCBjb25maWcpO1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5ydW5JZDtcbiAgICAgICAgICAgIHJ1bk1hbmFnZXIgPSBwaXBlLnNldHVwO1xuICAgICAgICAgICAgY29uc3QgaXNMb2dTdHJlYW1IYW5kbGVyID0gKGhhbmRsZXIpID0+IGhhbmRsZXIubmFtZSA9PT0gXCJsb2dfc3RyZWFtX3RyYWNlclwiO1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtTG9nSGFuZGxlciA9IHJ1bk1hbmFnZXI/LmhhbmRsZXJzLmZpbmQoaXNMb2dTdHJlYW1IYW5kbGVyKTtcbiAgICAgICAgICAgIGxldCBpdGVyYXRvciA9IHBpcGUub3V0cHV0O1xuICAgICAgICAgICAgaWYgKHN0cmVhbUxvZ0hhbmRsZXIgIT09IHVuZGVmaW5lZCAmJiBydW5NYW5hZ2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvciA9IGF3YWl0IHN0cmVhbUxvZ0hhbmRsZXIudGFwT3V0cHV0SXRlcmFibGUocnVuTWFuYWdlci5ydW5JZCwgcGlwZS5vdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpdGVyYXRvcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNvbmNhdChmaW5hbE91dHB1dCwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIGlucHV0czogX2NvZXJjZVRvRGljdChmaW5hbElucHV0LCBcImlucHV0XCIpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKGZpbmFsT3V0cHV0ID8/IHt9LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IGlucHV0czogX2NvZXJjZVRvRGljdChmaW5hbElucHV0LCBcImlucHV0XCIpIH0pO1xuICAgIH1cbiAgICBnZXRHcmFwaChfKSB7XG4gICAgICAgIGNvbnN0IGdyYXBoID0gbmV3IEdyYXBoKCk7XG4gICAgICAgIC8vIFRPRE86IEFkZCBpbnB1dCBzY2hlbWEgZm9yIHJ1bm5hYmxlc1xuICAgICAgICBjb25zdCBpbnB1dE5vZGUgPSBncmFwaC5hZGROb2RlKHtcbiAgICAgICAgICAgIG5hbWU6IGAke3RoaXMuZ2V0TmFtZSgpfUlucHV0YCxcbiAgICAgICAgICAgIHNjaGVtYTogei5hbnkoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlTm9kZSA9IGdyYXBoLmFkZE5vZGUodGhpcyk7XG4gICAgICAgIC8vIFRPRE86IEFkZCBvdXRwdXQgc2NoZW1hcyBmb3IgcnVubmFibGVzXG4gICAgICAgIGNvbnN0IG91dHB1dE5vZGUgPSBncmFwaC5hZGROb2RlKHtcbiAgICAgICAgICAgIG5hbWU6IGAke3RoaXMuZ2V0TmFtZSgpfU91dHB1dGAsXG4gICAgICAgICAgICBzY2hlbWE6IHouYW55KCksXG4gICAgICAgIH0pO1xuICAgICAgICBncmFwaC5hZGRFZGdlKGlucHV0Tm9kZSwgcnVubmFibGVOb2RlKTtcbiAgICAgICAgZ3JhcGguYWRkRWRnZShydW5uYWJsZU5vZGUsIG91dHB1dE5vZGUpO1xuICAgICAgICByZXR1cm4gZ3JhcGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBydW5uYWJsZSBzZXF1ZW5jZSB0aGF0IHJ1bnMgZWFjaCBpbmRpdmlkdWFsIHJ1bm5hYmxlIGluIHNlcmllcyxcbiAgICAgKiBwaXBpbmcgdGhlIG91dHB1dCBvZiBvbmUgcnVubmFibGUgaW50byBhbm90aGVyIHJ1bm5hYmxlIG9yIHJ1bm5hYmxlLWxpa2UuXG4gICAgICogQHBhcmFtIGNvZXJjZWFibGUgQSBydW5uYWJsZSwgZnVuY3Rpb24sIG9yIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGZ1bmN0aW9ucyBvciBydW5uYWJsZXMuXG4gICAgICogQHJldHVybnMgQSBuZXcgcnVubmFibGUgc2VxdWVuY2UuXG4gICAgICovXG4gICAgcGlwZShjb2VyY2VhYmxlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVNlcXVlbmNlKHtcbiAgICAgICAgICAgIGZpcnN0OiB0aGlzLFxuICAgICAgICAgICAgbGFzdDogX2NvZXJjZVRvUnVubmFibGUoY29lcmNlYWJsZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQaWNrIGtleXMgZnJvbSB0aGUgZGljdCBvdXRwdXQgb2YgdGhpcyBydW5uYWJsZS4gUmV0dXJucyBhIG5ldyBydW5uYWJsZS5cbiAgICAgKi9cbiAgICBwaWNrKGtleXMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gdGhpcy5waXBlKG5ldyBSdW5uYWJsZVBpY2soa2V5cykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG5ldyBmaWVsZHMgdG8gdGhlIGRpY3Qgb3V0cHV0IG9mIHRoaXMgcnVubmFibGUuIFJldHVybnMgYSBuZXcgcnVubmFibGUuXG4gICAgICovXG4gICAgYXNzaWduKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlwZShcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBuZXcgUnVubmFibGVBc3NpZ24oXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgbmV3IFJ1bm5hYmxlTWFwKHsgc3RlcHM6IG1hcHBpbmcgfSkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0cmFuc2Zvcm0sIHdoaWNoIGJ1ZmZlcnMgaW5wdXQgYW5kIHRoZW4gY2FsbHMgc3RyZWFtLlxuICAgICAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHRoZXkgY2FuIHN0YXJ0IHByb2R1Y2luZyBvdXRwdXQgd2hpbGVcbiAgICAgKiBpbnB1dCBpcyBzdGlsbCBiZWluZyBnZW5lcmF0ZWQuXG4gICAgICogQHBhcmFtIGdlbmVyYXRvclxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgYXN5bmMgKnRyYW5zZm9ybShnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGZpbmFsQ2h1bms7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBpZiAoZmluYWxDaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmluYWxDaHVuayA9IGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBhIGJlc3QgZWZmb3J0IHRvIGdhdGhlciwgZm9yIGFueSB0eXBlIHRoYXQgc3VwcG9ydHMgY29uY2F0LlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWV0aG9kIHNob3VsZCB0aHJvdyBhbiBlcnJvciBpZiBnYXRoZXJpbmcgZmFpbHMuXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBmaW5hbENodW5rID0gY29uY2F0KGZpbmFsQ2h1bmssIGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5fc3RyZWFtSXRlcmF0b3IoZmluYWxDaHVuaywgZW5zdXJlQ29uZmlnKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RyZWFtIGFsbCBvdXRwdXQgZnJvbSBhIHJ1bm5hYmxlLCBhcyByZXBvcnRlZCB0byB0aGUgY2FsbGJhY2sgc3lzdGVtLlxuICAgICAqIFRoaXMgaW5jbHVkZXMgYWxsIGlubmVyIHJ1bnMgb2YgTExNcywgUmV0cmlldmVycywgVG9vbHMsIGV0Yy5cbiAgICAgKiBPdXRwdXQgaXMgc3RyZWFtZWQgYXMgTG9nIG9iamVjdHMsIHdoaWNoIGluY2x1ZGUgYSBsaXN0IG9mXG4gICAgICoganNvbnBhdGNoIG9wcyB0aGF0IGRlc2NyaWJlIGhvdyB0aGUgc3RhdGUgb2YgdGhlIHJ1biBoYXMgY2hhbmdlZCBpbiBlYWNoXG4gICAgICogc3RlcCwgYW5kIHRoZSBmaW5hbCBzdGF0ZSBvZiB0aGUgcnVuLlxuICAgICAqIFRoZSBqc29ucGF0Y2ggb3BzIGNhbiBiZSBhcHBsaWVkIGluIG9yZGVyIHRvIGNvbnN0cnVjdCBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBzdHJlYW1PcHRpb25zXG4gICAgICovXG4gICAgYXN5bmMgKnN0cmVhbUxvZyhpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucykge1xuICAgICAgICBjb25zdCBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIgPSBuZXcgTG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyKHtcbiAgICAgICAgICAgIC4uLnN0cmVhbU9wdGlvbnMsXG4gICAgICAgICAgICBhdXRvQ2xvc2U6IGZhbHNlLFxuICAgICAgICAgICAgX3NjaGVtYUZvcm1hdDogXCJvcmlnaW5hbFwiLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICB5aWVsZCogdGhpcy5fc3RyZWFtTG9nKGlucHV0LCBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIsIGNvbmZpZyk7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtTG9nKGlucHV0LCBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIsIGNvbmZpZykge1xuICAgICAgICBjb25zdCB7IGNhbGxiYWNrcyB9ID0gY29uZmlnO1xuICAgICAgICBpZiAoY2FsbGJhY2tzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrcyA9IFtsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2FsbGJhY2tzKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gY2FsbGJhY2tzLmNvbmNhdChbbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb3BpZWRDYWxsYmFja3MgPSBjYWxsYmFja3MuY29weSgpO1xuICAgICAgICAgICAgY29waWVkQ2FsbGJhY2tzLmluaGVyaXRhYmxlSGFuZGxlcnMucHVzaChsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gY29waWVkQ2FsbGJhY2tzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlU3RyZWFtUHJvbWlzZSA9IHRoaXMuc3RyZWFtKGlucHV0LCBjb25maWcpO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb25zdW1lUnVubmFibGVTdHJlYW0oKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bm5hYmxlU3RyZWFtID0gYXdhaXQgcnVubmFibGVTdHJlYW1Qcm9taXNlO1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcnVubmFibGVTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0Y2ggPSBuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogXCIvc3RyZWFtZWRfb3V0cHV0Ly1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLndyaXRlci53cml0ZShwYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLndyaXRlci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlU3RyZWFtQ29uc3VtZVByb21pc2UgPSBjb25zdW1lUnVubmFibGVTdHJlYW0oKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgbG9nIG9mIGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIGxvZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bm5hYmxlU3RyZWFtQ29uc3VtZVByb21pc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgKnN0cmVhbUV2ZW50cyhpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCB0aGlzLl9zdHJlYW1FdmVudHMoaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpO1xuICAgICAgICAgICAgeWllbGQqIGNvbnZlcnRUb0h0dHBFdmVudFN0cmVhbShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeWllbGQqIHRoaXMuX3N0cmVhbUV2ZW50cyhpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1FdmVudHMoaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMudmVyc2lvbiAhPT0gXCJ2MVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgdmVyc2lvbiBcInYxXCIgb2YgdGhlIGV2ZW50cyBzY2hlbWEgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcnVuTG9nO1xuICAgICAgICBsZXQgaGFzRW5jb3VudGVyZWRTdGFydEV2ZW50ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgcm9vdFRhZ3MgPSBjb25maWcudGFncyA/PyBbXTtcbiAgICAgICAgY29uc3Qgcm9vdE1ldGFkYXRhID0gY29uZmlnLm1ldGFkYXRhID8/IHt9O1xuICAgICAgICBjb25zdCByb290TmFtZSA9IGNvbmZpZy5ydW5OYW1lID8/IHRoaXMuZ2V0TmFtZSgpO1xuICAgICAgICBjb25zdCBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIgPSBuZXcgTG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyKHtcbiAgICAgICAgICAgIC4uLnN0cmVhbU9wdGlvbnMsXG4gICAgICAgICAgICBhdXRvQ2xvc2U6IGZhbHNlLFxuICAgICAgICAgICAgX3NjaGVtYUZvcm1hdDogXCJzdHJlYW1pbmdfZXZlbnRzXCIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByb290RXZlbnRGaWx0ZXIgPSBuZXcgX1Jvb3RFdmVudEZpbHRlcih7XG4gICAgICAgICAgICAuLi5zdHJlYW1PcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbG9nU3RyZWFtID0gdGhpcy5fc3RyZWFtTG9nKGlucHV0LCBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIsIGNvbmZpZyk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgbG9nIG9mIGxvZ1N0cmVhbSkge1xuICAgICAgICAgICAgaWYgKCFydW5Mb2cpIHtcbiAgICAgICAgICAgICAgICBydW5Mb2cgPSBSdW5Mb2cuZnJvbVJ1bkxvZ1BhdGNoKGxvZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBydW5Mb2cgPSBydW5Mb2cuY29uY2F0KGxvZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnVuTG9nLnN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIGVycm9yOiBcInN0cmVhbUV2ZW50c1wiIHN0YXRlIGlzIG1pc3NpbmcuIFBsZWFzZSBvcGVuIGEgYnVnIHJlcG9ydC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFlpZWxkIHRoZSBzdGFydCBldmVudCBmb3IgdGhlIHJvb3QgcnVubmFibGUgaWYgaXQgaGFzbid0IGJlZW4gc2Vlbi5cbiAgICAgICAgICAgIC8vIFRoZSByb290IHJ1biBpcyBuZXZlciBmaWx0ZXJlZCBvdXRcbiAgICAgICAgICAgIGlmICghaGFzRW5jb3VudGVyZWRTdGFydEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaGFzRW5jb3VudGVyZWRTdGFydEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHsgLi4ucnVuTG9nLnN0YXRlIH07XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bl9pZDogc3RhdGUuaWQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBgb25fJHtzdGF0ZS50eXBlfV9zdGFydGAsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHJvb3ROYW1lLFxuICAgICAgICAgICAgICAgICAgICB0YWdzOiByb290VGFncyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHJvb3RNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocm9vdEV2ZW50RmlsdGVyLmluY2x1ZGVFdmVudChldmVudCwgc3RhdGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgZXZlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGF0aHMgPSBsb2cub3BzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigob3ApID0+IG9wLnBhdGguc3RhcnRzV2l0aChcIi9sb2dzL1wiKSlcbiAgICAgICAgICAgICAgICAubWFwKChvcCkgPT4gb3AucGF0aC5zcGxpdChcIi9cIilbMl0pO1xuICAgICAgICAgICAgY29uc3QgZGVkdXBlZFBhdGhzID0gWy4uLm5ldyBTZXQocGF0aHMpXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBkZWR1cGVkUGF0aHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRUeXBlO1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0ge307XG4gICAgICAgICAgICAgICAgY29uc3QgbG9nRW50cnkgPSBydW5Mb2cuc3RhdGUubG9nc1twYXRoXTtcbiAgICAgICAgICAgICAgICBpZiAobG9nRW50cnkuZW5kX3RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9nRW50cnkuc3RyZWFtZWRfb3V0cHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9IFwic3RyZWFtXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFR5cGUgPSBcInN0YXJ0XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9IFwiZW5kXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudFR5cGUgPT09IFwic3RhcnRcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIHRoZSBpbnB1dHMgd2l0aCB0aGUgc3RhcnQgZXZlbnQgaWYgdGhleSBhcmUgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgICAgICAvLyBVc3VhbGx5IHRoZXkgd2lsbCBOT1QgYmUgYXZhaWxhYmxlIGZvciBjb21wb25lbnRzIHRoYXQgb3BlcmF0ZVxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBzdHJlYW1zLCBzaW5jZSB0aG9zZSBjb21wb25lbnRzIHN0cmVhbSB0aGUgaW5wdXQgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGtub3cgaXRzIGZpbmFsIHZhbHVlIHVudGlsIHRoZSBlbmQgb2YgdGhlIHN0cmVhbS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ0VudHJ5LmlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmlucHV0ID0gbG9nRW50cnkuaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gXCJlbmRcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9nRW50cnkuaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaW5wdXQgPSBsb2dFbnRyeS5pbnB1dHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YS5vdXRwdXQgPSBsb2dFbnRyeS5maW5hbF9vdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gXCJzdHJlYW1cIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua0NvdW50ID0gbG9nRW50cnkuc3RyZWFtZWRfb3V0cHV0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rQ291bnQgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgZXhhY3RseSBvbmUgY2h1bmsgb2Ygc3RyZWFtZWQgb3V0cHV0LCBnb3QgJHtjaHVua0NvdW50fSBpbnN0ZWFkLiBFbmNvdW50ZXJlZCBpbjogXCIke2xvZ0VudHJ5Lm5hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhID0geyBjaHVuazogbG9nRW50cnkuc3RyZWFtZWRfb3V0cHV0WzBdIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSBzdHJlYW0sIHdlIGRvbid0IG5lZWQgaXQgYW55bW9yZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQW5kIHRoaXMgYXZvaWRzIGR1cGxpY2F0ZXMgYXMgd2VsbCFcbiAgICAgICAgICAgICAgICAgICAgbG9nRW50cnkuc3RyZWFtZWRfb3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGBvbl8ke2xvZ0VudHJ5LnR5cGV9XyR7ZXZlbnRUeXBlfWAsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGxvZ0VudHJ5Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJ1bl9pZDogbG9nRW50cnkuaWQsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IGxvZ0VudHJ5LnRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBsb2dFbnRyeS5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluYWxseSwgd2UgdGFrZSBjYXJlIG9mIHRoZSBzdHJlYW1pbmcgb3V0cHV0IGZyb20gdGhlIHJvb3QgY2hhaW5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueS5cbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHJ1bkxvZztcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zdHJlYW1lZF9vdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rQ291bnQgPSBzdGF0ZS5zdHJlYW1lZF9vdXRwdXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjaHVua0NvdW50ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgZXhhY3RseSBvbmUgY2h1bmsgb2Ygc3RyZWFtZWQgb3V0cHV0LCBnb3QgJHtjaHVua0NvdW50fSBpbnN0ZWFkLiBFbmNvdW50ZXJlZCBpbjogXCIke3N0YXRlLm5hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHsgY2h1bms6IHN0YXRlLnN0cmVhbWVkX291dHB1dFswXSB9O1xuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSBzdHJlYW0sIHdlIGRvbid0IG5lZWQgaXQgYW55bW9yZS5cbiAgICAgICAgICAgICAgICBzdGF0ZS5zdHJlYW1lZF9vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGBvbl8ke3N0YXRlLnR5cGV9X3N0cmVhbWAsXG4gICAgICAgICAgICAgICAgICAgIHJ1bl9pZDogc3RhdGUuaWQsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IHJvb3RUYWdzLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogcm9vdE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiByb290TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyb290RXZlbnRGaWx0ZXIuaW5jbHVkZUV2ZW50KGV2ZW50LCBzdGF0ZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBldmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBydW5Mb2c/LnN0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gRmluYWxseSwgeWllbGQgdGhlIGVuZCBldmVudCBmb3IgdGhlIHJvb3QgcnVubmFibGUuXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICAgICAgICBldmVudDogYG9uXyR7c3RhdGUudHlwZX1fZW5kYCxcbiAgICAgICAgICAgICAgICBuYW1lOiByb290TmFtZSxcbiAgICAgICAgICAgICAgICBydW5faWQ6IHN0YXRlLmlkLFxuICAgICAgICAgICAgICAgIHRhZ3M6IHJvb3RUYWdzLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiByb290TWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IHN0YXRlLmZpbmFsX291dHB1dCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyb290RXZlbnRGaWx0ZXIuaW5jbHVkZUV2ZW50KGV2ZW50LCBzdGF0ZS50eXBlKSlcbiAgICAgICAgICAgICAgICB5aWVsZCBldmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBpc1J1bm5hYmxlKHRoaW5nKSB7XG4gICAgICAgIHJldHVybiBpc1J1bm5hYmxlSW50ZXJmYWNlKHRoaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCBsaWZlY3ljbGUgbGlzdGVuZXJzIHRvIGEgUnVubmFibGUsIHJldHVybmluZyBhIG5ldyBSdW5uYWJsZS5cbiAgICAgKiBUaGUgUnVuIG9iamVjdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcnVuLCBpbmNsdWRpbmcgaXRzIGlkLFxuICAgICAqIHR5cGUsIGlucHV0LCBvdXRwdXQsIGVycm9yLCBzdGFydFRpbWUsIGVuZFRpbWUsIGFuZCBhbnkgdGFncyBvciBtZXRhZGF0YVxuICAgICAqIGFkZGVkIHRvIHRoZSBydW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbnMuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vblN0YXJ0IC0gQ2FsbGVkIGJlZm9yZSB0aGUgcnVubmFibGUgc3RhcnRzIHJ1bm5pbmcsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vbkVuZCAtIENhbGxlZCBhZnRlciB0aGUgcnVubmFibGUgZmluaXNoZXMgcnVubmluZywgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uRXJyb3IgLSBDYWxsZWQgaWYgdGhlIHJ1bm5hYmxlIHRocm93cyBhbiBlcnJvciwgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKi9cbiAgICB3aXRoTGlzdGVuZXJzKHsgb25TdGFydCwgb25FbmQsIG9uRXJyb3IsIH0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlQmluZGluZyh7XG4gICAgICAgICAgICBib3VuZDogdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZzoge30sXG4gICAgICAgICAgICBjb25maWdGYWN0b3JpZXM6IFtcbiAgICAgICAgICAgICAgICAoY29uZmlnKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBSb290TGlzdGVuZXJzVHJhY2VyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCBkZWxlZ2F0ZXMgY2FsbHMgdG8gYW5vdGhlciBydW5uYWJsZSB3aXRoIGEgc2V0IG9mIGt3YXJncy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlQmluZGluZyBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVCaW5kaW5nXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJvdW5kXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmZpZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrd2FyZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZmlnRmFjdG9yaWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm91bmQgPSBmaWVsZHMuYm91bmQ7XG4gICAgICAgIHRoaXMua3dhcmdzID0gZmllbGRzLmt3YXJncztcbiAgICAgICAgdGhpcy5jb25maWcgPSBmaWVsZHMuY29uZmlnO1xuICAgICAgICB0aGlzLmNvbmZpZ0ZhY3RvcmllcyA9IGZpZWxkcy5jb25maWdGYWN0b3JpZXM7XG4gICAgfVxuICAgIGdldE5hbWUoc3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLmdldE5hbWUoc3VmZml4KTtcbiAgICB9XG4gICAgYXN5bmMgX21lcmdlQ29uZmlnKC4uLm9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gbWVyZ2VDb25maWdzKHRoaXMuY29uZmlnLCAuLi5vcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG1lcmdlQ29uZmlncyhjb25maWcsIC4uLih0aGlzLmNvbmZpZ0ZhY3Rvcmllc1xuICAgICAgICAgICAgPyBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmNvbmZpZ0ZhY3Rvcmllcy5tYXAoYXN5bmMgKGNvbmZpZ0ZhY3RvcnkpID0+IGF3YWl0IGNvbmZpZ0ZhY3RvcnkoY29uZmlnKSkpXG4gICAgICAgICAgICA6IFtdKSk7XG4gICAgfVxuICAgIGJpbmQoa3dhcmdzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZCxcbiAgICAgICAgICAgIGt3YXJnczogeyAuLi50aGlzLmt3YXJncywgLi4ua3dhcmdzIH0sXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2l0aENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLFxuICAgICAgICAgICAga3dhcmdzOiB0aGlzLmt3YXJncyxcbiAgICAgICAgICAgIGNvbmZpZzogeyAuLi50aGlzLmNvbmZpZywgLi4uY29uZmlnIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3aXRoUmV0cnkoZmllbGRzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZC53aXRoUmV0cnkoZmllbGRzKSxcbiAgICAgICAgICAgIGt3YXJnczogdGhpcy5rd2FyZ3MsXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLmludm9rZShpbnB1dCwgYXdhaXQgdGhpcy5fbWVyZ2VDb25maWcoZW5zdXJlQ29uZmlnKG9wdGlvbnMpLCB0aGlzLmt3YXJncykpO1xuICAgIH1cbiAgICBhc3luYyBiYXRjaChpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICBjb25zdCBtZXJnZWRPcHRpb25zID0gQXJyYXkuaXNBcnJheShvcHRpb25zKVxuICAgICAgICAgICAgPyBhd2FpdCBQcm9taXNlLmFsbChvcHRpb25zLm1hcChhc3luYyAoaW5kaXZpZHVhbE9wdGlvbikgPT4gdGhpcy5fbWVyZ2VDb25maWcoZW5zdXJlQ29uZmlnKGluZGl2aWR1YWxPcHRpb24pLCB0aGlzLmt3YXJncykpKVxuICAgICAgICAgICAgOiBhd2FpdCB0aGlzLl9tZXJnZUNvbmZpZyhlbnN1cmVDb25maWcob3B0aW9ucyksIHRoaXMua3dhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmQuYmF0Y2goaW5wdXRzLCBtZXJnZWRPcHRpb25zLCBiYXRjaE9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLmJvdW5kLl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgYXdhaXQgdGhpcy5fbWVyZ2VDb25maWcoZW5zdXJlQ29uZmlnKG9wdGlvbnMpLCB0aGlzLmt3YXJncykpO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmQuc3RyZWFtKGlucHV0LCBhd2FpdCB0aGlzLl9tZXJnZUNvbmZpZyhlbnN1cmVDb25maWcob3B0aW9ucyksIHRoaXMua3dhcmdzKSk7XG4gICAgfVxuICAgIGFzeW5jICp0cmFuc2Zvcm0oXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgeWllbGQqIHRoaXMuYm91bmQudHJhbnNmb3JtKGdlbmVyYXRvciwgYXdhaXQgdGhpcy5fbWVyZ2VDb25maWcoZW5zdXJlQ29uZmlnKG9wdGlvbnMpLCB0aGlzLmt3YXJncykpO1xuICAgIH1cbiAgICBhc3luYyAqc3RyZWFtRXZlbnRzKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLmJvdW5kLnN0cmVhbUV2ZW50cyhpbnB1dCwge1xuICAgICAgICAgICAgLi4uKGF3YWl0IHRoaXMuX21lcmdlQ29uZmlnKGVuc3VyZUNvbmZpZyhvcHRpb25zKSwgdGhpcy5rd2FyZ3MpKSxcbiAgICAgICAgICAgIHZlcnNpb246IG9wdGlvbnMudmVyc2lvbixcbiAgICAgICAgfSwgc3RyZWFtT3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1J1bm5hYmxlQmluZGluZyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHRoaW5nXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaW5nLmJvdW5kICYmIFJ1bm5hYmxlLmlzUnVubmFibGUodGhpbmcuYm91bmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIGxpZmVjeWNsZSBsaXN0ZW5lcnMgdG8gYSBSdW5uYWJsZSwgcmV0dXJuaW5nIGEgbmV3IFJ1bm5hYmxlLlxuICAgICAqIFRoZSBSdW4gb2JqZWN0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBydW4sIGluY2x1ZGluZyBpdHMgaWQsXG4gICAgICogdHlwZSwgaW5wdXQsIG91dHB1dCwgZXJyb3IsIHN0YXJ0VGltZSwgZW5kVGltZSwgYW5kIGFueSB0YWdzIG9yIG1ldGFkYXRhXG4gICAgICogYWRkZWQgdG8gdGhlIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uU3RhcnQgLSBDYWxsZWQgYmVmb3JlIHRoZSBydW5uYWJsZSBzdGFydHMgcnVubmluZywgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uRW5kIC0gQ2FsbGVkIGFmdGVyIHRoZSBydW5uYWJsZSBmaW5pc2hlcyBydW5uaW5nLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25FcnJvciAtIENhbGxlZCBpZiB0aGUgcnVubmFibGUgdGhyb3dzIGFuIGVycm9yLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqL1xuICAgIHdpdGhMaXN0ZW5lcnMoeyBvblN0YXJ0LCBvbkVuZCwgb25FcnJvciwgfSkge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlQmluZGluZyh7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZCxcbiAgICAgICAgICAgIGt3YXJnczogdGhpcy5rd2FyZ3MsXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgY29uZmlnRmFjdG9yaWVzOiBbXG4gICAgICAgICAgICAgICAgKGNvbmZpZykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgUm9vdExpc3RlbmVyc1RyYWNlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgZGVsZWdhdGVzIGNhbGxzIHRvIGFub3RoZXIgcnVubmFibGVcbiAqIHdpdGggZWFjaCBlbGVtZW50IG9mIHRoZSBpbnB1dCBzZXF1ZW5jZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlRWFjaCBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVFYWNoXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJvdW5kXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm91bmQgPSBmaWVsZHMuYm91bmQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmRzIHRoZSBydW5uYWJsZSB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBrd2FyZ3MgVGhlIGFyZ3VtZW50cyB0byBiaW5kIHRoZSBydW5uYWJsZSB3aXRoLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUnVubmFibGVFYWNoYCBjbGFzcyB0aGF0IGlzIGJvdW5kIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgYmluZChrd2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUVhY2goe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMuYm91bmQuYmluZChrd2FyZ3MpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgcnVubmFibGUgd2l0aCB0aGUgc3BlY2lmaWVkIGlucHV0IGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gaW52b2tlIHRoZSBydW5uYWJsZSB3aXRoLlxuICAgICAqIEBwYXJhbSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gdG8gaW52b2tlIHRoZSBydW5uYWJsZSB3aXRoLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBvdXRwdXQgb2YgdGhlIHJ1bm5hYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIGludm9rZShpbnB1dHMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5faW52b2tlLCBpbnB1dHMsIGNvbmZpZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW52b2tlIHRoZSBydW5uYWJsZSB3aXRoIHRoZSBzcGVjaWZpZWQgaW5wdXQgYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBpbnZva2UgdGhlIHJ1bm5hYmxlIHdpdGguXG4gICAgICogQHBhcmFtIGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiB0byBpbnZva2UgdGhlIHJ1bm5hYmxlIHdpdGguXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG91dHB1dCBvZiB0aGUgcnVubmFibGUuXG4gICAgICovXG4gICAgYXN5bmMgX2ludm9rZShpbnB1dHMsIGNvbmZpZywgcnVuTWFuYWdlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZC5iYXRjaChpbnB1dHMsIHBhdGNoQ29uZmlnKGNvbmZpZywgeyBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCkgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIGxpZmVjeWNsZSBsaXN0ZW5lcnMgdG8gYSBSdW5uYWJsZSwgcmV0dXJuaW5nIGEgbmV3IFJ1bm5hYmxlLlxuICAgICAqIFRoZSBSdW4gb2JqZWN0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBydW4sIGluY2x1ZGluZyBpdHMgaWQsXG4gICAgICogdHlwZSwgaW5wdXQsIG91dHB1dCwgZXJyb3IsIHN0YXJ0VGltZSwgZW5kVGltZSwgYW5kIGFueSB0YWdzIG9yIG1ldGFkYXRhXG4gICAgICogYWRkZWQgdG8gdGhlIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uU3RhcnQgLSBDYWxsZWQgYmVmb3JlIHRoZSBydW5uYWJsZSBzdGFydHMgcnVubmluZywgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uRW5kIC0gQ2FsbGVkIGFmdGVyIHRoZSBydW5uYWJsZSBmaW5pc2hlcyBydW5uaW5nLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25FcnJvciAtIENhbGxlZCBpZiB0aGUgcnVubmFibGUgdGhyb3dzIGFuIGVycm9yLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqL1xuICAgIHdpdGhMaXN0ZW5lcnMoeyBvblN0YXJ0LCBvbkVuZCwgb25FcnJvciwgfSkge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlRWFjaCh7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZC53aXRoTGlzdGVuZXJzKHsgb25TdGFydCwgb25FbmQsIG9uRXJyb3IgfSksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgcnVubmFibGVzIHRoYXQgY2FuIGJlIHJldHJpZWQgYVxuICogc3BlY2lmaWVkIG51bWJlciBvZiB0aW1lcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlUmV0cnkgZXh0ZW5kcyBSdW5uYWJsZUJpbmRpbmcge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZVJldHJ5XCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhBdHRlbXB0TnVtYmVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkZhaWxlZEF0dGVtcHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICgpID0+IHsgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhBdHRlbXB0TnVtYmVyID0gZmllbGRzLm1heEF0dGVtcHROdW1iZXIgPz8gdGhpcy5tYXhBdHRlbXB0TnVtYmVyO1xuICAgICAgICB0aGlzLm9uRmFpbGVkQXR0ZW1wdCA9IGZpZWxkcy5vbkZhaWxlZEF0dGVtcHQgPz8gdGhpcy5vbkZhaWxlZEF0dGVtcHQ7XG4gICAgfVxuICAgIF9wYXRjaENvbmZpZ0ZvclJldHJ5KGF0dGVtcHQsIGNvbmZpZywgcnVuTWFuYWdlcikge1xuICAgICAgICBjb25zdCB0YWcgPSBhdHRlbXB0ID4gMSA/IGByZXRyeTphdHRlbXB0OiR7YXR0ZW1wdH1gIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcGF0Y2hDb25maWcoY29uZmlnLCB7IGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQodGFnKSB9KTtcbiAgICB9XG4gICAgYXN5bmMgX2ludm9rZShpbnB1dCwgY29uZmlnLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiBwUmV0cnkoKGF0dGVtcHROdW1iZXIpID0+IHN1cGVyLmludm9rZShpbnB1dCwgdGhpcy5fcGF0Y2hDb25maWdGb3JSZXRyeShhdHRlbXB0TnVtYmVyLCBjb25maWcsIHJ1bk1hbmFnZXIpKSwge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIG9uRmFpbGVkQXR0ZW1wdDogKGVycm9yKSA9PiB0aGlzLm9uRmFpbGVkQXR0ZW1wdChlcnJvciwgaW5wdXQpLFxuICAgICAgICAgICAgcmV0cmllczogTWF0aC5tYXgodGhpcy5tYXhBdHRlbXB0TnVtYmVyIC0gMSwgMCksXG4gICAgICAgICAgICByYW5kb21pemU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBpbnZva2VzIHRoZSBydW5uYWJsZSB3aXRoIHRoZSBzcGVjaWZpZWQgaW5wdXQsIHJ1biBtYW5hZ2VyLFxuICAgICAqIGFuZCBjb25maWcuIEl0IGhhbmRsZXMgdGhlIHJldHJ5IGxvZ2ljIGJ5IGNhdGNoaW5nIGFueSBlcnJvcnMgYW5kXG4gICAgICogcmVjdXJzaXZlbHkgaW52b2tpbmcgaXRzZWxmIHdpdGggdGhlIHVwZGF0ZWQgY29uZmlnIGZvciB0aGUgbmV4dCByZXRyeVxuICAgICAqIGF0dGVtcHQuXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBmb3IgdGhlIHJ1bm5hYmxlLlxuICAgICAqIEBwYXJhbSBydW5NYW5hZ2VyIFRoZSBydW4gbWFuYWdlciBmb3IgdGhlIHJ1bm5hYmxlLlxuICAgICAqIEBwYXJhbSBjb25maWcgVGhlIGNvbmZpZyBmb3IgdGhlIHJ1bm5hYmxlLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBvdXRwdXQgb2YgdGhlIHJ1bm5hYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIGludm9rZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsV2l0aENvbmZpZyh0aGlzLl9pbnZva2UsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgICBhc3luYyBfYmF0Y2goaW5wdXRzLCBjb25maWdzLCBydW5NYW5hZ2VycywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHNNYXAgPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHBSZXRyeShhc3luYyAoYXR0ZW1wdE51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0luZGV4ZXMgPSBpbnB1dHNcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoXywgaSkgPT4gaSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoaSkgPT4gcmVzdWx0c01hcFtpLnRvU3RyaW5nKCldID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzTWFwW2kudG9TdHJpbmcoKV0gaW5zdGFuY2VvZiBFcnJvcik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nSW5wdXRzID0gcmVtYWluaW5nSW5kZXhlcy5tYXAoKGkpID0+IGlucHV0c1tpXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0Y2hlZENvbmZpZ3MgPSByZW1haW5pbmdJbmRleGVzLm1hcCgoaSkgPT4gdGhpcy5fcGF0Y2hDb25maWdGb3JSZXRyeShhdHRlbXB0TnVtYmVyLCBjb25maWdzPy5baV0sIHJ1bk1hbmFnZXJzPy5baV0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgc3VwZXIuYmF0Y2gocmVtYWluaW5nSW5wdXRzLCBwYXRjaGVkQ29uZmlncywge1xuICAgICAgICAgICAgICAgICAgICAuLi5iYXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkV4Y2VwdGlvbnM6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0RXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRNYXBJbmRleCA9IHJlbWFpbmluZ0luZGV4ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RFeGNlcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RXhjZXB0aW9uID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RFeGNlcHRpb24uaW5wdXQgPSByZW1haW5pbmdJbnB1dHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c01hcFtyZXN1bHRNYXBJbmRleC50b1N0cmluZygpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZpcnN0RXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIG9uRmFpbGVkQXR0ZW1wdDogKGVycm9yKSA9PiB0aGlzLm9uRmFpbGVkQXR0ZW1wdChlcnJvciwgZXJyb3IuaW5wdXQpLFxuICAgICAgICAgICAgICAgIHJldHJpZXM6IE1hdGgubWF4KHRoaXMubWF4QXR0ZW1wdE51bWJlciAtIDEsIDApLFxuICAgICAgICAgICAgICAgIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoYmF0Y2hPcHRpb25zPy5yZXR1cm5FeGNlcHRpb25zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzdWx0c01hcClcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBwYXJzZUludChhLCAxMCkgLSBwYXJzZUludChiLCAxMCkpXG4gICAgICAgICAgICAubWFwKChrZXkpID0+IHJlc3VsdHNNYXBbcGFyc2VJbnQoa2V5LCAxMCldKTtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhdGNoV2l0aENvbmZpZyh0aGlzLl9iYXRjaC5iaW5kKHRoaXMpLCBpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucyk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHNlcXVlbmNlIG9mIHJ1bm5hYmxlcywgd2hlcmUgdGhlIG91dHB1dCBvZiBlYWNoIGlzIHRoZSBpbnB1dCBvZiB0aGUgbmV4dC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBwcm9tcHRUZW1wbGF0ZSA9IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcbiAqICAgXCJUZWxsIG1lIGEgam9rZSBhYm91dCB7dG9waWN9XCIsXG4gKiApO1xuICogY29uc3QgY2hhaW4gPSBSdW5uYWJsZVNlcXVlbmNlLmZyb20oW3Byb21wdFRlbXBsYXRlLCBuZXcgQ2hhdE9wZW5BSSh7fSldKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoYWluLmludm9rZSh7IHRvcGljOiBcImJlYXJzXCIgfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlU2VxdWVuY2UgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlU2VxdWVuY2VcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpcnN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1pZGRsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhc3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpcnN0ID0gZmllbGRzLmZpcnN0O1xuICAgICAgICB0aGlzLm1pZGRsZSA9IGZpZWxkcy5taWRkbGUgPz8gdGhpcy5taWRkbGU7XG4gICAgICAgIHRoaXMubGFzdCA9IGZpZWxkcy5sYXN0O1xuICAgICAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZTtcbiAgICB9XG4gICAgZ2V0IHN0ZXBzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuZmlyc3QsIC4uLnRoaXMubWlkZGxlLCB0aGlzLmxhc3RdO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXQsIFwiaW5wdXRcIiksIGNvbmZpZy5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnPy5ydW5OYW1lKTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5ydW5JZDtcbiAgICAgICAgbGV0IG5leHRTdGVwSW5wdXQgPSBpbnB1dDtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFN0ZXBzID0gW3RoaXMuZmlyc3QsIC4uLnRoaXMubWlkZGxlXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5pdGlhbFN0ZXBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcCA9IGluaXRpYWxTdGVwc1tpXTtcbiAgICAgICAgICAgICAgICBuZXh0U3RlcElucHV0ID0gYXdhaXQgc3RlcC5pbnZva2UobmV4dFN0ZXBJbnB1dCwgcGF0Y2hDb25maWcoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYHNlcTpzdGVwOiR7aSArIDF9YCksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCBjYW4ndCBkZXRlY3QgdGhhdCB0aGUgbGFzdCBvdXRwdXQgb2YgdGhlIHNlcXVlbmNlIHJldHVybnMgUnVuT3V0cHV0LCBzbyBjYWxsIGl0IG91dCBvZiB0aGUgbG9vcCBoZXJlXG4gICAgICAgICAgICBmaW5hbE91dHB1dCA9IGF3YWl0IHRoaXMubGFzdC5pbnZva2UobmV4dFN0ZXBJbnB1dCwgcGF0Y2hDb25maWcoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZChgc2VxOnN0ZXA6JHt0aGlzLnN0ZXBzLmxlbmd0aH1gKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChmaW5hbE91dHB1dCwgXCJvdXRwdXRcIikpO1xuICAgICAgICByZXR1cm4gZmluYWxPdXRwdXQ7XG4gICAgfVxuICAgIGFzeW5jIGJhdGNoKGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKGNvbmZpZ0xpc3QubWFwKGdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZykpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKGNhbGxiYWNrTWFuYWdlcnMubWFwKGFzeW5jIChjYWxsYmFja01hbmFnZXIsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVN0YXJ0UmVzID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXRzW2ldLCBcImlucHV0XCIpLCBjb25maWdMaXN0W2ldLnJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWdMaXN0W2ldLnJ1bk5hbWUpO1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZ0xpc3RbaV0ucnVuSWQ7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RhcnRSZXM7XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IG5leHRTdGVwSW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0ZXBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuc3RlcHNbaV07XG4gICAgICAgICAgICAgICAgbmV4dFN0ZXBJbnB1dHMgPSBhd2FpdCBzdGVwLmJhdGNoKG5leHRTdGVwSW5wdXRzLCBydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIsIGopID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRSdW5NYW5hZ2VyID0gcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYHNlcTpzdGVwOiR7aSArIDF9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRjaENvbmZpZyhjb25maWdMaXN0W2pdLCB7IGNhbGxiYWNrczogY2hpbGRSdW5NYW5hZ2VyIH0pO1xuICAgICAgICAgICAgICAgIH0pLCBiYXRjaE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSkpKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KG5leHRTdGVwSW5wdXRzLCBcIm91dHB1dFwiKSkpKTtcbiAgICAgICAgcmV0dXJuIG5leHRTdGVwSW5wdXRzO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgcnVuSWQsIC4uLm90aGVyT3B0aW9ucyB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dCwgXCJpbnB1dFwiKSwgcnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG90aGVyT3B0aW9ucz8ucnVuTmFtZSk7XG4gICAgICAgIGNvbnN0IHN0ZXBzID0gW3RoaXMuZmlyc3QsIC4uLnRoaXMubWlkZGxlLCB0aGlzLmxhc3RdO1xuICAgICAgICBsZXQgY29uY2F0U3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICBhc3luYyBmdW5jdGlvbiogaW5wdXRHZW5lcmF0b3IoKSB7XG4gICAgICAgICAgICB5aWVsZCBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGZpbmFsR2VuZXJhdG9yID0gc3RlcHNbMF0udHJhbnNmb3JtKGlucHV0R2VuZXJhdG9yKCksIHBhdGNoQ29uZmlnKG90aGVyT3B0aW9ucywge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYHNlcTpzdGVwOjFgKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RlcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gc3RlcHNbaV07XG4gICAgICAgICAgICAgICAgZmluYWxHZW5lcmF0b3IgPSBhd2FpdCBzdGVwLnRyYW5zZm9ybShmaW5hbEdlbmVyYXRvciwgcGF0Y2hDb25maWcob3RoZXJPcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYHNlcTpzdGVwOiR7aSArIDF9YCksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBmaW5hbEdlbmVyYXRvcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgIGlmIChjb25jYXRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjb25jYXQoZmluYWxPdXRwdXQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2F0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3QoZmluYWxPdXRwdXQsIFwib3V0cHV0XCIpKTtcbiAgICB9XG4gICAgZ2V0R3JhcGgoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGdyYXBoID0gbmV3IEdyYXBoKCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCBjdXJyZW50TGFzdE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0ZXBzLmZvckVhY2goKHN0ZXAsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGVwR3JhcGggPSBzdGVwLmdldEdyYXBoKGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICBzdGVwR3JhcGgudHJpbUZpcnN0Tm9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSB0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBzdGVwR3JhcGgudHJpbUxhc3ROb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmFwaC5leHRlbmQoc3RlcEdyYXBoKTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBGaXJzdE5vZGUgPSBzdGVwR3JhcGguZmlyc3ROb2RlKCk7XG4gICAgICAgICAgICBpZiAoIXN0ZXBGaXJzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJ1bm5hYmxlICR7c3RlcH0gaGFzIG5vIGZpcnN0IG5vZGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50TGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBncmFwaC5hZGRFZGdlKGN1cnJlbnRMYXN0Tm9kZSwgc3RlcEZpcnN0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50TGFzdE5vZGUgPSBzdGVwR3JhcGgubGFzdE5vZGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBncmFwaDtcbiAgICB9XG4gICAgcGlwZShjb2VyY2VhYmxlKSB7XG4gICAgICAgIGlmIChSdW5uYWJsZVNlcXVlbmNlLmlzUnVubmFibGVTZXF1ZW5jZShjb2VyY2VhYmxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVNlcXVlbmNlKHtcbiAgICAgICAgICAgICAgICBmaXJzdDogdGhpcy5maXJzdCxcbiAgICAgICAgICAgICAgICBtaWRkbGU6IHRoaXMubWlkZGxlLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdCxcbiAgICAgICAgICAgICAgICAgICAgY29lcmNlYWJsZS5maXJzdCxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29lcmNlYWJsZS5taWRkbGUsXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgbGFzdDogY29lcmNlYWJsZS5sYXN0LFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSA/PyBjb2VyY2VhYmxlLm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUnVubmFibGVTZXF1ZW5jZSh7XG4gICAgICAgICAgICAgICAgZmlyc3Q6IHRoaXMuZmlyc3QsXG4gICAgICAgICAgICAgICAgbWlkZGxlOiBbLi4udGhpcy5taWRkbGUsIHRoaXMubGFzdF0sXG4gICAgICAgICAgICAgICAgbGFzdDogX2NvZXJjZVRvUnVubmFibGUoY29lcmNlYWJsZSksXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgaXNSdW5uYWJsZVNlcXVlbmNlKHRoaW5nKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaW5nLm1pZGRsZSkgJiYgUnVubmFibGUuaXNSdW5uYWJsZSh0aGluZyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGZyb20oW2ZpcnN0LCAuLi5ydW5uYWJsZXNdLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVTZXF1ZW5jZSh7XG4gICAgICAgICAgICBmaXJzdDogX2NvZXJjZVRvUnVubmFibGUoZmlyc3QpLFxuICAgICAgICAgICAgbWlkZGxlOiBydW5uYWJsZXMuc2xpY2UoMCwgLTEpLm1hcChfY29lcmNlVG9SdW5uYWJsZSksXG4gICAgICAgICAgICBsYXN0OiBfY29lcmNlVG9SdW5uYWJsZShydW5uYWJsZXNbcnVubmFibGVzLmxlbmd0aCAtIDFdKSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQSBydW5uYWJsZSB0aGF0IHJ1bnMgYSBtYXBwaW5nIG9mIHJ1bm5hYmxlcyBpbiBwYXJhbGxlbCxcbiAqIGFuZCByZXR1cm5zIGEgbWFwcGluZyBvZiB0aGVpciBvdXRwdXRzLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IG1hcENoYWluID0gUnVubmFibGVNYXAuZnJvbSh7XG4gKiAgIGpva2U6IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcIlRlbGwgbWUgYSBqb2tlIGFib3V0IHt0b3BpY31cIikucGlwZShcbiAqICAgICBuZXcgQ2hhdEFudGhyb3BpYyh7fSksXG4gKiAgICksXG4gKiAgIHBvZW06IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcIndyaXRlIGEgMi1saW5lIHBvZW0gYWJvdXQge3RvcGljfVwiKS5waXBlKFxuICogICAgIG5ldyBDaGF0QW50aHJvcGljKHt9KSxcbiAqICAgKSxcbiAqIH0pO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbWFwQ2hhaW4uaW52b2tlKHsgdG9waWM6IFwiYmVhclwiIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZU1hcCBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVNYXBcIjtcbiAgICB9XG4gICAgZ2V0U3RlcHNLZXlzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdGVwcyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0ZXBzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RlcHMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmllbGRzLnN0ZXBzKSkge1xuICAgICAgICAgICAgdGhpcy5zdGVwc1trZXldID0gX2NvZXJjZVRvUnVubmFibGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHN0ZXBzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVNYXAoeyBzdGVwcyB9KTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IGdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZyhjb25maWcpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCB7XG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgfSwgY29uZmlnLnJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWc/LnJ1bk5hbWUpO1xuICAgICAgICBkZWxldGUgY29uZmlnLnJ1bklkO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5lbnRyaWVzKHRoaXMuc3RlcHMpLm1hcChhc3luYyAoW2tleSwgcnVubmFibGVdKSA9PiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBhd2FpdCBydW5uYWJsZS5pbnZva2UoaW5wdXQsIHBhdGNoQ29uZmlnKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKGBtYXA6a2V5OiR7a2V5fWApLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQob3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oZ2VuZXJhdG9yLCBydW5NYW5hZ2VyLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIHNoYWxsb3cgY29weSBzdGVwcyB0byBpZ25vcmUgY2hhbmdlcyB3aGlsZSBpdGVyYXRpbmdcbiAgICAgICAgY29uc3Qgc3RlcHMgPSB7IC4uLnRoaXMuc3RlcHMgfTtcbiAgICAgICAgLy8gZWFjaCBzdGVwIGdldHMgYSBjb3B5IG9mIHRoZSBpbnB1dCBpdGVyYXRvclxuICAgICAgICBjb25zdCBpbnB1dENvcGllcyA9IGF0ZWUoZ2VuZXJhdG9yLCBPYmplY3Qua2V5cyhzdGVwcykubGVuZ3RoKTtcbiAgICAgICAgLy8gc3RhcnQgdGhlIGZpcnN0IGl0ZXJhdGlvbiBvZiBlYWNoIG91dHB1dCBpdGVyYXRvclxuICAgICAgICBjb25zdCB0YXNrcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoc3RlcHMpLm1hcCgoW2tleSwgcnVubmFibGVdLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnZW4gPSBydW5uYWJsZS50cmFuc2Zvcm0oaW5wdXRDb3BpZXNbaV0sIHBhdGNoQ29uZmlnKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKGBtYXA6a2V5OiR7a2V5fWApLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIFtrZXksIGdlbi5uZXh0KCkudGhlbigocmVzdWx0KSA9PiAoeyBrZXksIGdlbiwgcmVzdWx0IH0pKV07XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8geWllbGQgY2h1bmtzIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSxcbiAgICAgICAgLy8gc3RhcnRpbmcgbmV3IGl0ZXJhdGlvbnMgYXMgbmVlZGVkLFxuICAgICAgICAvLyB1bnRpbCBhbGwgaXRlcmF0b3JzIGFyZSBkb25lXG4gICAgICAgIHdoaWxlICh0YXNrcy5zaXplKSB7XG4gICAgICAgICAgICBjb25zdCB7IGtleSwgcmVzdWx0LCBnZW4gfSA9IGF3YWl0IFByb21pc2UucmFjZSh0YXNrcy52YWx1ZXMoKSk7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB7IFtrZXldOiByZXN1bHQudmFsdWUgfTtcbiAgICAgICAgICAgICAgICB0YXNrcy5zZXQoa2V5LCBnZW4ubmV4dCgpLnRoZW4oKHJlc3VsdCkgPT4gKHsga2V5LCBnZW4sIHJlc3VsdCB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW5zZm9ybShnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybVN0cmVhbVdpdGhDb25maWcoZ2VuZXJhdG9yLCB0aGlzLl90cmFuc2Zvcm0uYmluZCh0aGlzKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBhc3luYyBmdW5jdGlvbiogZ2VuZXJhdG9yKCkge1xuICAgICAgICAgICAgeWllbGQgaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JhcHBlZEdlbmVyYXRvciA9IG5ldyBBc3luY0dlbmVyYXRvcldpdGhTZXR1cCh0aGlzLnRyYW5zZm9ybShnZW5lcmF0b3IoKSwgb3B0aW9ucykpO1xuICAgICAgICBhd2FpdCB3cmFwcGVkR2VuZXJhdG9yLnNldHVwO1xuICAgICAgICByZXR1cm4gSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Iod3JhcHBlZEdlbmVyYXRvcik7XG4gICAgfVxufVxuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgcnVucyBhIGNhbGxhYmxlLlxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGVMYW1iZGEgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlTGFtYmRhXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmdW5jXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZnVuYyA9IGZpZWxkcy5mdW5jO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShmdW5jKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVMYW1iZGEoe1xuICAgICAgICAgICAgZnVuYyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9pbnZva2UoaW5wdXQsIGNvbmZpZywgcnVuTWFuYWdlcikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRDb25maWcgPSBwYXRjaENvbmZpZyhjb25maWcsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICAgICAgcmVjdXJzaW9uTGltaXQ6IChjb25maWc/LnJlY3Vyc2lvbkxpbWl0ID8/IERFRkFVTFRfUkVDVVJTSU9OX0xJTUlUKSAtIDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZvaWQgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5nZXRJbnN0YW5jZSgpLnJ1bihjaGlsZENvbmZpZywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBhd2FpdCB0aGlzLmZ1bmMoaW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjaGlsZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQgJiYgUnVubmFibGUuaXNSdW5uYWJsZShvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnPy5yZWN1cnNpb25MaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY3Vyc2lvbiBsaW1pdCByZWFjaGVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGF3YWl0IG91dHB1dC5pbnZva2UoaW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jaGlsZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN1cnNpb25MaW1pdDogKGNoaWxkQ29uZmlnLnJlY3Vyc2lvbkxpbWl0ID8/IERFRkFVTFRfUkVDVVJTSU9OX0xJTUlUKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FzeW5jSXRlcmFibGUob3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBjb25zdW1lQXN5bmNJdGVyYWJsZUluQ29udGV4dChjaGlsZENvbmZpZywgb3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIGEgYmVzdCBlZmZvcnQgdG8gZ2F0aGVyLCBmb3IgYW55IHR5cGUgdGhhdCBzdXBwb3J0cyBjb25jYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjb25jYXQoZmluYWxPdXRwdXQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGZpbmFsT3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSXRlcmF0b3Iob3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBjb25zdW1lSXRlcmF0b3JJbkNvbnRleHQoY2hpbGRDb25maWcsIG91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBhIGJlc3QgZWZmb3J0IHRvIGdhdGhlciwgZm9yIGFueSB0eXBlIHRoYXQgc3VwcG9ydHMgY29uY2F0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY29uY2F0KGZpbmFsT3V0cHV0LCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBmaW5hbE91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5faW52b2tlLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jICpfdHJhbnNmb3JtKGdlbmVyYXRvciwgcnVuTWFuYWdlciwgY29uZmlnKSB7XG4gICAgICAgIGxldCBmaW5hbENodW5rO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGdlbmVyYXRvcikge1xuICAgICAgICAgICAgaWYgKGZpbmFsQ2h1bmsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmsgPSBjaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1ha2UgYSBiZXN0IGVmZm9ydCB0byBnYXRoZXIsIGZvciBhbnkgdHlwZSB0aGF0IHN1cHBvcnRzIGNvbmNhdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICBmaW5hbENodW5rID0gY29uY2F0KGZpbmFsQ2h1bmssIGNodW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxDaHVuayA9IGNodW5rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB2b2lkIEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0SW5zdGFuY2UoKS5ydW4oY29uZmlnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5mdW5jKGZpbmFsQ2h1bmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dHB1dCAmJiBSdW5uYWJsZS5pc1J1bm5hYmxlKG91dHB1dCkpIHtcbiAgICAgICAgICAgIGlmIChjb25maWc/LnJlY3Vyc2lvbkxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjdXJzaW9uIGxpbWl0IHJlYWNoZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgb3V0cHV0LnN0cmVhbShmaW5hbENodW5rLCBwYXRjaENvbmZpZyhjb25maWcsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICAgICAgcmVjdXJzaW9uTGltaXQ6IChjb25maWc/LnJlY3Vyc2lvbkxpbWl0ID8/IERFRkFVTFRfUkVDVVJTSU9OX0xJTUlUKSAtIDEsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQXN5bmNJdGVyYWJsZShvdXRwdXQpKSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNvbnN1bWVBc3luY0l0ZXJhYmxlSW5Db250ZXh0KGNvbmZpZywgb3V0cHV0KSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzSXRlcmF0b3Iob3V0cHV0KSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBjb25zdW1lSXRlcmF0b3JJbkNvbnRleHQoY29uZmlnLCBvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhnZW5lcmF0b3IsIHRoaXMuX3RyYW5zZm9ybS5iaW5kKHRoaXMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBnZW5lcmF0b3IoKSB7XG4gICAgICAgICAgICB5aWVsZCBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cmFwcGVkR2VuZXJhdG9yID0gbmV3IEFzeW5jR2VuZXJhdG9yV2l0aFNldHVwKHRoaXMudHJhbnNmb3JtKGdlbmVyYXRvcigpLCBvcHRpb25zKSk7XG4gICAgICAgIGF3YWl0IHdyYXBwZWRHZW5lcmF0b3Iuc2V0dXA7XG4gICAgICAgIHJldHVybiBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcih3cmFwcGVkR2VuZXJhdG9yKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUnVubmFibGVQYXJhbGxlbCBleHRlbmRzIFJ1bm5hYmxlTWFwIHtcbn1cbi8qKlxuICogQSBSdW5uYWJsZSB0aGF0IGNhbiBmYWxsYmFjayB0byBvdGhlciBSdW5uYWJsZXMgaWYgaXQgZmFpbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZVdpdGhGYWxsYmFja3MgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlV2l0aEZhbGxiYWNrc1wiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5uYWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmYWxsYmFja3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ydW5uYWJsZSA9IGZpZWxkcy5ydW5uYWJsZTtcbiAgICAgICAgdGhpcy5mYWxsYmFja3MgPSBmaWVsZHMuZmFsbGJhY2tzO1xuICAgIH1cbiAgICAqcnVubmFibGVzKCkge1xuICAgICAgICB5aWVsZCB0aGlzLnJ1bm5hYmxlO1xuICAgICAgICBmb3IgKGNvbnN0IGZhbGxiYWNrIG9mIHRoaXMuZmFsbGJhY2tzKSB7XG4gICAgICAgICAgICB5aWVsZCBmYWxsYmFjaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IENhbGxiYWNrTWFuYWdlci5jb25maWd1cmUob3B0aW9ucz8uY2FsbGJhY2tzLCB1bmRlZmluZWQsIG9wdGlvbnM/LnRhZ3MsIHVuZGVmaW5lZCwgb3B0aW9ucz8ubWV0YWRhdGEpO1xuICAgICAgICBjb25zdCB7IHJ1bklkLCAuLi5vdGhlck9wdGlvbnMgfSA9IG9wdGlvbnMgPz8ge307XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXQsIFwiaW5wdXRcIiksIHJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvdGhlck9wdGlvbnM/LnJ1bk5hbWUpO1xuICAgICAgICBsZXQgZmlyc3RFcnJvcjtcbiAgICAgICAgZm9yIChjb25zdCBydW5uYWJsZSBvZiB0aGlzLnJ1bm5hYmxlcygpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJ1bm5hYmxlLmludm9rZShpbnB1dCwgcGF0Y2hDb25maWcob3RoZXJPcHRpb25zLCB7IGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSB9KSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChvdXRwdXQsIFwib3V0cHV0XCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RFcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3RFcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBlcnJvciBzdG9yZWQgYXQgZW5kIG9mIGZhbGxiYWNrLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGZpcnN0RXJyb3IpO1xuICAgICAgICB0aHJvdyBmaXJzdEVycm9yO1xuICAgIH1cbiAgICBhc3luYyBiYXRjaChpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICBpZiAoYmF0Y2hPcHRpb25zPy5yZXR1cm5FeGNlcHRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZ0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKGNvbmZpZ0xpc3QubWFwKChjb25maWcpID0+IENhbGxiYWNrTWFuYWdlci5jb25maWd1cmUoY29uZmlnPy5jYWxsYmFja3MsIHVuZGVmaW5lZCwgY29uZmlnPy50YWdzLCB1bmRlZmluZWQsIGNvbmZpZz8ubWV0YWRhdGEpKSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY2FsbGJhY2tNYW5hZ2Vycy5tYXAoYXN5bmMgKGNhbGxiYWNrTWFuYWdlciwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlU3RhcnRSZXMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXI/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dHNbaV0sIFwiaW5wdXRcIiksIGNvbmZpZ0xpc3RbaV0ucnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZ0xpc3RbaV0ucnVuTmFtZSk7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnTGlzdFtpXS5ydW5JZDtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdGFydFJlcztcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgZmlyc3RFcnJvcjtcbiAgICAgICAgZm9yIChjb25zdCBydW5uYWJsZSBvZiB0aGlzLnJ1bm5hYmxlcygpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dHMgPSBhd2FpdCBydW5uYWJsZS5iYXRjaChpbnB1dHMsIHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlciwgaikgPT4gcGF0Y2hDb25maWcoY29uZmlnTGlzdFtqXSwge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICAgICAgfSkpLCBiYXRjaE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlciwgaSkgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChvdXRwdXRzW2ldLCBcIm91dHB1dFwiKSkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEVycm9yID0gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmaXJzdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBlcnJvciBzdG9yZWQgYXQgZW5kIG9mIGZhbGxiYWNrcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGZpcnN0RXJyb3IpKSk7XG4gICAgICAgIHRocm93IGZpcnN0RXJyb3I7XG4gICAgfVxufVxuLy8gVE9ETzogRmlndXJlIG91dCB3aHkgdGhlIGNvbXBpbGVyIG5lZWRzIGhlbHAgZWxpbWluYXRpbmcgRXJyb3IgYXMgYSBSdW5PdXRwdXQgdHlwZVxuZXhwb3J0IGZ1bmN0aW9uIF9jb2VyY2VUb1J1bm5hYmxlKGNvZXJjZWFibGUpIHtcbiAgICBpZiAodHlwZW9mIGNvZXJjZWFibGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlTGFtYmRhKHsgZnVuYzogY29lcmNlYWJsZSB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoUnVubmFibGUuaXNSdW5uYWJsZShjb2VyY2VhYmxlKSkge1xuICAgICAgICByZXR1cm4gY29lcmNlYWJsZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoY29lcmNlYWJsZSkgJiYgdHlwZW9mIGNvZXJjZWFibGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcnVubmFibGVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGNvZXJjZWFibGUpKSB7XG4gICAgICAgICAgICBydW5uYWJsZXNba2V5XSA9IF9jb2VyY2VUb1J1bm5hYmxlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlTWFwKHtcbiAgICAgICAgICAgIHN0ZXBzOiBydW5uYWJsZXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIFJ1bm5hYmxlLCBmdW5jdGlvbiBvciBvYmplY3QuXFxuSW5zdGVhZCBnb3QgYW4gdW5zdXBwb3J0ZWQgdHlwZS5gKTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCBhc3NpZ25zIGtleS12YWx1ZSBwYWlycyB0byBpbnB1dHMgb2YgdHlwZSBgUmVjb3JkPHN0cmluZywgdW5rbm93bj5gLlxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGVBc3NpZ24gZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlQXNzaWduXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgIGlmIChmaWVsZHMgaW5zdGFuY2VvZiBSdW5uYWJsZU1hcCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMgPSB7IG1hcHBlcjogZmllbGRzIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXBwZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXBwZXIgPSBmaWVsZHMubWFwcGVyO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWFwcGVyUmVzdWx0ID0gYXdhaXQgdGhpcy5tYXBwZXIuaW52b2tlKGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmlucHV0LFxuICAgICAgICAgICAgLi4ubWFwcGVyUmVzdWx0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyAqX3RyYW5zZm9ybShnZW5lcmF0b3IsIHJ1bk1hbmFnZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gY29sbGVjdCBtYXBwZXIga2V5c1xuICAgICAgICBjb25zdCBtYXBwZXJLZXlzID0gdGhpcy5tYXBwZXIuZ2V0U3RlcHNLZXlzKCk7XG4gICAgICAgIC8vIGNyZWF0ZSB0d28gaW5wdXQgZ2Vucywgb25lIGZvciB0aGUgbWFwcGVyLCBvbmUgZm9yIHRoZSBpbnB1dFxuICAgICAgICBjb25zdCBbZm9yUGFzc3Rocm91Z2gsIGZvck1hcHBlcl0gPSBhdGVlKGdlbmVyYXRvcik7XG4gICAgICAgIC8vIGNyZWF0ZSBtYXBwZXIgb3V0cHV0IGdlblxuICAgICAgICBjb25zdCBtYXBwZXJPdXRwdXQgPSB0aGlzLm1hcHBlci50cmFuc2Zvcm0oZm9yTWFwcGVyLCBwYXRjaENvbmZpZyhvcHRpb25zLCB7IGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSB9KSk7XG4gICAgICAgIC8vIHN0YXJ0IHRoZSBtYXBwZXJcbiAgICAgICAgY29uc3QgZmlyc3RNYXBwZXJDaHVua1Byb21pc2UgPSBtYXBwZXJPdXRwdXQubmV4dCgpO1xuICAgICAgICAvLyB5aWVsZCB0aGUgcGFzc3Rocm91Z2hcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBmb3JQYXNzdGhyb3VnaCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGNodW5rKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUnVubmFibGVBc3NpZ24gY2FuIG9ubHkgYmUgdXNlZCB3aXRoIG9iamVjdHMgYXMgaW5wdXQsIGdvdCAke3R5cGVvZiBjaHVua31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGNodW5rKS5maWx0ZXIoKFtrZXldKSA9PiAhbWFwcGVyS2V5cy5pbmNsdWRlcyhrZXkpKSk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoZmlsdGVyZWQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBmaWx0ZXJlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB5aWVsZCB0aGUgbWFwcGVyIG91dHB1dFxuICAgICAgICB5aWVsZCAoYXdhaXQgZmlyc3RNYXBwZXJDaHVua1Byb21pc2UpLnZhbHVlO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIG1hcHBlck91dHB1dCkge1xuICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhnZW5lcmF0b3IsIHRoaXMuX3RyYW5zZm9ybS5iaW5kKHRoaXMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBnZW5lcmF0b3IoKSB7XG4gICAgICAgICAgICB5aWVsZCBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cmFwcGVkR2VuZXJhdG9yID0gbmV3IEFzeW5jR2VuZXJhdG9yV2l0aFNldHVwKHRoaXMudHJhbnNmb3JtKGdlbmVyYXRvcigpLCBvcHRpb25zKSk7XG4gICAgICAgIGF3YWl0IHdyYXBwZWRHZW5lcmF0b3Iuc2V0dXA7XG4gICAgICAgIHJldHVybiBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcih3cmFwcGVkR2VuZXJhdG9yKTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCBhc3NpZ25zIGtleS12YWx1ZSBwYWlycyB0byBpbnB1dHMgb2YgdHlwZSBgUmVjb3JkPHN0cmluZywgdW5rbm93bj5gLlxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGVQaWNrIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZVBpY2tcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoZmllbGRzKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMgPSB7IGtleXM6IGZpZWxkcyB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmtleXMgPSBmaWVsZHMua2V5cztcbiAgICB9XG4gICAgYXN5bmMgX3BpY2soaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmtleXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dFt0aGlzLmtleXNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGlja2VkID0gdGhpcy5rZXlzXG4gICAgICAgICAgICAgICAgLm1hcCgoa2V5KSA9PiBba2V5LCBpbnB1dFtrZXldXSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh2KSA9PiB2WzFdICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHBpY2tlZC5sZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiBPYmplY3QuZnJvbUVudHJpZXMocGlja2VkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKHRoaXMuX3BpY2suYmluZCh0aGlzKSwgaW5wdXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyAqX3RyYW5zZm9ybShnZW5lcmF0b3IpIHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHBpY2tlZCA9IGF3YWl0IHRoaXMuX3BpY2soY2h1bmspO1xuICAgICAgICAgICAgaWYgKHBpY2tlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgcGlja2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW5zZm9ybShnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybVN0cmVhbVdpdGhDb25maWcoZ2VuZXJhdG9yLCB0aGlzLl90cmFuc2Zvcm0uYmluZCh0aGlzKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBhc3luYyBmdW5jdGlvbiogZ2VuZXJhdG9yKCkge1xuICAgICAgICAgICAgeWllbGQgaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JhcHBlZEdlbmVyYXRvciA9IG5ldyBBc3luY0dlbmVyYXRvcldpdGhTZXR1cCh0aGlzLnRyYW5zZm9ybShnZW5lcmF0b3IoKSwgb3B0aW9ucykpO1xuICAgICAgICBhd2FpdCB3cmFwcGVkR2VuZXJhdG9yLnNldHVwO1xuICAgICAgICByZXR1cm4gSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Iod3JhcHBlZEdlbmVyYXRvcik7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/runnables/base.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/runnables/config.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/config.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_RECURSION_LIMIT: () => (/* binding */ DEFAULT_RECURSION_LIMIT),\n/* harmony export */   ensureConfig: () => (/* binding */ ensureConfig),\n/* harmony export */   getCallbackManagerForConfig: () => (/* binding */ getCallbackManagerForConfig),\n/* harmony export */   mergeConfigs: () => (/* binding */ mergeConfigs),\n/* harmony export */   patchConfig: () => (/* binding */ patchConfig)\n/* harmony export */ });\n/* harmony import */ var _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../callbacks/manager.js */ \"(action-browser)/./node_modules/@langchain/core/dist/callbacks/manager.js\");\n/* harmony import */ var _singletons_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../singletons/index.js */ \"(action-browser)/./node_modules/@langchain/core/dist/singletons/index.js\");\n\n\nconst DEFAULT_RECURSION_LIMIT = 25;\nasync function getCallbackManagerForConfig(config) {\n    return _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n}\nfunction mergeConfigs(...configs) {\n    // We do not want to call ensureConfig on the empty state here as this may cause\n    // double loading of callbacks if async local storage is being used.\n    const copy = {};\n    for (const options of configs.filter((c) => !!c)) {\n        for (const key of Object.keys(options)) {\n            if (key === \"metadata\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"tags\") {\n                const baseKeys = copy[key] ?? [];\n                copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];\n            }\n            else if (key === \"configurable\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"callbacks\") {\n                const baseCallbacks = copy.callbacks;\n                const providedCallbacks = options.callbacks;\n                // callbacks can be either undefined, Array<handler> or manager\n                // so merging two callbacks values has 6 cases\n                if (Array.isArray(providedCallbacks)) {\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        copy.callbacks = baseCallbacks.concat(providedCallbacks);\n                    }\n                    else {\n                        // baseCallbacks is a manager\n                        const manager = baseCallbacks.copy();\n                        for (const callback of providedCallbacks) {\n                            manager.addHandler((0,_callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.ensureHandler)(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                }\n                else if (providedCallbacks) {\n                    // providedCallbacks is a manager\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        const manager = providedCallbacks.copy();\n                        for (const callback of baseCallbacks) {\n                            manager.addHandler((0,_callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.ensureHandler)(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                    else {\n                        // baseCallbacks is also a manager\n                        copy.callbacks = new _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.CallbackManager(providedCallbacks._parentRunId, {\n                            handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),\n                            inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),\n                            tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),\n                            inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),\n                            metadata: {\n                                ...baseCallbacks.metadata,\n                                ...providedCallbacks.metadata,\n                            },\n                        });\n                    }\n                }\n            }\n            else {\n                const typedKey = key;\n                copy[typedKey] = options[typedKey] ?? copy[typedKey];\n            }\n        }\n    }\n    return copy;\n}\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n/**\n * Ensure that a passed config is an object with all required keys present.\n *\n * Note: To make sure async local storage loading works correctly, this\n * should not be called with a default or prepopulated config argument.\n */\nfunction ensureConfig(config) {\n    const loadedConfig = config ?? _singletons_index_js__WEBPACK_IMPORTED_MODULE_1__.AsyncLocalStorageProviderSingleton.getInstance().getStore();\n    let empty = {\n        tags: [],\n        metadata: {},\n        callbacks: undefined,\n        recursionLimit: 25,\n        runId: undefined,\n    };\n    if (loadedConfig) {\n        empty = { ...empty, ...loadedConfig };\n    }\n    if (loadedConfig?.configurable) {\n        for (const key of Object.keys(loadedConfig.configurable)) {\n            if (PRIMITIVES.has(typeof loadedConfig.configurable[key]) &&\n                !empty.metadata?.[key]) {\n                if (!empty.metadata) {\n                    empty.metadata = {};\n                }\n                empty.metadata[key] = loadedConfig.configurable[key];\n            }\n        }\n    }\n    return empty;\n}\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nfunction patchConfig(config = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, runId, } = {}) {\n    const newConfig = ensureConfig(config);\n    if (callbacks !== undefined) {\n        /**\n         * If we're replacing callbacks we need to unset runName\n         * since that should apply only to the same run as the original callbacks\n         */\n        delete newConfig.runName;\n        newConfig.callbacks = callbacks;\n    }\n    if (recursionLimit !== undefined) {\n        newConfig.recursionLimit = recursionLimit;\n    }\n    if (maxConcurrency !== undefined) {\n        newConfig.maxConcurrency = maxConcurrency;\n    }\n    if (runName !== undefined) {\n        newConfig.runName = runName;\n    }\n    if (configurable !== undefined) {\n        newConfig.configurable = { ...newConfig.configurable, ...configurable };\n    }\n    if (runId !== undefined) {\n        delete newConfig.runId;\n    }\n    return newConfig;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvY29uZmlnLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEU7QUFDRTtBQUNyRTtBQUNBO0FBQ1AsV0FBVyxrRUFBZTtBQUMxQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG9FQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvRUFBYTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtFQUFlO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG1DQUFtQyxvRkFBa0M7QUFDckU7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0MsSUFBSSwyRUFBMkUsSUFBSTtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxydW5uYWJsZXNcXGNvbmZpZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDYWxsYmFja01hbmFnZXIsIGVuc3VyZUhhbmRsZXIsIH0gZnJvbSBcIi4uL2NhbGxiYWNrcy9tYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uIH0gZnJvbSBcIi4uL3NpbmdsZXRvbnMvaW5kZXguanNcIjtcbmV4cG9ydCBjb25zdCBERUZBVUxUX1JFQ1VSU0lPTl9MSU1JVCA9IDI1O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZyhjb25maWcpIHtcbiAgICByZXR1cm4gQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShjb25maWc/LmNhbGxiYWNrcywgdW5kZWZpbmVkLCBjb25maWc/LnRhZ3MsIHVuZGVmaW5lZCwgY29uZmlnPy5tZXRhZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VDb25maWdzKC4uLmNvbmZpZ3MpIHtcbiAgICAvLyBXZSBkbyBub3Qgd2FudCB0byBjYWxsIGVuc3VyZUNvbmZpZyBvbiB0aGUgZW1wdHkgc3RhdGUgaGVyZSBhcyB0aGlzIG1heSBjYXVzZVxuICAgIC8vIGRvdWJsZSBsb2FkaW5nIG9mIGNhbGxiYWNrcyBpZiBhc3luYyBsb2NhbCBzdG9yYWdlIGlzIGJlaW5nIHVzZWQuXG4gICAgY29uc3QgY29weSA9IHt9O1xuICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBjb25maWdzLmZpbHRlcigoYykgPT4gISFjKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvcHRpb25zKSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJtZXRhZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgY29weVtrZXldID0geyAuLi5jb3B5W2tleV0sIC4uLm9wdGlvbnNba2V5XSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcInRhZ3NcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VLZXlzID0gY29weVtrZXldID8/IFtdO1xuICAgICAgICAgICAgICAgIGNvcHlba2V5XSA9IFsuLi5uZXcgU2V0KGJhc2VLZXlzLmNvbmNhdChvcHRpb25zW2tleV0gPz8gW10pKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiY29uZmlndXJhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSB7IC4uLmNvcHlba2V5XSwgLi4ub3B0aW9uc1trZXldIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiY2FsbGJhY2tzXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlQ2FsbGJhY2tzID0gY29weS5jYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZWRDYWxsYmFja3MgPSBvcHRpb25zLmNhbGxiYWNrcztcbiAgICAgICAgICAgICAgICAvLyBjYWxsYmFja3MgY2FuIGJlIGVpdGhlciB1bmRlZmluZWQsIEFycmF5PGhhbmRsZXI+IG9yIG1hbmFnZXJcbiAgICAgICAgICAgICAgICAvLyBzbyBtZXJnaW5nIHR3byBjYWxsYmFja3MgdmFsdWVzIGhhcyA2IGNhc2VzXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvdmlkZWRDYWxsYmFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmFzZUNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBwcm92aWRlZENhbGxiYWNrcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJhc2VDYWxsYmFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LmNhbGxiYWNrcyA9IGJhc2VDYWxsYmFja3MuY29uY2F0KHByb3ZpZGVkQ2FsbGJhY2tzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhc2VDYWxsYmFja3MgaXMgYSBtYW5hZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYW5hZ2VyID0gYmFzZUNhbGxiYWNrcy5jb3B5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHByb3ZpZGVkQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKGVuc3VyZUhhbmRsZXIoY2FsbGJhY2spLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuY2FsbGJhY2tzID0gbWFuYWdlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlZENhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm92aWRlZENhbGxiYWNrcyBpcyBhIG1hbmFnZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiYXNlQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LmNhbGxiYWNrcyA9IHByb3ZpZGVkQ2FsbGJhY2tzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYmFzZUNhbGxiYWNrcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hbmFnZXIgPSBwcm92aWRlZENhbGxiYWNrcy5jb3B5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGJhc2VDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLmFkZEhhbmRsZXIoZW5zdXJlSGFuZGxlcihjYWxsYmFjayksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBtYW5hZ2VyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFzZUNhbGxiYWNrcyBpcyBhbHNvIGEgbWFuYWdlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHByb3ZpZGVkQ2FsbGJhY2tzLl9wYXJlbnRSdW5JZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzOiBiYXNlQ2FsbGJhY2tzLmhhbmRsZXJzLmNvbmNhdChwcm92aWRlZENhbGxiYWNrcy5oYW5kbGVycyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdGFibGVIYW5kbGVyczogYmFzZUNhbGxiYWNrcy5pbmhlcml0YWJsZUhhbmRsZXJzLmNvbmNhdChwcm92aWRlZENhbGxiYWNrcy5pbmhlcml0YWJsZUhhbmRsZXJzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzOiBBcnJheS5mcm9tKG5ldyBTZXQoYmFzZUNhbGxiYWNrcy50YWdzLmNvbmNhdChwcm92aWRlZENhbGxiYWNrcy50YWdzKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaGVyaXRhYmxlVGFnczogQXJyYXkuZnJvbShuZXcgU2V0KGJhc2VDYWxsYmFja3MuaW5oZXJpdGFibGVUYWdzLmNvbmNhdChwcm92aWRlZENhbGxiYWNrcy5pbmhlcml0YWJsZVRhZ3MpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYmFzZUNhbGxiYWNrcy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucHJvdmlkZWRDYWxsYmFja3MubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRLZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgY29weVt0eXBlZEtleV0gPSBvcHRpb25zW3R5cGVkS2V5XSA/PyBjb3B5W3R5cGVkS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn1cbmNvbnN0IFBSSU1JVElWRVMgPSBuZXcgU2V0KFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl0pO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHBhc3NlZCBjb25maWcgaXMgYW4gb2JqZWN0IHdpdGggYWxsIHJlcXVpcmVkIGtleXMgcHJlc2VudC5cbiAqXG4gKiBOb3RlOiBUbyBtYWtlIHN1cmUgYXN5bmMgbG9jYWwgc3RvcmFnZSBsb2FkaW5nIHdvcmtzIGNvcnJlY3RseSwgdGhpc1xuICogc2hvdWxkIG5vdCBiZSBjYWxsZWQgd2l0aCBhIGRlZmF1bHQgb3IgcHJlcG9wdWxhdGVkIGNvbmZpZyBhcmd1bWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25zdCBsb2FkZWRDb25maWcgPSBjb25maWcgPz8gQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5nZXRJbnN0YW5jZSgpLmdldFN0b3JlKCk7XG4gICAgbGV0IGVtcHR5ID0ge1xuICAgICAgICB0YWdzOiBbXSxcbiAgICAgICAgbWV0YWRhdGE6IHt9LFxuICAgICAgICBjYWxsYmFja3M6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVjdXJzaW9uTGltaXQ6IDI1LFxuICAgICAgICBydW5JZDogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgaWYgKGxvYWRlZENvbmZpZykge1xuICAgICAgICBlbXB0eSA9IHsgLi4uZW1wdHksIC4uLmxvYWRlZENvbmZpZyB9O1xuICAgIH1cbiAgICBpZiAobG9hZGVkQ29uZmlnPy5jb25maWd1cmFibGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobG9hZGVkQ29uZmlnLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgIGlmIChQUklNSVRJVkVTLmhhcyh0eXBlb2YgbG9hZGVkQ29uZmlnLmNvbmZpZ3VyYWJsZVtrZXldKSAmJlxuICAgICAgICAgICAgICAgICFlbXB0eS5tZXRhZGF0YT8uW2tleV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtcHR5Lm1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtcHR5Lm1ldGFkYXRhID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtcHR5Lm1ldGFkYXRhW2tleV0gPSBsb2FkZWRDb25maWcuY29uZmlndXJhYmxlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5O1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBwYXRjaGVzIHJ1bm5hYmxlIGNvbmZpZ3Mgd2l0aCB1cGRhdGVkIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXRjaENvbmZpZyhjb25maWcgPSB7fSwgeyBjYWxsYmFja3MsIG1heENvbmN1cnJlbmN5LCByZWN1cnNpb25MaW1pdCwgcnVuTmFtZSwgY29uZmlndXJhYmxlLCBydW5JZCwgfSA9IHt9KSB7XG4gICAgY29uc3QgbmV3Q29uZmlnID0gZW5zdXJlQ29uZmlnKGNvbmZpZyk7XG4gICAgaWYgKGNhbGxiYWNrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSByZXBsYWNpbmcgY2FsbGJhY2tzIHdlIG5lZWQgdG8gdW5zZXQgcnVuTmFtZVxuICAgICAgICAgKiBzaW5jZSB0aGF0IHNob3VsZCBhcHBseSBvbmx5IHRvIHRoZSBzYW1lIHJ1biBhcyB0aGUgb3JpZ2luYWwgY2FsbGJhY2tzXG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGUgbmV3Q29uZmlnLnJ1bk5hbWU7XG4gICAgICAgIG5ld0NvbmZpZy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgfVxuICAgIGlmIChyZWN1cnNpb25MaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld0NvbmZpZy5yZWN1cnNpb25MaW1pdCA9IHJlY3Vyc2lvbkxpbWl0O1xuICAgIH1cbiAgICBpZiAobWF4Q29uY3VycmVuY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdDb25maWcubWF4Q29uY3VycmVuY3kgPSBtYXhDb25jdXJyZW5jeTtcbiAgICB9XG4gICAgaWYgKHJ1bk5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdDb25maWcucnVuTmFtZSA9IHJ1bk5hbWU7XG4gICAgfVxuICAgIGlmIChjb25maWd1cmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdDb25maWcuY29uZmlndXJhYmxlID0geyAuLi5uZXdDb25maWcuY29uZmlndXJhYmxlLCAuLi5jb25maWd1cmFibGUgfTtcbiAgICB9XG4gICAgaWYgKHJ1bklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIG5ld0NvbmZpZy5ydW5JZDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0NvbmZpZztcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/runnables/config.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/runnables/graph.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/graph.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Graph: () => (/* binding */ Graph),\n/* harmony export */   nodeDataStr: () => (/* binding */ nodeDataStr)\n/* harmony export */ });\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod-to-json-schema */ \"(action-browser)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@langchain/core/dist/runnables/utils.js\");\n\n\n\nconst MAX_DATA_DISPLAY_NAME_LENGTH = 42;\nfunction nodeDataStr(node) {\n    if (!(0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node.id)) {\n        return node.id;\n    }\n    else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isRunnableInterface)(node.data)) {\n        try {\n            let data = node.data.toString();\n            if (data.startsWith(\"<\") ||\n                data[0] !== data[0].toUpperCase() ||\n                data.split(\"\\n\").length > 1) {\n                data = node.data.getName();\n            }\n            else if (data.length > MAX_DATA_DISPLAY_NAME_LENGTH) {\n                data = `${data.substring(0, MAX_DATA_DISPLAY_NAME_LENGTH)}...`;\n            }\n            return data.startsWith(\"Runnable\") ? data.slice(\"Runnable\".length) : data;\n        }\n        catch (error) {\n            return node.data.getName();\n        }\n    }\n    else {\n        return node.data.name ?? \"UnknownSchema\";\n    }\n}\nfunction nodeDataJson(node) {\n    // if node.data is implements Runnable\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isRunnableInterface)(node.data)) {\n        return {\n            type: \"runnable\",\n            data: {\n                id: node.data.lc_id,\n                name: node.data.getName(),\n            },\n        };\n    }\n    else {\n        return {\n            type: \"schema\",\n            data: { ...(0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__.zodToJsonSchema)(node.data.schema), title: node.data.name },\n        };\n    }\n}\nclass Graph {\n    constructor() {\n        Object.defineProperty(this, \"nodes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"edges\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    // Convert the graph to a JSON-serializable format.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    toJSON() {\n        const stableNodeIds = {};\n        Object.values(this.nodes).forEach((node, i) => {\n            stableNodeIds[node.id] = (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node.id) ? i : node.id;\n        });\n        return {\n            nodes: Object.values(this.nodes).map((node) => ({\n                id: stableNodeIds[node.id],\n                ...nodeDataJson(node),\n            })),\n            edges: this.edges.map((edge) => edge.data\n                ? {\n                    source: stableNodeIds[edge.source],\n                    target: stableNodeIds[edge.target],\n                    data: edge.data,\n                }\n                : {\n                    source: stableNodeIds[edge.source],\n                    target: stableNodeIds[edge.target],\n                }),\n        };\n    }\n    addNode(data, id) {\n        if (id !== undefined && this.nodes[id] !== undefined) {\n            throw new Error(`Node with id ${id} already exists`);\n        }\n        const nodeId = id || (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n        const node = { id: nodeId, data };\n        this.nodes[nodeId] = node;\n        return node;\n    }\n    removeNode(node) {\n        // Remove the node from the nodes map\n        delete this.nodes[node.id];\n        // Filter out edges connected to the node\n        this.edges = this.edges.filter((edge) => edge.source !== node.id && edge.target !== node.id);\n    }\n    addEdge(source, target, data) {\n        if (this.nodes[source.id] === undefined) {\n            throw new Error(`Source node ${source.id} not in graph`);\n        }\n        if (this.nodes[target.id] === undefined) {\n            throw new Error(`Target node ${target.id} not in graph`);\n        }\n        const edge = { source: source.id, target: target.id, data };\n        this.edges.push(edge);\n        return edge;\n    }\n    firstNode() {\n        const targets = new Set(this.edges.map((edge) => edge.target));\n        const found = [];\n        Object.values(this.nodes).forEach((node) => {\n            if (!targets.has(node.id)) {\n                found.push(node);\n            }\n        });\n        return found[0];\n    }\n    lastNode() {\n        const sources = new Set(this.edges.map((edge) => edge.source));\n        const found = [];\n        Object.values(this.nodes).forEach((node) => {\n            if (!sources.has(node.id)) {\n                found.push(node);\n            }\n        });\n        return found[0];\n    }\n    extend(graph) {\n        // Add all nodes from the other graph, taking care to avoid duplicates\n        Object.entries(graph.nodes).forEach(([key, value]) => {\n            this.nodes[key] = value;\n        });\n        // Add all edges from the other graph\n        this.edges = [...this.edges, ...graph.edges];\n    }\n    trimFirstNode() {\n        const firstNode = this.firstNode();\n        if (firstNode) {\n            const outgoingEdges = this.edges.filter((edge) => edge.source === firstNode.id);\n            if (Object.keys(this.nodes).length === 1 || outgoingEdges.length === 1) {\n                this.removeNode(firstNode);\n            }\n        }\n    }\n    trimLastNode() {\n        const lastNode = this.lastNode();\n        if (lastNode) {\n            const incomingEdges = this.edges.filter((edge) => edge.target === lastNode.id);\n            if (Object.keys(this.nodes).length === 1 || incomingEdges.length === 1) {\n                this.removeNode(lastNode);\n            }\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvZ3JhcGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXFEO0FBQ0c7QUFDUDtBQUNqRDtBQUNPO0FBQ1AsU0FBUyxnREFBTTtBQUNmO0FBQ0E7QUFDQSxhQUFhLDhEQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdEQUFnRDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixHQUFHLG1FQUFlLDJDQUEyQztBQUNqRjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnREFBTTtBQUMzQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLElBQUk7QUFDaEQ7QUFDQSw2QkFBNkIsZ0RBQU07QUFDbkMsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHJ1bm5hYmxlc1xcZ3JhcGguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgem9kVG9Kc29uU2NoZW1hIH0gZnJvbSBcInpvZC10by1qc29uLXNjaGVtYVwiO1xuaW1wb3J0IHsgdjQgYXMgdXVpZHY0LCB2YWxpZGF0ZSBhcyBpc1V1aWQgfSBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgaXNSdW5uYWJsZUludGVyZmFjZSB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5jb25zdCBNQVhfREFUQV9ESVNQTEFZX05BTUVfTEVOR1RIID0gNDI7XG5leHBvcnQgZnVuY3Rpb24gbm9kZURhdGFTdHIobm9kZSkge1xuICAgIGlmICghaXNVdWlkKG5vZGUuaWQpKSB7XG4gICAgICAgIHJldHVybiBub2RlLmlkO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1J1bm5hYmxlSW50ZXJmYWNlKG5vZGUuZGF0YSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gbm9kZS5kYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoZGF0YS5zdGFydHNXaXRoKFwiPFwiKSB8fFxuICAgICAgICAgICAgICAgIGRhdGFbMF0gIT09IGRhdGFbMF0udG9VcHBlckNhc2UoKSB8fFxuICAgICAgICAgICAgICAgIGRhdGEuc3BsaXQoXCJcXG5cIikubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBub2RlLmRhdGEuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS5sZW5ndGggPiBNQVhfREFUQV9ESVNQTEFZX05BTUVfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGAke2RhdGEuc3Vic3RyaW5nKDAsIE1BWF9EQVRBX0RJU1BMQVlfTkFNRV9MRU5HVEgpfS4uLmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5zdGFydHNXaXRoKFwiUnVubmFibGVcIikgPyBkYXRhLnNsaWNlKFwiUnVubmFibGVcIi5sZW5ndGgpIDogZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmRhdGEuZ2V0TmFtZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9kZS5kYXRhLm5hbWUgPz8gXCJVbmtub3duU2NoZW1hXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9kZURhdGFKc29uKG5vZGUpIHtcbiAgICAvLyBpZiBub2RlLmRhdGEgaXMgaW1wbGVtZW50cyBSdW5uYWJsZVxuICAgIGlmIChpc1J1bm5hYmxlSW50ZXJmYWNlKG5vZGUuZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwicnVubmFibGVcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBpZDogbm9kZS5kYXRhLmxjX2lkLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5vZGUuZGF0YS5nZXROYW1lKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwic2NoZW1hXCIsXG4gICAgICAgICAgICBkYXRhOiB7IC4uLnpvZFRvSnNvblNjaGVtYShub2RlLmRhdGEuc2NoZW1hKSwgdGl0bGU6IG5vZGUuZGF0YS5uYW1lIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEdyYXBoIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibm9kZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlZGdlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdGhlIGdyYXBoIHRvIGEgSlNPTi1zZXJpYWxpemFibGUgZm9ybWF0LlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBzdGFibGVOb2RlSWRzID0ge307XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5ub2RlcykuZm9yRWFjaCgobm9kZSwgaSkgPT4ge1xuICAgICAgICAgICAgc3RhYmxlTm9kZUlkc1tub2RlLmlkXSA9IGlzVXVpZChub2RlLmlkKSA/IGkgOiBub2RlLmlkO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGVzOiBPYmplY3QudmFsdWVzKHRoaXMubm9kZXMpLm1hcCgobm9kZSkgPT4gKHtcbiAgICAgICAgICAgICAgICBpZDogc3RhYmxlTm9kZUlkc1tub2RlLmlkXSxcbiAgICAgICAgICAgICAgICAuLi5ub2RlRGF0YUpzb24obm9kZSksXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBlZGdlczogdGhpcy5lZGdlcy5tYXAoKGVkZ2UpID0+IGVkZ2UuZGF0YVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHN0YWJsZU5vZGVJZHNbZWRnZS5zb3VyY2VdLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHN0YWJsZU5vZGVJZHNbZWRnZS50YXJnZXRdLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBlZGdlLmRhdGEsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHN0YWJsZU5vZGVJZHNbZWRnZS5zb3VyY2VdLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHN0YWJsZU5vZGVJZHNbZWRnZS50YXJnZXRdLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGROb2RlKGRhdGEsIGlkKSB7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubm9kZXNbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSB3aXRoIGlkICR7aWR9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZUlkID0gaWQgfHwgdXVpZHY0KCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB7IGlkOiBub2RlSWQsIGRhdGEgfTtcbiAgICAgICAgdGhpcy5ub2Rlc1tub2RlSWRdID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHJlbW92ZU5vZGUobm9kZSkge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIG5vZGUgZnJvbSB0aGUgbm9kZXMgbWFwXG4gICAgICAgIGRlbGV0ZSB0aGlzLm5vZGVzW25vZGUuaWRdO1xuICAgICAgICAvLyBGaWx0ZXIgb3V0IGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgbm9kZVxuICAgICAgICB0aGlzLmVkZ2VzID0gdGhpcy5lZGdlcy5maWx0ZXIoKGVkZ2UpID0+IGVkZ2Uuc291cmNlICE9PSBub2RlLmlkICYmIGVkZ2UudGFyZ2V0ICE9PSBub2RlLmlkKTtcbiAgICB9XG4gICAgYWRkRWRnZShzb3VyY2UsIHRhcmdldCwgZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5ub2Rlc1tzb3VyY2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU291cmNlIG5vZGUgJHtzb3VyY2UuaWR9IG5vdCBpbiBncmFwaGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5vZGVzW3RhcmdldC5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYXJnZXQgbm9kZSAke3RhcmdldC5pZH0gbm90IGluIGdyYXBoYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWRnZSA9IHsgc291cmNlOiBzb3VyY2UuaWQsIHRhcmdldDogdGFyZ2V0LmlkLCBkYXRhIH07XG4gICAgICAgIHRoaXMuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgcmV0dXJuIGVkZ2U7XG4gICAgfVxuICAgIGZpcnN0Tm9kZSgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0cyA9IG5ldyBTZXQodGhpcy5lZGdlcy5tYXAoKGVkZ2UpID0+IGVkZ2UudGFyZ2V0KSk7XG4gICAgICAgIGNvbnN0IGZvdW5kID0gW107XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5ub2RlcykuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0YXJnZXRzLmhhcyhub2RlLmlkKSkge1xuICAgICAgICAgICAgICAgIGZvdW5kLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm91bmRbMF07XG4gICAgfVxuICAgIGxhc3ROb2RlKCkge1xuICAgICAgICBjb25zdCBzb3VyY2VzID0gbmV3IFNldCh0aGlzLmVkZ2VzLm1hcCgoZWRnZSkgPT4gZWRnZS5zb3VyY2UpKTtcbiAgICAgICAgY29uc3QgZm91bmQgPSBbXTtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZXMuaGFzKG5vZGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgZm91bmQucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZFswXTtcbiAgICB9XG4gICAgZXh0ZW5kKGdyYXBoKSB7XG4gICAgICAgIC8vIEFkZCBhbGwgbm9kZXMgZnJvbSB0aGUgb3RoZXIgZ3JhcGgsIHRha2luZyBjYXJlIHRvIGF2b2lkIGR1cGxpY2F0ZXNcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZ3JhcGgubm9kZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBZGQgYWxsIGVkZ2VzIGZyb20gdGhlIG90aGVyIGdyYXBoXG4gICAgICAgIHRoaXMuZWRnZXMgPSBbLi4udGhpcy5lZGdlcywgLi4uZ3JhcGguZWRnZXNdO1xuICAgIH1cbiAgICB0cmltRmlyc3ROb2RlKCkge1xuICAgICAgICBjb25zdCBmaXJzdE5vZGUgPSB0aGlzLmZpcnN0Tm9kZSgpO1xuICAgICAgICBpZiAoZmlyc3ROb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBvdXRnb2luZ0VkZ2VzID0gdGhpcy5lZGdlcy5maWx0ZXIoKGVkZ2UpID0+IGVkZ2Uuc291cmNlID09PSBmaXJzdE5vZGUuaWQpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMubm9kZXMpLmxlbmd0aCA9PT0gMSB8fCBvdXRnb2luZ0VkZ2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZShmaXJzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyaW1MYXN0Tm9kZSgpIHtcbiAgICAgICAgY29uc3QgbGFzdE5vZGUgPSB0aGlzLmxhc3ROb2RlKCk7XG4gICAgICAgIGlmIChsYXN0Tm9kZSkge1xuICAgICAgICAgICAgY29uc3QgaW5jb21pbmdFZGdlcyA9IHRoaXMuZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBlZGdlLnRhcmdldCA9PT0gbGFzdE5vZGUuaWQpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMubm9kZXMpLmxlbmd0aCA9PT0gMSB8fCBpbmNvbWluZ0VkZ2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZShsYXN0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/runnables/graph.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/runnables/iter.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/iter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   consumeAsyncIterableInContext: () => (/* binding */ consumeAsyncIterableInContext),\n/* harmony export */   consumeIteratorInContext: () => (/* binding */ consumeIteratorInContext),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),\n/* harmony export */   isIterator: () => (/* binding */ isIterator)\n/* harmony export */ });\n/* harmony import */ var _singletons_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../singletons/index.js */ \"(action-browser)/./node_modules/@langchain/core/dist/singletons/index.js\");\n\nfunction isIterator(thing) {\n    return (typeof thing === \"object\" &&\n        thing !== null &&\n        typeof thing[Symbol.iterator] === \"function\" &&\n        // avoid detecting array/set as iterator\n        typeof thing.next === \"function\");\n}\nfunction isAsyncIterable(thing) {\n    return (typeof thing === \"object\" &&\n        thing !== null &&\n        typeof thing[Symbol.asyncIterator] ===\n            \"function\");\n}\nfunction* consumeIteratorInContext(context, iter) {\n    const storage = _singletons_index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.getInstance();\n    while (true) {\n        const { value, done } = storage.run(context, iter.next.bind(iter));\n        if (done) {\n            break;\n        }\n        else {\n            yield value;\n        }\n    }\n}\nasync function* consumeAsyncIterableInContext(context, iter) {\n    const storage = _singletons_index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.getInstance();\n    const iterator = iter[Symbol.asyncIterator]();\n    while (true) {\n        const { value, done } = await storage.run(context, iterator.next.bind(iter));\n        if (done) {\n            break;\n        }\n        else {\n            yield value;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvaXRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE0RTtBQUNyRTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLG9GQUFrQztBQUN0RDtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG9CQUFvQixvRkFBa0M7QUFDdEQ7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxydW5uYWJsZXNcXGl0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiB9IGZyb20gXCIuLi9zaW5nbGV0b25zL2luZGV4LmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gaXNJdGVyYXRvcih0aGluZykge1xuICAgIHJldHVybiAodHlwZW9mIHRoaW5nID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHRoaW5nICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB0aGluZ1tTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgLy8gYXZvaWQgZGV0ZWN0aW5nIGFycmF5L3NldCBhcyBpdGVyYXRvclxuICAgICAgICB0eXBlb2YgdGhpbmcubmV4dCA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0FzeW5jSXRlcmFibGUodGhpbmcpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB0aGluZyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB0aGluZyAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgdGhpbmdbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PVxuICAgICAgICAgICAgXCJmdW5jdGlvblwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiogY29uc3VtZUl0ZXJhdG9ySW5Db250ZXh0KGNvbnRleHQsIGl0ZXIpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5nZXRJbnN0YW5jZSgpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IHN0b3JhZ2UucnVuKGNvbnRleHQsIGl0ZXIubmV4dC5iaW5kKGl0ZXIpKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIGNvbnN1bWVBc3luY0l0ZXJhYmxlSW5Db250ZXh0KGNvbnRleHQsIGl0ZXIpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5nZXRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gaXRlcltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBzdG9yYWdlLnJ1bihjb250ZXh0LCBpdGVyYXRvci5uZXh0LmJpbmQoaXRlcikpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/runnables/iter.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/runnables/utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _RootEventFilter: () => (/* binding */ _RootEventFilter),\n/* harmony export */   isRunnableInterface: () => (/* binding */ isRunnableInterface)\n/* harmony export */ });\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isRunnableInterface(thing) {\n    return thing ? thing.lc_runnable : false;\n}\n/**\n * Utility to filter the root event in the streamEvents implementation.\n * This is simply binding the arguments to the namespace to make save on\n * a bit of typing in the streamEvents implementation.\n *\n * TODO: Refactor and remove.\n */\nclass _RootEventFilter {\n    constructor(fields) {\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.includeNames = fields.includeNames;\n        this.includeTypes = fields.includeTypes;\n        this.includeTags = fields.includeTags;\n        this.excludeNames = fields.excludeNames;\n        this.excludeTypes = fields.excludeTypes;\n        this.excludeTags = fields.excludeTags;\n    }\n    includeEvent(event, rootType) {\n        let include = this.includeNames === undefined &&\n            this.includeTypes === undefined &&\n            this.includeTags === undefined;\n        const eventTags = event.tags ?? [];\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(event.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(rootType);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include || eventTags.some((tag) => this.includeTags?.includes(tag));\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(event.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(rootType);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && eventTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxydW5uYWJsZXNcXHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gaXNSdW5uYWJsZUludGVyZmFjZSh0aGluZykge1xuICAgIHJldHVybiB0aGluZyA/IHRoaW5nLmxjX3J1bm5hYmxlIDogZmFsc2U7XG59XG4vKipcbiAqIFV0aWxpdHkgdG8gZmlsdGVyIHRoZSByb290IGV2ZW50IGluIHRoZSBzdHJlYW1FdmVudHMgaW1wbGVtZW50YXRpb24uXG4gKiBUaGlzIGlzIHNpbXBseSBiaW5kaW5nIHRoZSBhcmd1bWVudHMgdG8gdGhlIG5hbWVzcGFjZSB0byBtYWtlIHNhdmUgb25cbiAqIGEgYml0IG9mIHR5cGluZyBpbiB0aGUgc3RyZWFtRXZlbnRzIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFRPRE86IFJlZmFjdG9yIGFuZCByZW1vdmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBfUm9vdEV2ZW50RmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZU5hbWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVUeXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlTmFtZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZVR5cGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVUYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5jbHVkZU5hbWVzID0gZmllbGRzLmluY2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5pbmNsdWRlVHlwZXMgPSBmaWVsZHMuaW5jbHVkZVR5cGVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID0gZmllbGRzLmluY2x1ZGVUYWdzO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVOYW1lcyA9IGZpZWxkcy5leGNsdWRlTmFtZXM7XG4gICAgICAgIHRoaXMuZXhjbHVkZVR5cGVzID0gZmllbGRzLmV4Y2x1ZGVUeXBlcztcbiAgICAgICAgdGhpcy5leGNsdWRlVGFncyA9IGZpZWxkcy5leGNsdWRlVGFncztcbiAgICB9XG4gICAgaW5jbHVkZUV2ZW50KGV2ZW50LCByb290VHlwZSkge1xuICAgICAgICBsZXQgaW5jbHVkZSA9IHRoaXMuaW5jbHVkZU5hbWVzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVR5cGVzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVRhZ3MgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZXZlbnRUYWdzID0gZXZlbnQudGFncyA/PyBbXTtcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZU5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZU5hbWVzLmluY2x1ZGVzKGV2ZW50Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSB8fCB0aGlzLmluY2x1ZGVUeXBlcy5pbmNsdWRlcyhyb290VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVRhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9XG4gICAgICAgICAgICAgICAgaW5jbHVkZSB8fCBldmVudFRhZ3Muc29tZSgodGFnKSA9PiB0aGlzLmluY2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgJiYgIXRoaXMuZXhjbHVkZU5hbWVzLmluY2x1ZGVzKGV2ZW50Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlVHlwZXMuaW5jbHVkZXMocm9vdFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUYWdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgJiYgZXZlbnRUYWdzLmV2ZXJ5KCh0YWcpID0+ICF0aGlzLmV4Y2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/runnables/utils.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/runnables/wrappers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/wrappers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertToHttpEventStream: () => (/* binding */ convertToHttpEventStream)\n/* harmony export */ });\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/stream.js */ \"(action-browser)/./node_modules/@langchain/core/dist/utils/stream.js\");\n\nfunction convertToHttpEventStream(stream) {\n    const encoder = new TextEncoder();\n    const finalStream = new ReadableStream({\n        async start(controller) {\n            for await (const chunk of stream) {\n                controller.enqueue(encoder.encode(`event: data\\ndata: ${JSON.stringify(chunk)}\\n\\n`));\n            }\n            controller.enqueue(encoder.encode(\"event: end\\n\\n\"));\n            controller.close();\n        },\n    });\n    return _utils_stream_js__WEBPACK_IMPORTED_MODULE_0__.IterableReadableStream.fromReadableStream(finalStream);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvd3JhcHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEQ7QUFDckQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxzQkFBc0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxXQUFXLG9FQUFzQjtBQUNqQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHJ1bm5hYmxlc1xcd3JhcHBlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSB9IGZyb20gXCIuLi91dGlscy9zdHJlYW0uanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9IdHRwRXZlbnRTdHJlYW0oc3RyZWFtKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGZpbmFsU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoYGV2ZW50OiBkYXRhXFxuZGF0YTogJHtKU09OLnN0cmluZ2lmeShjaHVuayl9XFxuXFxuYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKFwiZXZlbnQ6IGVuZFxcblxcblwiKSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKGZpbmFsU3RyZWFtKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/runnables/wrappers.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/singletons/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* binding */ AsyncLocalStorageProviderSingleton),\n/* harmony export */   MockAsyncLocalStorage: () => (/* binding */ MockAsyncLocalStorage)\n/* harmony export */ });\n/* eslint-disable @typescript-eslint/no-explicit-any */\nclass MockAsyncLocalStorage {\n    getStore() {\n        return undefined;\n    }\n    run(_store, callback) {\n        return callback();\n    }\n}\nclass AsyncLocalStorageProvider {\n    constructor() {\n        Object.defineProperty(this, \"asyncLocalStorage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new MockAsyncLocalStorage()\n        });\n        Object.defineProperty(this, \"hasBeenInitialized\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n    }\n    getInstance() {\n        return this.asyncLocalStorage;\n    }\n    initializeGlobalInstance(instance) {\n        if (!this.hasBeenInitialized) {\n            this.hasBeenInitialized = true;\n            this.asyncLocalStorage = instance;\n        }\n    }\n}\nconst AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9zaW5nbGV0b25zL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxzaW5nbGV0b25zXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5leHBvcnQgY2xhc3MgTW9ja0FzeW5jTG9jYWxTdG9yYWdlIHtcbiAgICBnZXRTdG9yZSgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcnVuKF9zdG9yZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxufVxuY2xhc3MgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFzeW5jTG9jYWxTdG9yYWdlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTW9ja0FzeW5jTG9jYWxTdG9yYWdlKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhc0JlZW5Jbml0aWFsaXplZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEluc3RhbmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luY0xvY2FsU3RvcmFnZTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZUdsb2JhbEluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNCZWVuSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQmVlbkluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYXN5bmNMb2NhbFN0b3JhZ2UgPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gPSBuZXcgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlcigpO1xuZXhwb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/singletons/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/tracers/base.js":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/base.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseTracer: () => (/* binding */ BaseTracer)\n/* harmony export */ });\n/* harmony import */ var _callbacks_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../callbacks/base.js */ \"(action-browser)/./node_modules/@langchain/core/dist/callbacks/base.js\");\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\nfunction stripNonAlphanumeric(input) {\n    return input.replace(/[-:.]/g, \"\");\n}\nfunction convertToDottedOrderFormat(epoch, runId, executionOrder) {\n    const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, \"0\");\n    return (stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId);\n}\nclass BaseTracer extends _callbacks_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseCallbackHandler {\n    constructor(_fields) {\n        super(...arguments);\n        Object.defineProperty(this, \"runMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n    }\n    copy() {\n        return this;\n    }\n    stringifyError(error) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (error instanceof Error) {\n            return error.message + (error?.stack ? `\\n\\n${error.stack}` : \"\");\n        }\n        if (typeof error === \"string\") {\n            return error;\n        }\n        return `${error}`;\n    }\n    _addChildRun(parentRun, childRun) {\n        parentRun.child_runs.push(childRun);\n    }\n    async _startTrace(run) {\n        const currentDottedOrder = convertToDottedOrderFormat(run.start_time, run.id, run.execution_order);\n        const storedRun = { ...run };\n        if (storedRun.parent_run_id !== undefined) {\n            const parentRun = this.runMap.get(storedRun.parent_run_id);\n            if (parentRun) {\n                this._addChildRun(parentRun, storedRun);\n                parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);\n                storedRun.trace_id = parentRun.trace_id;\n                if (parentRun.dotted_order !== undefined) {\n                    storedRun.dotted_order = [\n                        parentRun.dotted_order,\n                        currentDottedOrder,\n                    ].join(\".\");\n                }\n                else {\n                    // This can happen naturally for callbacks added within a run\n                    // console.debug(`Parent run with UUID ${storedRun.parent_run_id} has no dotted order.`);\n                }\n            }\n            else {\n                // This can happen naturally for callbacks added within a run\n                // console.debug(\n                //   `Parent run with UUID ${storedRun.parent_run_id} not found.`\n                // );\n            }\n        }\n        else {\n            storedRun.trace_id = storedRun.id;\n            storedRun.dotted_order = currentDottedOrder;\n        }\n        this.runMap.set(storedRun.id, storedRun);\n        await this.onRunCreate?.(storedRun);\n    }\n    async _endTrace(run) {\n        const parentRun = run.parent_run_id !== undefined && this.runMap.get(run.parent_run_id);\n        if (parentRun) {\n            parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);\n        }\n        else {\n            await this.persistRun(run);\n        }\n        this.runMap.delete(run.id);\n        await this.onRunUpdate?.(run);\n    }\n    _getExecutionOrder(parentRunId) {\n        const parentRun = parentRunId !== undefined && this.runMap.get(parentRunId);\n        // If a run has no parent then execution order is 1\n        if (!parentRun) {\n            return 1;\n        }\n        return parentRun.child_execution_order + 1;\n    }\n    async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: name ?? llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { prompts },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        await this._startTrace(run);\n        await this.onLLMStart?.(run);\n        return run;\n    }\n    async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: name ?? llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { messages },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        await this._startTrace(run);\n        await this.onLLMStart?.(run);\n        return run;\n    }\n    async handleLLMEnd(output, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = output;\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onLLMEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleLLMError(error, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onLLMError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? chain.id[chain.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: chain,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs,\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: runType ?? \"chain\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        await this._startTrace(run);\n        await this.onChainStart?.(run);\n        return run;\n    }\n    async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {\n        const run = this.runMap.get(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = _coerceToDict(outputs, \"output\");\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        if (kwargs?.inputs !== undefined) {\n            run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n        }\n        await this.onChainEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleChainError(error, runId, _parentRunId, _tags, kwargs) {\n        const run = this.runMap.get(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        if (kwargs?.inputs !== undefined) {\n            run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n        }\n        await this.onChainError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? tool.id[tool.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: tool,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { input },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"tool\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        await this._startTrace(run);\n        await this.onToolStart?.(run);\n        return run;\n    }\n    async handleToolEnd(output, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { output };\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onToolEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleToolError(error, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onToolError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleAgentAction(action, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        const agentRun = run;\n        agentRun.actions = agentRun.actions || [];\n        agentRun.actions.push(action);\n        agentRun.events.push({\n            name: \"agent_action\",\n            time: new Date().toISOString(),\n            kwargs: { action },\n        });\n        await this.onAgentAction?.(run);\n    }\n    async handleAgentEnd(action, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"agent_end\",\n            time: new Date().toISOString(),\n            kwargs: { action },\n        });\n        await this.onAgentEnd?.(run);\n    }\n    async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? retriever.id[retriever.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: retriever,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { query },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"retriever\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        await this._startTrace(run);\n        await this.onRetrieverStart?.(run);\n        return run;\n    }\n    async handleRetrieverEnd(documents, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { documents };\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onRetrieverEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleRetrieverError(error, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onRetrieverError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleText(text, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"text\",\n            time: new Date().toISOString(),\n            kwargs: { text },\n        });\n        await this.onText?.(run);\n    }\n    async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(`Invalid \"runId\" provided to \"handleLLMNewToken\" callback.`);\n        }\n        run.events.push({\n            name: \"new_token\",\n            time: new Date().toISOString(),\n            kwargs: { token, idx, chunk: fields?.chunk },\n        });\n        await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });\n        return run;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJDQUEyQyxFQUFFLFlBQVk7QUFDN0Y7QUFDTyx5QkFBeUIsbUVBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFlBQVk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx5QkFBeUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx5QkFBeUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hELFNBQVM7QUFDVCxpREFBaUQsc0JBQXNCO0FBQ3ZFO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHRyYWNlcnNcXGJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNhbGxiYWNrSGFuZGxlciwgfSBmcm9tIFwiLi4vY2FsbGJhY2tzL2Jhc2UuanNcIjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBfY29lcmNlVG9EaWN0KHZhbHVlLCBkZWZhdWx0S2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCJcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHsgW2RlZmF1bHRLZXldOiB2YWx1ZSB9O1xufVxuZnVuY3Rpb24gc3RyaXBOb25BbHBoYW51bWVyaWMoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvWy06Ll0vZywgXCJcIik7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdChlcG9jaCwgcnVuSWQsIGV4ZWN1dGlvbk9yZGVyKSB7XG4gICAgY29uc3QgcGFkZGVkT3JkZXIgPSBleGVjdXRpb25PcmRlci50b0ZpeGVkKDApLnNsaWNlKDAsIDMpLnBhZFN0YXJ0KDMsIFwiMFwiKTtcbiAgICByZXR1cm4gKHN0cmlwTm9uQWxwaGFudW1lcmljKGAke25ldyBEYXRlKGVwb2NoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIC0xKX0ke3BhZGRlZE9yZGVyfVpgKSArIHJ1bklkKTtcbn1cbmV4cG9ydCBjbGFzcyBCYXNlVHJhY2VyIGV4dGVuZHMgQmFzZUNhbGxiYWNrSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoX2ZpZWxkcykge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5NYXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN0cmluZ2lmeUVycm9yKGVycm9yKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvci5tZXNzYWdlICsgKGVycm9yPy5zdGFjayA/IGBcXG5cXG4ke2Vycm9yLnN0YWNrfWAgOiBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke2Vycm9yfWA7XG4gICAgfVxuICAgIF9hZGRDaGlsZFJ1bihwYXJlbnRSdW4sIGNoaWxkUnVuKSB7XG4gICAgICAgIHBhcmVudFJ1bi5jaGlsZF9ydW5zLnB1c2goY2hpbGRSdW4pO1xuICAgIH1cbiAgICBhc3luYyBfc3RhcnRUcmFjZShydW4pIHtcbiAgICAgICAgY29uc3QgY3VycmVudERvdHRlZE9yZGVyID0gY29udmVydFRvRG90dGVkT3JkZXJGb3JtYXQocnVuLnN0YXJ0X3RpbWUsIHJ1bi5pZCwgcnVuLmV4ZWN1dGlvbl9vcmRlcik7XG4gICAgICAgIGNvbnN0IHN0b3JlZFJ1biA9IHsgLi4ucnVuIH07XG4gICAgICAgIGlmIChzdG9yZWRSdW4ucGFyZW50X3J1bl9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRSdW4gPSB0aGlzLnJ1bk1hcC5nZXQoc3RvcmVkUnVuLnBhcmVudF9ydW5faWQpO1xuICAgICAgICAgICAgaWYgKHBhcmVudFJ1bikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZENoaWxkUnVuKHBhcmVudFJ1biwgc3RvcmVkUnVuKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyID0gTWF0aC5tYXgocGFyZW50UnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciwgc3RvcmVkUnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlcik7XG4gICAgICAgICAgICAgICAgc3RvcmVkUnVuLnRyYWNlX2lkID0gcGFyZW50UnVuLnRyYWNlX2lkO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRSdW4uZG90dGVkX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVkUnVuLmRvdHRlZF9vcmRlciA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJ1bi5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RG90dGVkT3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIF0uam9pbihcIi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gbmF0dXJhbGx5IGZvciBjYWxsYmFja3MgYWRkZWQgd2l0aGluIGEgcnVuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZGVidWcoYFBhcmVudCBydW4gd2l0aCBVVUlEICR7c3RvcmVkUnVuLnBhcmVudF9ydW5faWR9IGhhcyBubyBkb3R0ZWQgb3JkZXIuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIG5hdHVyYWxseSBmb3IgY2FsbGJhY2tzIGFkZGVkIHdpdGhpbiBhIHJ1blxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgICAgICAgLy8gICBgUGFyZW50IHJ1biB3aXRoIFVVSUQgJHtzdG9yZWRSdW4ucGFyZW50X3J1bl9pZH0gbm90IGZvdW5kLmBcbiAgICAgICAgICAgICAgICAvLyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RvcmVkUnVuLnRyYWNlX2lkID0gc3RvcmVkUnVuLmlkO1xuICAgICAgICAgICAgc3RvcmVkUnVuLmRvdHRlZF9vcmRlciA9IGN1cnJlbnREb3R0ZWRPcmRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJ1bk1hcC5zZXQoc3RvcmVkUnVuLmlkLCBzdG9yZWRSdW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUnVuQ3JlYXRlPy4oc3RvcmVkUnVuKTtcbiAgICB9XG4gICAgYXN5bmMgX2VuZFRyYWNlKHJ1bikge1xuICAgICAgICBjb25zdCBwYXJlbnRSdW4gPSBydW4ucGFyZW50X3J1bl9pZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucnVuTWFwLmdldChydW4ucGFyZW50X3J1bl9pZCk7XG4gICAgICAgIGlmIChwYXJlbnRSdW4pIHtcbiAgICAgICAgICAgIHBhcmVudFJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIgPSBNYXRoLm1heChwYXJlbnRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyLCBydW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdFJ1bihydW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucnVuTWFwLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUnVuVXBkYXRlPy4ocnVuKTtcbiAgICB9XG4gICAgX2dldEV4ZWN1dGlvbk9yZGVyKHBhcmVudFJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFJ1biA9IHBhcmVudFJ1bklkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ydW5NYXAuZ2V0KHBhcmVudFJ1bklkKTtcbiAgICAgICAgLy8gSWYgYSBydW4gaGFzIG5vIHBhcmVudCB0aGVuIGV4ZWN1dGlvbiBvcmRlciBpcyAxXG4gICAgICAgIGlmICghcGFyZW50UnVuKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50UnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciArIDE7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTVN0YXJ0KGxsbSwgcHJvbXB0cywgcnVuSWQsIHBhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgZmluYWxFeHRyYVBhcmFtcyA9IG1ldGFkYXRhXG4gICAgICAgICAgICA/IHsgLi4uZXh0cmFQYXJhbXMsIG1ldGFkYXRhIH1cbiAgICAgICAgICAgIDogZXh0cmFQYXJhbXM7XG4gICAgICAgIGNvbnN0IHJ1biA9IHtcbiAgICAgICAgICAgIGlkOiBydW5JZCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUgPz8gbGxtLmlkW2xsbS5pZC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudFJ1bklkLFxuICAgICAgICAgICAgc3RhcnRfdGltZSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IGxsbSxcbiAgICAgICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShzdGFydF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaW5wdXRzOiB7IHByb21wdHMgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBydW5fdHlwZTogXCJsbG1cIixcbiAgICAgICAgICAgIGV4dHJhOiBmaW5hbEV4dHJhUGFyYW1zID8/IHt9LFxuICAgICAgICAgICAgdGFnczogdGFncyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnRUcmFjZShydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uTExNU3RhcnQ/LihydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGF0TW9kZWxTdGFydChsbG0sIG1lc3NhZ2VzLCBydW5JZCwgcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSkge1xuICAgICAgICBjb25zdCBleGVjdXRpb25fb3JkZXIgPSB0aGlzLl9nZXRFeGVjdXRpb25PcmRlcihwYXJlbnRSdW5JZCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBmaW5hbEV4dHJhUGFyYW1zID0gbWV0YWRhdGFcbiAgICAgICAgICAgID8geyAuLi5leHRyYVBhcmFtcywgbWV0YWRhdGEgfVxuICAgICAgICAgICAgOiBleHRyYVBhcmFtcztcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyBsbG0uaWRbbGxtLmlkLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lLFxuICAgICAgICAgICAgc2VyaWFsaXplZDogbGxtLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgbWVzc2FnZXMgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBydW5fdHlwZTogXCJsbG1cIixcbiAgICAgICAgICAgIGV4dHJhOiBmaW5hbEV4dHJhUGFyYW1zID8/IHt9LFxuICAgICAgICAgICAgdGFnczogdGFncyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnRUcmFjZShydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uTExNU3RhcnQ/LihydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVMTE1FbmQob3V0cHV0LCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImxsbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBMTE0gcnVuIHRvIGVuZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLm91dHB1dHMgPSBvdXRwdXQ7XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkxMTUVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTUVycm9yKGVycm9yLCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImxsbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBMTE0gcnVuIHRvIGVuZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLmVycm9yID0gdGhpcy5zdHJpbmdpZnlFcnJvcihlcnJvcik7XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVycm9yXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uTExNRXJyb3I/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpblN0YXJ0KGNoYWluLCBpbnB1dHMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIHJ1blR5cGUsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyBjaGFpbi5pZFtjaGFpbi5pZC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudFJ1bklkLFxuICAgICAgICAgICAgc3RhcnRfdGltZSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IGNoYWluLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIHJ1bl90eXBlOiBydW5UeXBlID8/IFwiY2hhaW5cIixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgZXh0cmE6IG1ldGFkYXRhID8geyBtZXRhZGF0YSB9IDoge30sXG4gICAgICAgICAgICB0YWdzOiB0YWdzIHx8IFtdLFxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydFRyYWNlKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMub25DaGFpblN0YXJ0Py4ocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhaW5FbmQob3V0cHV0cywgcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGt3YXJncykge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1bikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hhaW4gcnVuIHRvIGVuZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLm91dHB1dHMgPSBfY29lcmNlVG9EaWN0KG91dHB1dHMsIFwib3V0cHV0XCIpO1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlbmRcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChrd2FyZ3M/LmlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW4uaW5wdXRzID0gX2NvZXJjZVRvRGljdChrd2FyZ3MuaW5wdXRzLCBcImlucHV0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMub25DaGFpbkVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluRXJyb3IoZXJyb3IsIHJ1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBrd2FyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNoYWluIHJ1biB0byBlbmQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5lcnJvciA9IHRoaXMuc3RyaW5naWZ5RXJyb3IoZXJyb3IpO1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGt3YXJncz8uaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1bi5pbnB1dHMgPSBfY29lcmNlVG9EaWN0KGt3YXJncy5pbnB1dHMsIFwiaW5wdXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5vbkNoYWluRXJyb3I/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUb29sU3RhcnQodG9vbCwgaW5wdXQsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyB0b29sLmlkW3Rvb2wuaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiB0b29sLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgaW5wdXQgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBleHRyYTogbWV0YWRhdGEgPyB7IG1ldGFkYXRhIH0gOiB7fSxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3MgfHwgW10sXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0VHJhY2UocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblRvb2xTdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFbmQob3V0cHV0LCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcInRvb2xcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdG9vbCBydW4gdG8gZW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5vdXRwdXRzID0geyBvdXRwdXQgfTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uVG9vbEVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFcnJvcihlcnJvciwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJ0b29sXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRvb2wgcnVuIHRvIGVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSB0aGlzLnN0cmluZ2lmeUVycm9yKGVycm9yKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25Ub29sRXJyb3I/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEFjdGlvbihhY3Rpb24sIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwiY2hhaW5cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFnZW50UnVuID0gcnVuO1xuICAgICAgICBhZ2VudFJ1bi5hY3Rpb25zID0gYWdlbnRSdW4uYWN0aW9ucyB8fCBbXTtcbiAgICAgICAgYWdlbnRSdW4uYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICAgIGFnZW50UnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWdlbnRfYWN0aW9uXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBrd2FyZ3M6IHsgYWN0aW9uIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uQWdlbnRBY3Rpb24/LihydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEVuZChhY3Rpb24sIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwiY2hhaW5cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImFnZW50X2VuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAga3dhcmdzOiB7IGFjdGlvbiB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkFnZW50RW5kPy4ocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmV0cmlldmVyU3RhcnQocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQsIHBhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSkge1xuICAgICAgICBjb25zdCBleGVjdXRpb25fb3JkZXIgPSB0aGlzLl9nZXRFeGVjdXRpb25PcmRlcihwYXJlbnRSdW5JZCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBydW4gPSB7XG4gICAgICAgICAgICBpZDogcnVuSWQsXG4gICAgICAgICAgICBuYW1lOiBuYW1lID8/IHJldHJpZXZlci5pZFtyZXRyaWV2ZXIuaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiByZXRyaWV2ZXIsXG4gICAgICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoc3RhcnRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGlucHV0czogeyBxdWVyeSB9LFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBydW5fdHlwZTogXCJyZXRyaWV2ZXJcIixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgZXh0cmE6IG1ldGFkYXRhID8geyBtZXRhZGF0YSB9IDoge30sXG4gICAgICAgICAgICB0YWdzOiB0YWdzIHx8IFtdLFxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydFRyYWNlKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMub25SZXRyaWV2ZXJTdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlckVuZChkb2N1bWVudHMsIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwicmV0cmlldmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJldHJpZXZlciBydW4gdG8gZW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5vdXRwdXRzID0geyBkb2N1bWVudHMgfTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUmV0cmlldmVyRW5kPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5kVHJhY2UocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmV0cmlldmVyRXJyb3IoZXJyb3IsIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwicmV0cmlldmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJldHJpZXZlciBydW4gdG8gZW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5lcnJvciA9IHRoaXMuc3RyaW5naWZ5RXJyb3IoZXJyb3IpO1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJldHJpZXZlckVycm9yPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5kVHJhY2UocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVGV4dCh0ZXh0LCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImNoYWluXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBrd2FyZ3M6IHsgdGV4dCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblRleHQ/LihydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVMTE1OZXdUb2tlbih0b2tlbiwgaWR4LCBydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywgZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwibGxtXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcInJ1bklkXCIgcHJvdmlkZWQgdG8gXCJoYW5kbGVMTE1OZXdUb2tlblwiIGNhbGxiYWNrLmApO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcIm5ld190b2tlblwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAga3dhcmdzOiB7IHRva2VuLCBpZHgsIGNodW5rOiBmaWVsZHM/LmNodW5rIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uTExNTmV3VG9rZW4/LihydW4sIHRva2VuLCB7IGNodW5rOiBmaWVsZHM/LmNodW5rIH0pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/tracers/base.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/tracers/console.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/console.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConsoleCallbackHandler: () => (/* binding */ ConsoleCallbackHandler)\n/* harmony export */ });\n/* harmony import */ var ansi_styles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ansi-styles */ \"(action-browser)/./node_modules/@langchain/core/node_modules/ansi-styles/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/core/dist/tracers/base.js\");\n\n\nfunction wrap(style, text) {\n    return `${style.open}${text}${style.close}`;\n}\nfunction tryJsonStringify(obj, fallback) {\n    try {\n        return JSON.stringify(obj, null, 2);\n    }\n    catch (err) {\n        return fallback;\n    }\n}\nfunction elapsed(run) {\n    if (!run.end_time)\n        return \"\";\n    const elapsed = run.end_time - run.start_time;\n    if (elapsed < 1000) {\n        return `${elapsed}ms`;\n    }\n    return `${(elapsed / 1000).toFixed(2)}s`;\n}\nconst { color } = ansi_styles__WEBPACK_IMPORTED_MODULE_0__;\n/**\n * A tracer that logs all events to the console. It extends from the\n * `BaseTracer` class and overrides its methods to provide custom logging\n * functionality.\n * @example\n * ```typescript\n *\n * const llm = new ChatAnthropic({\n *   temperature: 0,\n *   tags: [\"example\", \"callbacks\", \"constructor\"],\n *   callbacks: [new ConsoleCallbackHandler()],\n * });\n *\n * ```\n */\nclass ConsoleCallbackHandler extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseTracer {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"console_callback_handler\"\n        });\n    }\n    /**\n     * Method used to persist the run. In this case, it simply returns a\n     * resolved promise as there's no persistence logic.\n     * @param _run The run to persist.\n     * @returns A resolved promise.\n     */\n    persistRun(_run) {\n        return Promise.resolve();\n    }\n    // utility methods\n    /**\n     * Method used to get all the parent runs of a given run.\n     * @param run The run whose parents are to be retrieved.\n     * @returns An array of parent runs.\n     */\n    getParents(run) {\n        const parents = [];\n        let currentRun = run;\n        while (currentRun.parent_run_id) {\n            const parent = this.runMap.get(currentRun.parent_run_id);\n            if (parent) {\n                parents.push(parent);\n                currentRun = parent;\n            }\n            else {\n                break;\n            }\n        }\n        return parents;\n    }\n    /**\n     * Method used to get a string representation of the run's lineage, which\n     * is used in logging.\n     * @param run The run whose lineage is to be retrieved.\n     * @returns A string representation of the run's lineage.\n     */\n    getBreadcrumbs(run) {\n        const parents = this.getParents(run).reverse();\n        const string = [...parents, run]\n            .map((parent, i, arr) => {\n            const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;\n            return i === arr.length - 1 ? wrap(ansi_styles__WEBPACK_IMPORTED_MODULE_0__.bold, name) : name;\n        })\n            .join(\" > \");\n        return wrap(color.grey, string);\n    }\n    // logging methods\n    /**\n     * Method used to log the start of a chain run.\n     * @param run The chain run that has started.\n     * @returns void\n     */\n    onChainStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[chain/start]\")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(run.inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of a chain run.\n     * @param run The chain run that has ended.\n     * @returns void\n     */\n    onChainEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[chain/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Chain run with output: ${tryJsonStringify(run.outputs, \"[outputs]\")}`);\n    }\n    /**\n     * Method used to log any errors of a chain run.\n     * @param run The chain run that has errored.\n     * @returns void\n     */\n    onChainError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[chain/error]\")} [${crumbs}] [${elapsed(run)}] Chain run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of an LLM run.\n     * @param run The LLM run that has started.\n     * @returns void\n     */\n    onLLMStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        const inputs = \"prompts\" in run.inputs\n            ? { prompts: run.inputs.prompts.map((p) => p.trim()) }\n            : run.inputs;\n        console.log(`${wrap(color.green, \"[llm/start]\")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of an LLM run.\n     * @param run The LLM run that has ended.\n     * @returns void\n     */\n    onLLMEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[llm/end]\")} [${crumbs}] [${elapsed(run)}] Exiting LLM run with output: ${tryJsonStringify(run.outputs, \"[response]\")}`);\n    }\n    /**\n     * Method used to log any errors of an LLM run.\n     * @param run The LLM run that has errored.\n     * @returns void\n     */\n    onLLMError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[llm/error]\")} [${crumbs}] [${elapsed(run)}] LLM run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of a tool run.\n     * @param run The tool run that has started.\n     * @returns void\n     */\n    onToolStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[tool/start]\")} [${crumbs}] Entering Tool run with input: \"${run.inputs.input?.trim()}\"`);\n    }\n    /**\n     * Method used to log the end of a tool run.\n     * @param run The tool run that has ended.\n     * @returns void\n     */\n    onToolEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[tool/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Tool run with output: \"${run.outputs?.output?.trim()}\"`);\n    }\n    /**\n     * Method used to log any errors of a tool run.\n     * @param run The tool run that has errored.\n     * @returns void\n     */\n    onToolError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[tool/error]\")} [${crumbs}] [${elapsed(run)}] Tool run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of a retriever run.\n     * @param run The retriever run that has started.\n     * @returns void\n     */\n    onRetrieverStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[retriever/start]\")} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(run.inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of a retriever run.\n     * @param run The retriever run that has ended.\n     * @returns void\n     */\n    onRetrieverEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[retriever/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Retriever run with output: ${tryJsonStringify(run.outputs, \"[outputs]\")}`);\n    }\n    /**\n     * Method used to log any errors of a retriever run.\n     * @param run The retriever run that has errored.\n     * @returns void\n     */\n    onRetrieverError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[retriever/error]\")} [${crumbs}] [${elapsed(run)}] Retriever run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the action selected by the agent.\n     * @param run The run in which the agent action occurred.\n     * @returns void\n     */\n    onAgentAction(run) {\n        const agentRun = run;\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.blue, \"[agent/action]\")} [${crumbs}] Agent selected action: ${tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], \"[action]\")}`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL2NvbnNvbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWlDO0FBQ007QUFDdkM7QUFDQSxjQUFjLFdBQVcsRUFBRSxLQUFLLEVBQUUsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBLFFBQVEsUUFBUSxFQUFFLHdDQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ08scUNBQXFDLGdEQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCLEdBQUcsZ0JBQWdCLEdBQUcsWUFBWTtBQUNyRiwrQ0FBK0MsNkNBQVc7QUFDMUQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0NBQW9DLEdBQUcsT0FBTyxtQ0FBbUMseUNBQXlDO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDLEdBQUcsT0FBTyxLQUFLLGFBQWEsbUNBQW1DLDJDQUEyQztBQUNsSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtDQUFrQyxHQUFHLE9BQU8sS0FBSyxhQUFhLGtDQUFrQyx1Q0FBdUM7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsdUJBQXVCLGtDQUFrQyxHQUFHLE9BQU8saUNBQWlDLHFDQUFxQztBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQixHQUFHLE9BQU8sS0FBSyxhQUFhLGlDQUFpQyw0Q0FBNEM7QUFDL0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0MsR0FBRyxPQUFPLEtBQUssYUFBYSxnQ0FBZ0MsdUNBQXVDO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUNBQW1DLEdBQUcsT0FBTyxtQ0FBbUMseUJBQXlCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWdDLEdBQUcsT0FBTyxLQUFLLGFBQWEsbUNBQW1DLDRCQUE0QjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQyxHQUFHLE9BQU8sS0FBSyxhQUFhLGlDQUFpQyx1Q0FBdUM7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3Q0FBd0MsR0FBRyxPQUFPLHVDQUF1Qyx5Q0FBeUM7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQ0FBcUMsR0FBRyxPQUFPLEtBQUssYUFBYSx1Q0FBdUMsMkNBQTJDO0FBQzFLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0NBQXNDLEdBQUcsT0FBTyxLQUFLLGFBQWEsc0NBQXNDLHVDQUF1QztBQUN0SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0NBQW9DLEdBQUcsT0FBTywyQkFBMkIsNEVBQTRFO0FBQzVLO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx0cmFjZXJzXFxjb25zb2xlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHlsZXMgZnJvbSBcImFuc2ktc3R5bGVzXCI7XG5pbXBvcnQgeyBCYXNlVHJhY2VyIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuZnVuY3Rpb24gd3JhcChzdHlsZSwgdGV4dCkge1xuICAgIHJldHVybiBgJHtzdHlsZS5vcGVufSR7dGV4dH0ke3N0eWxlLmNsb3NlfWA7XG59XG5mdW5jdGlvbiB0cnlKc29uU3RyaW5naWZ5KG9iaiwgZmFsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgfVxufVxuZnVuY3Rpb24gZWxhcHNlZChydW4pIHtcbiAgICBpZiAoIXJ1bi5lbmRfdGltZSlcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgY29uc3QgZWxhcHNlZCA9IHJ1bi5lbmRfdGltZSAtIHJ1bi5zdGFydF90aW1lO1xuICAgIGlmIChlbGFwc2VkIDwgMTAwMCkge1xuICAgICAgICByZXR1cm4gYCR7ZWxhcHNlZH1tc2A7XG4gICAgfVxuICAgIHJldHVybiBgJHsoZWxhcHNlZCAvIDEwMDApLnRvRml4ZWQoMil9c2A7XG59XG5jb25zdCB7IGNvbG9yIH0gPSBzdHlsZXM7XG4vKipcbiAqIEEgdHJhY2VyIHRoYXQgbG9ncyBhbGwgZXZlbnRzIHRvIHRoZSBjb25zb2xlLiBJdCBleHRlbmRzIGZyb20gdGhlXG4gKiBgQmFzZVRyYWNlcmAgY2xhc3MgYW5kIG92ZXJyaWRlcyBpdHMgbWV0aG9kcyB0byBwcm92aWRlIGN1c3RvbSBsb2dnaW5nXG4gKiBmdW5jdGlvbmFsaXR5LlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqXG4gKiBjb25zdCBsbG0gPSBuZXcgQ2hhdEFudGhyb3BpYyh7XG4gKiAgIHRlbXBlcmF0dXJlOiAwLFxuICogICB0YWdzOiBbXCJleGFtcGxlXCIsIFwiY2FsbGJhY2tzXCIsIFwiY29uc3RydWN0b3JcIl0sXG4gKiAgIGNhbGxiYWNrczogW25ldyBDb25zb2xlQ2FsbGJhY2tIYW5kbGVyKCldLFxuICogfSk7XG4gKlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25zb2xlQ2FsbGJhY2tIYW5kbGVyIGV4dGVuZHMgQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiY29uc29sZV9jYWxsYmFja19oYW5kbGVyXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHBlcnNpc3QgdGhlIHJ1bi4gSW4gdGhpcyBjYXNlLCBpdCBzaW1wbHkgcmV0dXJucyBhXG4gICAgICogcmVzb2x2ZWQgcHJvbWlzZSBhcyB0aGVyZSdzIG5vIHBlcnNpc3RlbmNlIGxvZ2ljLlxuICAgICAqIEBwYXJhbSBfcnVuIFRoZSBydW4gdG8gcGVyc2lzdC5cbiAgICAgKiBAcmV0dXJucyBBIHJlc29sdmVkIHByb21pc2UuXG4gICAgICovXG4gICAgcGVyc2lzdFJ1bihfcnVuKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLy8gdXRpbGl0eSBtZXRob2RzXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gZ2V0IGFsbCB0aGUgcGFyZW50IHJ1bnMgb2YgYSBnaXZlbiBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcnVuIHdob3NlIHBhcmVudHMgYXJlIHRvIGJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBwYXJlbnQgcnVucy5cbiAgICAgKi9cbiAgICBnZXRQYXJlbnRzKHJ1bikge1xuICAgICAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgICAgIGxldCBjdXJyZW50UnVuID0gcnVuO1xuICAgICAgICB3aGlsZSAoY3VycmVudFJ1bi5wYXJlbnRfcnVuX2lkKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnJ1bk1hcC5nZXQoY3VycmVudFJ1bi5wYXJlbnRfcnVuX2lkKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UnVuID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcnVuJ3MgbGluZWFnZSwgd2hpY2hcbiAgICAgKiBpcyB1c2VkIGluIGxvZ2dpbmcuXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcnVuIHdob3NlIGxpbmVhZ2UgaXMgdG8gYmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBydW4ncyBsaW5lYWdlLlxuICAgICAqL1xuICAgIGdldEJyZWFkY3J1bWJzKHJ1bikge1xuICAgICAgICBjb25zdCBwYXJlbnRzID0gdGhpcy5nZXRQYXJlbnRzKHJ1bikucmV2ZXJzZSgpO1xuICAgICAgICBjb25zdCBzdHJpbmcgPSBbLi4ucGFyZW50cywgcnVuXVxuICAgICAgICAgICAgLm1hcCgocGFyZW50LCBpLCBhcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBgJHtwYXJlbnQuZXhlY3V0aW9uX29yZGVyfToke3BhcmVudC5ydW5fdHlwZX06JHtwYXJlbnQubmFtZX1gO1xuICAgICAgICAgICAgcmV0dXJuIGkgPT09IGFyci5sZW5ndGggLSAxID8gd3JhcChzdHlsZXMuYm9sZCwgbmFtZSkgOiBuYW1lO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oXCIgPiBcIik7XG4gICAgICAgIHJldHVybiB3cmFwKGNvbG9yLmdyZXksIHN0cmluZyk7XG4gICAgfVxuICAgIC8vIGxvZ2dpbmcgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgc3RhcnQgb2YgYSBjaGFpbiBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgY2hhaW4gcnVuIHRoYXQgaGFzIHN0YXJ0ZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uQ2hhaW5TdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmdyZWVuLCBcIltjaGFpbi9zdGFydF1cIil9IFske2NydW1ic31dIEVudGVyaW5nIENoYWluIHJ1biB3aXRoIGlucHV0OiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmlucHV0cywgXCJbaW5wdXRzXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBlbmQgb2YgYSBjaGFpbiBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgY2hhaW4gcnVuIHRoYXQgaGFzIGVuZGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkNoYWluRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuY3lhbiwgXCJbY2hhaW4vZW5kXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gRXhpdGluZyBDaGFpbiBydW4gd2l0aCBvdXRwdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4ub3V0cHV0cywgXCJbb3V0cHV0c11cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyBhbnkgZXJyb3JzIG9mIGEgY2hhaW4gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIGNoYWluIHJ1biB0aGF0IGhhcyBlcnJvcmVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkNoYWluRXJyb3IocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5yZWQsIFwiW2NoYWluL2Vycm9yXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gQ2hhaW4gcnVuIGVycm9yZWQgd2l0aCBlcnJvcjogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5lcnJvciwgXCJbZXJyb3JdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIHN0YXJ0IG9mIGFuIExMTSBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgTExNIHJ1biB0aGF0IGhhcyBzdGFydGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkxMTVN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IFwicHJvbXB0c1wiIGluIHJ1bi5pbnB1dHNcbiAgICAgICAgICAgID8geyBwcm9tcHRzOiBydW4uaW5wdXRzLnByb21wdHMubWFwKChwKSA9PiBwLnRyaW0oKSkgfVxuICAgICAgICAgICAgOiBydW4uaW5wdXRzO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmdyZWVuLCBcIltsbG0vc3RhcnRdXCIpfSBbJHtjcnVtYnN9XSBFbnRlcmluZyBMTE0gcnVuIHdpdGggaW5wdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShpbnB1dHMsIFwiW2lucHV0c11cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgZW5kIG9mIGFuIExMTSBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgTExNIHJ1biB0aGF0IGhhcyBlbmRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25MTE1FbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5jeWFuLCBcIltsbG0vZW5kXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gRXhpdGluZyBMTE0gcnVuIHdpdGggb3V0cHV0OiAke3RyeUpzb25TdHJpbmdpZnkocnVuLm91dHB1dHMsIFwiW3Jlc3BvbnNlXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIGFueSBlcnJvcnMgb2YgYW4gTExNIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBMTE0gcnVuIHRoYXQgaGFzIGVycm9yZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uTExNRXJyb3IocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5yZWQsIFwiW2xsbS9lcnJvcl1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIExMTSBydW4gZXJyb3JlZCB3aXRoIGVycm9yOiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmVycm9yLCBcIltlcnJvcl1cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgc3RhcnQgb2YgYSB0b29sIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSB0b29sIHJ1biB0aGF0IGhhcyBzdGFydGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblRvb2xTdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmdyZWVuLCBcIlt0b29sL3N0YXJ0XVwiKX0gWyR7Y3J1bWJzfV0gRW50ZXJpbmcgVG9vbCBydW4gd2l0aCBpbnB1dDogXCIke3J1bi5pbnB1dHMuaW5wdXQ/LnRyaW0oKX1cImApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIGVuZCBvZiBhIHRvb2wgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHRvb2wgcnVuIHRoYXQgaGFzIGVuZGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblRvb2xFbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5jeWFuLCBcIlt0b29sL2VuZF1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIEV4aXRpbmcgVG9vbCBydW4gd2l0aCBvdXRwdXQ6IFwiJHtydW4ub3V0cHV0cz8ub3V0cHV0Py50cmltKCl9XCJgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIGFueSBlcnJvcnMgb2YgYSB0b29sIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSB0b29sIHJ1biB0aGF0IGhhcyBlcnJvcmVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblRvb2xFcnJvcihydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLnJlZCwgXCJbdG9vbC9lcnJvcl1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIFRvb2wgcnVuIGVycm9yZWQgd2l0aCBlcnJvcjogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5lcnJvciwgXCJbZXJyb3JdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIHN0YXJ0IG9mIGEgcmV0cmlldmVyIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSByZXRyaWV2ZXIgcnVuIHRoYXQgaGFzIHN0YXJ0ZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uUmV0cmlldmVyU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5ncmVlbiwgXCJbcmV0cmlldmVyL3N0YXJ0XVwiKX0gWyR7Y3J1bWJzfV0gRW50ZXJpbmcgUmV0cmlldmVyIHJ1biB3aXRoIGlucHV0OiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmlucHV0cywgXCJbaW5wdXRzXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBlbmQgb2YgYSByZXRyaWV2ZXIgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJldHJpZXZlciBydW4gdGhhdCBoYXMgZW5kZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uUmV0cmlldmVyRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuY3lhbiwgXCJbcmV0cmlldmVyL2VuZF1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIEV4aXRpbmcgUmV0cmlldmVyIHJ1biB3aXRoIG91dHB1dDogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5vdXRwdXRzLCBcIltvdXRwdXRzXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIGFueSBlcnJvcnMgb2YgYSByZXRyaWV2ZXIgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJldHJpZXZlciBydW4gdGhhdCBoYXMgZXJyb3JlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25SZXRyaWV2ZXJFcnJvcihydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLnJlZCwgXCJbcmV0cmlldmVyL2Vycm9yXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gUmV0cmlldmVyIHJ1biBlcnJvcmVkIHdpdGggZXJyb3I6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uZXJyb3IsIFwiW2Vycm9yXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBhY3Rpb24gc2VsZWN0ZWQgYnkgdGhlIGFnZW50LlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJ1biBpbiB3aGljaCB0aGUgYWdlbnQgYWN0aW9uIG9jY3VycmVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkFnZW50QWN0aW9uKHJ1bikge1xuICAgICAgICBjb25zdCBhZ2VudFJ1biA9IHJ1bjtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmJsdWUsIFwiW2FnZW50L2FjdGlvbl1cIil9IFske2NydW1ic31dIEFnZW50IHNlbGVjdGVkIGFjdGlvbjogJHt0cnlKc29uU3RyaW5naWZ5KGFnZW50UnVuLmFjdGlvbnNbYWdlbnRSdW4uYWN0aW9ucy5sZW5ndGggLSAxXSwgXCJbYWN0aW9uXVwiKX1gKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/tracers/console.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/tracers/initialize.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/initialize.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTracingCallbackHandler: () => (/* binding */ getTracingCallbackHandler),\n/* harmony export */   getTracingV2CallbackHandler: () => (/* binding */ getTracingV2CallbackHandler)\n/* harmony export */ });\n/* harmony import */ var _tracer_langchain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tracer_langchain.js */ \"(action-browser)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.js\");\n/* harmony import */ var _tracer_langchain_v1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tracer_langchain_v1.js */ \"(action-browser)/./node_modules/@langchain/core/dist/tracers/tracer_langchain_v1.js\");\n\n\n/**\n * @deprecated Use the V2 handler instead.\n *\n * Function that returns an instance of `LangChainTracerV1`. If a session\n * is provided, it loads that session into the tracer; otherwise, it loads\n * a default session.\n * @param session Optional session to load into the tracer.\n * @returns An instance of `LangChainTracerV1`.\n */\nasync function getTracingCallbackHandler(session) {\n    const tracer = new _tracer_langchain_v1_js__WEBPACK_IMPORTED_MODULE_1__.LangChainTracerV1();\n    if (session) {\n        await tracer.loadSession(session);\n    }\n    else {\n        await tracer.loadDefaultSession();\n    }\n    return tracer;\n}\n/**\n * Function that returns an instance of `LangChainTracer`. It does not\n * load any session data.\n * @returns An instance of `LangChainTracer`.\n */\nasync function getTracingV2CallbackHandler() {\n    return new _tracer_langchain_js__WEBPACK_IMPORTED_MODULE_0__.LangChainTracer();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL2luaXRpYWxpemUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3RDtBQUNLO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx1QkFBdUIsc0VBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlLGlFQUFlO0FBQzlCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdHJhY2Vyc1xcaW5pdGlhbGl6ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMYW5nQ2hhaW5UcmFjZXIgfSBmcm9tIFwiLi90cmFjZXJfbGFuZ2NoYWluLmpzXCI7XG5pbXBvcnQgeyBMYW5nQ2hhaW5UcmFjZXJWMSB9IGZyb20gXCIuL3RyYWNlcl9sYW5nY2hhaW5fdjEuanNcIjtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBWMiBoYW5kbGVyIGluc3RlYWQuXG4gKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGluc3RhbmNlIG9mIGBMYW5nQ2hhaW5UcmFjZXJWMWAuIElmIGEgc2Vzc2lvblxuICogaXMgcHJvdmlkZWQsIGl0IGxvYWRzIHRoYXQgc2Vzc2lvbiBpbnRvIHRoZSB0cmFjZXI7IG90aGVyd2lzZSwgaXQgbG9hZHNcbiAqIGEgZGVmYXVsdCBzZXNzaW9uLlxuICogQHBhcmFtIHNlc3Npb24gT3B0aW9uYWwgc2Vzc2lvbiB0byBsb2FkIGludG8gdGhlIHRyYWNlci5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIGBMYW5nQ2hhaW5UcmFjZXJWMWAuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUcmFjaW5nQ2FsbGJhY2tIYW5kbGVyKHNlc3Npb24pIHtcbiAgICBjb25zdCB0cmFjZXIgPSBuZXcgTGFuZ0NoYWluVHJhY2VyVjEoKTtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICBhd2FpdCB0cmFjZXIubG9hZFNlc3Npb24oc2Vzc2lvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhd2FpdCB0cmFjZXIubG9hZERlZmF1bHRTZXNzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0cmFjZXI7XG59XG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBpbnN0YW5jZSBvZiBgTGFuZ0NoYWluVHJhY2VyYC4gSXQgZG9lcyBub3RcbiAqIGxvYWQgYW55IHNlc3Npb24gZGF0YS5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIGBMYW5nQ2hhaW5UcmFjZXJgLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VHJhY2luZ1YyQ2FsbGJhY2tIYW5kbGVyKCkge1xuICAgIHJldHVybiBuZXcgTGFuZ0NoYWluVHJhY2VyKCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/tracers/initialize.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/tracers/log_stream.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/log_stream.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogStreamCallbackHandler: () => (/* binding */ LogStreamCallbackHandler),\n/* harmony export */   RunLog: () => (/* binding */ RunLog),\n/* harmony export */   RunLogPatch: () => (/* binding */ RunLogPatch)\n/* harmony export */ });\n/* harmony import */ var _utils_fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/fast-json-patch/index.js */ \"(action-browser)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/core/dist/tracers/base.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/stream.js */ \"(action-browser)/./node_modules/@langchain/core/dist/utils/stream.js\");\n/* harmony import */ var _messages_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../messages/index.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/index.js\");\n\n\n\n\n/**\n * List of jsonpatch JSONPatchOperations, which describe how to create the run state\n * from an empty dict. This is the minimal representation of the log, designed to\n * be serialized as JSON and sent over the wire to reconstruct the log on the other\n * side. Reconstruction of the state can be done with any jsonpatch-compliant library,\n * see https://jsonpatch.com for more information.\n */\nclass RunLogPatch {\n    constructor(fields) {\n        Object.defineProperty(this, \"ops\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.ops = fields.ops ?? [];\n    }\n    concat(other) {\n        const ops = this.ops.concat(other.ops);\n        const states = (0,_utils_fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__.applyPatch)({}, ops);\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunLog({\n            ops,\n            state: states[states.length - 1].newDocument,\n        });\n    }\n}\nclass RunLog extends RunLogPatch {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"state\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.state = fields.state;\n    }\n    concat(other) {\n        const ops = this.ops.concat(other.ops);\n        const states = (0,_utils_fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__.applyPatch)(this.state, other.ops);\n        return new RunLog({ ops, state: states[states.length - 1].newDocument });\n    }\n    static fromRunLogPatch(patch) {\n        const states = (0,_utils_fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__.applyPatch)({}, patch.ops);\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunLog({\n            ops: patch.ops,\n            state: states[states.length - 1].newDocument,\n        });\n    }\n}\n/**\n * Extract standardized inputs from a run.\n *\n * Standardizes the inputs based on the type of the runnable used.\n *\n * @param run - Run object\n * @param schemaFormat - The schema format to use.\n *\n * @returns Valid inputs are only dict. By conventions, inputs always represented\n * invocation using named arguments.\n * A null means that the input is not yet known!\n */\nasync function _getStandardizedInputs(run, schemaFormat) {\n    if (schemaFormat === \"original\") {\n        throw new Error(\"Do not assign inputs with original schema drop the key for now. \" +\n            \"When inputs are added to streamLog they should be added with \" +\n            \"standardized schema for streaming events.\");\n    }\n    const { inputs } = run;\n    if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n        return inputs;\n    }\n    if (Object.keys(inputs).length === 1 && inputs?.input === \"\") {\n        return undefined;\n    }\n    // new style chains\n    // These nest an additional 'input' key inside the 'inputs' to make sure\n    // the input is always a dict. We need to unpack and user the inner value.\n    // We should try to fix this in Runnables and callbacks/tracers\n    // Runnables should be using a null type here not a placeholder\n    // dict.\n    return inputs.input;\n}\nasync function _getStandardizedOutputs(run, schemaFormat) {\n    const { outputs } = run;\n    if (schemaFormat === \"original\") {\n        // Return the old schema, without standardizing anything\n        return outputs;\n    }\n    if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n        return outputs;\n    }\n    // TODO: Remove this hacky check\n    if (outputs !== undefined &&\n        Object.keys(outputs).length === 1 &&\n        outputs?.output !== undefined) {\n        return outputs.output;\n    }\n    return outputs;\n}\nfunction isChatGenerationChunk(x) {\n    return x !== undefined && x.message !== undefined;\n}\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nclass LogStreamCallbackHandler extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseTracer {\n    constructor(fields) {\n        super({ _awaitHandler: true, ...fields });\n        Object.defineProperty(this, \"autoClose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_schemaFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"original\"\n        });\n        Object.defineProperty(this, \"rootId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"keyMapByRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"counterMapByRunName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"transformStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"writer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"receiveStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"log_stream_tracer\"\n        });\n        this.autoClose = fields?.autoClose ?? true;\n        this.includeNames = fields?.includeNames;\n        this.includeTypes = fields?.includeTypes;\n        this.includeTags = fields?.includeTags;\n        this.excludeNames = fields?.excludeNames;\n        this.excludeTypes = fields?.excludeTypes;\n        this.excludeTags = fields?.excludeTags;\n        this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;\n        this.transformStream = new TransformStream();\n        this.writer = this.transformStream.writable.getWriter();\n        this.receiveStream = _utils_stream_js__WEBPACK_IMPORTED_MODULE_2__.IterableReadableStream.fromReadableStream(this.transformStream.readable);\n    }\n    [Symbol.asyncIterator]() {\n        return this.receiveStream;\n    }\n    async persistRun(_run) {\n        // This is a legacy method only called once for an entire run tree\n        // and is therefore not useful here\n    }\n    _includeRun(run) {\n        if (run.id === this.rootId) {\n            return false;\n        }\n        const runTags = run.tags ?? [];\n        let include = this.includeNames === undefined &&\n            this.includeTags === undefined &&\n            this.includeTypes === undefined;\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(run.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(run.run_type);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include ||\n                    runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(run.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(run.run_type);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n    async *tapOutputIterable(runId, output) {\n        // Tap an output async iterator to stream its values to the log.\n        for await (const chunk of output) {\n            // root run is handled in .streamLog()\n            if (runId !== this.rootId) {\n                // if we can't find the run silently ignore\n                // eg. because this run wasn't included in the log\n                const key = this.keyMapByRunId[runId];\n                if (key) {\n                    await this.writer.write(new RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: `/logs/${key}/streamed_output/-`,\n                                value: chunk,\n                            },\n                        ],\n                    }));\n                }\n            }\n            yield chunk;\n        }\n    }\n    async onRunCreate(run) {\n        if (this.rootId === undefined) {\n            this.rootId = run.id;\n            await this.writer.write(new RunLogPatch({\n                ops: [\n                    {\n                        op: \"replace\",\n                        path: \"\",\n                        value: {\n                            id: run.id,\n                            name: run.name,\n                            type: run.run_type,\n                            streamed_output: [],\n                            final_output: undefined,\n                            logs: {},\n                        },\n                    },\n                ],\n            }));\n        }\n        if (!this._includeRun(run)) {\n            return;\n        }\n        if (this.counterMapByRunName[run.name] === undefined) {\n            this.counterMapByRunName[run.name] = 0;\n        }\n        this.counterMapByRunName[run.name] += 1;\n        const count = this.counterMapByRunName[run.name];\n        this.keyMapByRunId[run.id] =\n            count === 1 ? run.name : `${run.name}:${count}`;\n        const logEntry = {\n            id: run.id,\n            name: run.name,\n            type: run.run_type,\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            start_time: new Date(run.start_time).toISOString(),\n            streamed_output: [],\n            streamed_output_str: [],\n            final_output: undefined,\n            end_time: undefined,\n        };\n        if (this._schemaFormat === \"streaming_events\") {\n            logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);\n        }\n        await this.writer.write(new RunLogPatch({\n            ops: [\n                {\n                    op: \"add\",\n                    path: `/logs/${this.keyMapByRunId[run.id]}`,\n                    value: logEntry,\n                },\n            ],\n        }));\n    }\n    async onRunUpdate(run) {\n        try {\n            const runName = this.keyMapByRunId[run.id];\n            if (runName === undefined) {\n                return;\n            }\n            const ops = [];\n            if (this._schemaFormat === \"streaming_events\") {\n                ops.push({\n                    op: \"replace\",\n                    path: `/logs/${runName}/inputs`,\n                    value: await _getStandardizedInputs(run, this._schemaFormat),\n                });\n            }\n            ops.push({\n                op: \"add\",\n                path: `/logs/${runName}/final_output`,\n                value: await _getStandardizedOutputs(run, this._schemaFormat),\n            });\n            if (run.end_time !== undefined) {\n                ops.push({\n                    op: \"add\",\n                    path: `/logs/${runName}/end_time`,\n                    value: new Date(run.end_time).toISOString(),\n                });\n            }\n            const patch = new RunLogPatch({ ops });\n            await this.writer.write(patch);\n        }\n        finally {\n            if (run.id === this.rootId) {\n                const patch = new RunLogPatch({\n                    ops: [\n                        {\n                            op: \"replace\",\n                            path: \"/final_output\",\n                            value: await _getStandardizedOutputs(run, this._schemaFormat),\n                        },\n                    ],\n                });\n                await this.writer.write(patch);\n                if (this.autoClose) {\n                    await this.writer.close();\n                }\n            }\n        }\n    }\n    async onLLMNewToken(run, token, kwargs) {\n        const runName = this.keyMapByRunId[run.id];\n        if (runName === undefined) {\n            return;\n        }\n        // TODO: Remove hack\n        const isChatModel = run.inputs.messages !== undefined;\n        let streamedOutputValue;\n        if (isChatModel) {\n            if (isChatGenerationChunk(kwargs?.chunk)) {\n                streamedOutputValue = kwargs?.chunk;\n            }\n            else {\n                streamedOutputValue = new _messages_index_js__WEBPACK_IMPORTED_MODULE_3__.AIMessageChunk(token);\n            }\n        }\n        else {\n            streamedOutputValue = token;\n        }\n        const patch = new RunLogPatch({\n            ops: [\n                {\n                    op: \"add\",\n                    path: `/logs/${runName}/streamed_output_str/-`,\n                    value: token,\n                },\n                {\n                    op: \"add\",\n                    path: `/logs/${runName}/streamed_output/-`,\n                    value: streamedOutputValue,\n                },\n            ],\n        });\n        await this.writer.write(patch);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL2xvZ19zdHJlYW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFnRTtBQUN6QjtBQUNxQjtBQUNOO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkVBQVUsR0FBRztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyRUFBVTtBQUNqQyw0QkFBNEIsbURBQW1EO0FBQy9FO0FBQ0E7QUFDQSx1QkFBdUIsMkVBQVUsR0FBRztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx1Q0FBdUMsZ0RBQVU7QUFDeEQ7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9FQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxJQUFJO0FBQ25EO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUyxHQUFHLE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQkFBMkI7QUFDOUQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNENBQTRDLEtBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw4REFBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdHJhY2Vyc1xcbG9nX3N0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcHBseVBhdGNoLCB9IGZyb20gXCIuLi91dGlscy9mYXN0LWpzb24tcGF0Y2gvaW5kZXguanNcIjtcbmltcG9ydCB7IEJhc2VUcmFjZXIgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIH0gZnJvbSBcIi4uL3V0aWxzL3N0cmVhbS5qc1wiO1xuaW1wb3J0IHsgQUlNZXNzYWdlQ2h1bmsgfSBmcm9tIFwiLi4vbWVzc2FnZXMvaW5kZXguanNcIjtcbi8qKlxuICogTGlzdCBvZiBqc29ucGF0Y2ggSlNPTlBhdGNoT3BlcmF0aW9ucywgd2hpY2ggZGVzY3JpYmUgaG93IHRvIGNyZWF0ZSB0aGUgcnVuIHN0YXRlXG4gKiBmcm9tIGFuIGVtcHR5IGRpY3QuIFRoaXMgaXMgdGhlIG1pbmltYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxvZywgZGVzaWduZWQgdG9cbiAqIGJlIHNlcmlhbGl6ZWQgYXMgSlNPTiBhbmQgc2VudCBvdmVyIHRoZSB3aXJlIHRvIHJlY29uc3RydWN0IHRoZSBsb2cgb24gdGhlIG90aGVyXG4gKiBzaWRlLiBSZWNvbnN0cnVjdGlvbiBvZiB0aGUgc3RhdGUgY2FuIGJlIGRvbmUgd2l0aCBhbnkganNvbnBhdGNoLWNvbXBsaWFudCBsaWJyYXJ5LFxuICogc2VlIGh0dHBzOi8vanNvbnBhdGNoLmNvbSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bkxvZ1BhdGNoIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3BzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3BzID0gZmllbGRzLm9wcyA/PyBbXTtcbiAgICB9XG4gICAgY29uY2F0KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IG9wcyA9IHRoaXMub3BzLmNvbmNhdChvdGhlci5vcHMpO1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSBhcHBseVBhdGNoKHt9LCBvcHMpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVuTG9nKHtcbiAgICAgICAgICAgIG9wcyxcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZXNbc3RhdGVzLmxlbmd0aCAtIDFdLm5ld0RvY3VtZW50LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUnVuTG9nIGV4dGVuZHMgUnVuTG9nUGF0Y2gge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXRlID0gZmllbGRzLnN0YXRlO1xuICAgIH1cbiAgICBjb25jYXQob3RoZXIpIHtcbiAgICAgICAgY29uc3Qgb3BzID0gdGhpcy5vcHMuY29uY2F0KG90aGVyLm9wcyk7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGFwcGx5UGF0Y2godGhpcy5zdGF0ZSwgb3RoZXIub3BzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5Mb2coeyBvcHMsIHN0YXRlOiBzdGF0ZXNbc3RhdGVzLmxlbmd0aCAtIDFdLm5ld0RvY3VtZW50IH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJ1bkxvZ1BhdGNoKHBhdGNoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGFwcGx5UGF0Y2goe30sIHBhdGNoLm9wcyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5Mb2coe1xuICAgICAgICAgICAgb3BzOiBwYXRjaC5vcHMsXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGVzW3N0YXRlcy5sZW5ndGggLSAxXS5uZXdEb2N1bWVudCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBFeHRyYWN0IHN0YW5kYXJkaXplZCBpbnB1dHMgZnJvbSBhIHJ1bi5cbiAqXG4gKiBTdGFuZGFyZGl6ZXMgdGhlIGlucHV0cyBiYXNlZCBvbiB0aGUgdHlwZSBvZiB0aGUgcnVubmFibGUgdXNlZC5cbiAqXG4gKiBAcGFyYW0gcnVuIC0gUnVuIG9iamVjdFxuICogQHBhcmFtIHNjaGVtYUZvcm1hdCAtIFRoZSBzY2hlbWEgZm9ybWF0IHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJucyBWYWxpZCBpbnB1dHMgYXJlIG9ubHkgZGljdC4gQnkgY29udmVudGlvbnMsIGlucHV0cyBhbHdheXMgcmVwcmVzZW50ZWRcbiAqIGludm9jYXRpb24gdXNpbmcgbmFtZWQgYXJndW1lbnRzLlxuICogQSBudWxsIG1lYW5zIHRoYXQgdGhlIGlucHV0IGlzIG5vdCB5ZXQga25vd24hXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9nZXRTdGFuZGFyZGl6ZWRJbnB1dHMocnVuLCBzY2hlbWFGb3JtYXQpIHtcbiAgICBpZiAoc2NoZW1hRm9ybWF0ID09PSBcIm9yaWdpbmFsXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG8gbm90IGFzc2lnbiBpbnB1dHMgd2l0aCBvcmlnaW5hbCBzY2hlbWEgZHJvcCB0aGUga2V5IGZvciBub3cuIFwiICtcbiAgICAgICAgICAgIFwiV2hlbiBpbnB1dHMgYXJlIGFkZGVkIHRvIHN0cmVhbUxvZyB0aGV5IHNob3VsZCBiZSBhZGRlZCB3aXRoIFwiICtcbiAgICAgICAgICAgIFwic3RhbmRhcmRpemVkIHNjaGVtYSBmb3Igc3RyZWFtaW5nIGV2ZW50cy5cIik7XG4gICAgfVxuICAgIGNvbnN0IHsgaW5wdXRzIH0gPSBydW47XG4gICAgaWYgKFtcInJldHJpZXZlclwiLCBcImxsbVwiLCBcInByb21wdFwiXS5pbmNsdWRlcyhydW4ucnVuX3R5cGUpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dHM7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhpbnB1dHMpLmxlbmd0aCA9PT0gMSAmJiBpbnB1dHM/LmlucHV0ID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIG5ldyBzdHlsZSBjaGFpbnNcbiAgICAvLyBUaGVzZSBuZXN0IGFuIGFkZGl0aW9uYWwgJ2lucHV0JyBrZXkgaW5zaWRlIHRoZSAnaW5wdXRzJyB0byBtYWtlIHN1cmVcbiAgICAvLyB0aGUgaW5wdXQgaXMgYWx3YXlzIGEgZGljdC4gV2UgbmVlZCB0byB1bnBhY2sgYW5kIHVzZXIgdGhlIGlubmVyIHZhbHVlLlxuICAgIC8vIFdlIHNob3VsZCB0cnkgdG8gZml4IHRoaXMgaW4gUnVubmFibGVzIGFuZCBjYWxsYmFja3MvdHJhY2Vyc1xuICAgIC8vIFJ1bm5hYmxlcyBzaG91bGQgYmUgdXNpbmcgYSBudWxsIHR5cGUgaGVyZSBub3QgYSBwbGFjZWhvbGRlclxuICAgIC8vIGRpY3QuXG4gICAgcmV0dXJuIGlucHV0cy5pbnB1dDtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9nZXRTdGFuZGFyZGl6ZWRPdXRwdXRzKHJ1biwgc2NoZW1hRm9ybWF0KSB7XG4gICAgY29uc3QgeyBvdXRwdXRzIH0gPSBydW47XG4gICAgaWYgKHNjaGVtYUZvcm1hdCA9PT0gXCJvcmlnaW5hbFwiKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgb2xkIHNjaGVtYSwgd2l0aG91dCBzdGFuZGFyZGl6aW5nIGFueXRoaW5nXG4gICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgIH1cbiAgICBpZiAoW1wicmV0cmlldmVyXCIsIFwibGxtXCIsIFwicHJvbXB0XCJdLmluY2x1ZGVzKHJ1bi5ydW5fdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfVxuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIGhhY2t5IGNoZWNrXG4gICAgaWYgKG91dHB1dHMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBPYmplY3Qua2V5cyhvdXRwdXRzKS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgb3V0cHV0cz8ub3V0cHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dHMub3V0cHV0O1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0cztcbn1cbmZ1bmN0aW9uIGlzQ2hhdEdlbmVyYXRpb25DaHVuayh4KSB7XG4gICAgcmV0dXJuIHggIT09IHVuZGVmaW5lZCAmJiB4Lm1lc3NhZ2UgIT09IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogQ2xhc3MgdGhhdCBleHRlbmRzIHRoZSBgQmFzZVRyYWNlcmAgY2xhc3MgZnJvbSB0aGVcbiAqIGBsYW5nY2hhaW4uY2FsbGJhY2tzLnRyYWNlcnMuYmFzZWAgbW9kdWxlLiBJdCByZXByZXNlbnRzIGEgY2FsbGJhY2tcbiAqIGhhbmRsZXIgdGhhdCBsb2dzIHRoZSBleGVjdXRpb24gb2YgcnVucyBhbmQgZW1pdHMgYFJ1bkxvZ2AgaW5zdGFuY2VzIHRvIGFcbiAqIGBSdW5Mb2dTdHJlYW1gLlxuICovXG5leHBvcnQgY2xhc3MgTG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyIGV4dGVuZHMgQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKHsgX2F3YWl0SGFuZGxlcjogdHJ1ZSwgLi4uZmllbGRzIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQ2xvc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVOYW1lc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlVHlwZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZU5hbWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVUeXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2NoZW1hRm9ybWF0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIm9yaWdpbmFsXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJvb3RJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrZXlNYXBCeVJ1bklkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY291bnRlck1hcEJ5UnVuTmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zZm9ybVN0cmVhbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3cml0ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVjZWl2ZVN0cmVhbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImxvZ19zdHJlYW1fdHJhY2VyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXV0b0Nsb3NlID0gZmllbGRzPy5hdXRvQ2xvc2UgPz8gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbmNsdWRlTmFtZXMgPSBmaWVsZHM/LmluY2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5pbmNsdWRlVHlwZXMgPSBmaWVsZHM/LmluY2x1ZGVUeXBlcztcbiAgICAgICAgdGhpcy5pbmNsdWRlVGFncyA9IGZpZWxkcz8uaW5jbHVkZVRhZ3M7XG4gICAgICAgIHRoaXMuZXhjbHVkZU5hbWVzID0gZmllbGRzPy5leGNsdWRlTmFtZXM7XG4gICAgICAgIHRoaXMuZXhjbHVkZVR5cGVzID0gZmllbGRzPy5leGNsdWRlVHlwZXM7XG4gICAgICAgIHRoaXMuZXhjbHVkZVRhZ3MgPSBmaWVsZHM/LmV4Y2x1ZGVUYWdzO1xuICAgICAgICB0aGlzLl9zY2hlbWFGb3JtYXQgPSBmaWVsZHM/Ll9zY2hlbWFGb3JtYXQgPz8gdGhpcy5fc2NoZW1hRm9ybWF0O1xuICAgICAgICB0aGlzLnRyYW5zZm9ybVN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oKTtcbiAgICAgICAgdGhpcy53cml0ZXIgPSB0aGlzLnRyYW5zZm9ybVN0cmVhbS53cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlU3RyZWFtID0gSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW0odGhpcy50cmFuc2Zvcm1TdHJlYW0ucmVhZGFibGUpO1xuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlU3RyZWFtO1xuICAgIH1cbiAgICBhc3luYyBwZXJzaXN0UnVuKF9ydW4pIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGxlZ2FjeSBtZXRob2Qgb25seSBjYWxsZWQgb25jZSBmb3IgYW4gZW50aXJlIHJ1biB0cmVlXG4gICAgICAgIC8vIGFuZCBpcyB0aGVyZWZvcmUgbm90IHVzZWZ1bCBoZXJlXG4gICAgfVxuICAgIF9pbmNsdWRlUnVuKHJ1bikge1xuICAgICAgICBpZiAocnVuLmlkID09PSB0aGlzLnJvb3RJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ1blRhZ3MgPSBydW4udGFncyA/PyBbXTtcbiAgICAgICAgbGV0IGluY2x1ZGUgPSB0aGlzLmluY2x1ZGVOYW1lcyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVR5cGVzID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSB8fCB0aGlzLmluY2x1ZGVOYW1lcy5pbmNsdWRlcyhydW4ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZVR5cGVzLmluY2x1ZGVzKHJ1bi5ydW5fdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVRhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9XG4gICAgICAgICAgICAgICAgaW5jbHVkZSB8fFxuICAgICAgICAgICAgICAgICAgICBydW5UYWdzLmZpbmQoKHRhZykgPT4gdGhpcy5pbmNsdWRlVGFncz8uaW5jbHVkZXModGFnKSkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgJiYgIXRoaXMuZXhjbHVkZU5hbWVzLmluY2x1ZGVzKHJ1bi5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlVHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgJiYgIXRoaXMuZXhjbHVkZVR5cGVzLmluY2x1ZGVzKHJ1bi5ydW5fdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZVRhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9XG4gICAgICAgICAgICAgICAgaW5jbHVkZSAmJiBydW5UYWdzLmV2ZXJ5KCh0YWcpID0+ICF0aGlzLmV4Y2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICB9XG4gICAgYXN5bmMgKnRhcE91dHB1dEl0ZXJhYmxlKHJ1bklkLCBvdXRwdXQpIHtcbiAgICAgICAgLy8gVGFwIGFuIG91dHB1dCBhc3luYyBpdGVyYXRvciB0byBzdHJlYW0gaXRzIHZhbHVlcyB0byB0aGUgbG9nLlxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIG91dHB1dCkge1xuICAgICAgICAgICAgLy8gcm9vdCBydW4gaXMgaGFuZGxlZCBpbiAuc3RyZWFtTG9nKClcbiAgICAgICAgICAgIGlmIChydW5JZCAhPT0gdGhpcy5yb290SWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBydW4gc2lsZW50bHkgaWdub3JlXG4gICAgICAgICAgICAgICAgLy8gZWcuIGJlY2F1c2UgdGhpcyBydW4gd2Fzbid0IGluY2x1ZGVkIGluIHRoZSBsb2dcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmtleU1hcEJ5UnVuSWRbcnVuSWRdO1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUobmV3IFJ1bkxvZ1BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke2tleX0vc3RyZWFtZWRfb3V0cHV0Ly1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBvblJ1bkNyZWF0ZShydW4pIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdElkID0gcnVuLmlkO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUobmV3IFJ1bkxvZ1BhdGNoKHtcbiAgICAgICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBydW4ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBydW4ucnVuX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtZWRfb3V0cHV0OiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbF9vdXRwdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2luY2x1ZGVSdW4ocnVuKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvdW50ZXJNYXBCeVJ1bk5hbWVbcnVuLm5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnRlck1hcEJ5UnVuTmFtZVtydW4ubmFtZV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY291bnRlck1hcEJ5UnVuTmFtZVtydW4ubmFtZV0gKz0gMTtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmNvdW50ZXJNYXBCeVJ1bk5hbWVbcnVuLm5hbWVdO1xuICAgICAgICB0aGlzLmtleU1hcEJ5UnVuSWRbcnVuLmlkXSA9XG4gICAgICAgICAgICBjb3VudCA9PT0gMSA/IHJ1bi5uYW1lIDogYCR7cnVuLm5hbWV9OiR7Y291bnR9YDtcbiAgICAgICAgY29uc3QgbG9nRW50cnkgPSB7XG4gICAgICAgICAgICBpZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiBydW4ucnVuX3R5cGUsXG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW4uZXh0cmE/Lm1ldGFkYXRhID8/IHt9LFxuICAgICAgICAgICAgc3RhcnRfdGltZTogbmV3IERhdGUocnVuLnN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBzdHJlYW1lZF9vdXRwdXQ6IFtdLFxuICAgICAgICAgICAgc3RyZWFtZWRfb3V0cHV0X3N0cjogW10sXG4gICAgICAgICAgICBmaW5hbF9vdXRwdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVuZF90aW1lOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9zY2hlbWFGb3JtYXQgPT09IFwic3RyZWFtaW5nX2V2ZW50c1wiKSB7XG4gICAgICAgICAgICBsb2dFbnRyeS5pbnB1dHMgPSBhd2FpdCBfZ2V0U3RhbmRhcmRpemVkSW5wdXRzKHJ1biwgdGhpcy5fc2NoZW1hRm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7dGhpcy5rZXlNYXBCeVJ1bklkW3J1bi5pZF19YCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxvZ0VudHJ5LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIG9uUnVuVXBkYXRlKHJ1bikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcnVuTmFtZSA9IHRoaXMua2V5TWFwQnlSdW5JZFtydW4uaWRdO1xuICAgICAgICAgICAgaWYgKHJ1bk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NjaGVtYUZvcm1hdCA9PT0gXCJzdHJlYW1pbmdfZXZlbnRzXCIpIHtcbiAgICAgICAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7cnVuTmFtZX0vaW5wdXRzYCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF3YWl0IF9nZXRTdGFuZGFyZGl6ZWRJbnB1dHMocnVuLCB0aGlzLl9zY2hlbWFGb3JtYXQpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3J1bk5hbWV9L2ZpbmFsX291dHB1dGAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGF3YWl0IF9nZXRTdGFuZGFyZGl6ZWRPdXRwdXRzKHJ1biwgdGhpcy5fc2NoZW1hRm9ybWF0KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJ1bi5lbmRfdGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7cnVuTmFtZX0vZW5kX3RpbWVgLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGF0Y2ggPSBuZXcgUnVuTG9nUGF0Y2goeyBvcHMgfSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShwYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAocnVuLmlkID09PSB0aGlzLnJvb3RJZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGNoID0gbmV3IFJ1bkxvZ1BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IFwiL2ZpbmFsX291dHB1dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhd2FpdCBfZ2V0U3RhbmRhcmRpemVkT3V0cHV0cyhydW4sIHRoaXMuX3NjaGVtYUZvcm1hdCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKHBhdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25MTE1OZXdUb2tlbihydW4sIHRva2VuLCBrd2FyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVuTmFtZSA9IHRoaXMua2V5TWFwQnlSdW5JZFtydW4uaWRdO1xuICAgICAgICBpZiAocnVuTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIGhhY2tcbiAgICAgICAgY29uc3QgaXNDaGF0TW9kZWwgPSBydW4uaW5wdXRzLm1lc3NhZ2VzICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBzdHJlYW1lZE91dHB1dFZhbHVlO1xuICAgICAgICBpZiAoaXNDaGF0TW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChpc0NoYXRHZW5lcmF0aW9uQ2h1bmsoa3dhcmdzPy5jaHVuaykpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1lZE91dHB1dFZhbHVlID0ga3dhcmdzPy5jaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmVhbWVkT3V0cHV0VmFsdWUgPSBuZXcgQUlNZXNzYWdlQ2h1bmsodG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtZWRPdXRwdXRWYWx1ZSA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGNoID0gbmV3IFJ1bkxvZ1BhdGNoKHtcbiAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3J1bk5hbWV9L3N0cmVhbWVkX291dHB1dF9zdHIvLWAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0b2tlbixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3J1bk5hbWV9L3N0cmVhbWVkX291dHB1dC8tYCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0cmVhbWVkT3V0cHV0VmFsdWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShwYXRjaCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/tracers/log_stream.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/tracers/root_listener.js":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/root_listener.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RootListenersTracer: () => (/* binding */ RootListenersTracer)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/core/dist/tracers/base.js\");\n\nclass RootListenersTracer extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseTracer {\n    constructor({ config, onStart, onEnd, onError, }) {\n        super({ _awaitHandler: true });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"RootListenersTracer\"\n        });\n        /** The Run's ID. Type UUID */\n        Object.defineProperty(this, \"rootId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnStart\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnEnd\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnError\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.config = config;\n        this.argOnStart = onStart;\n        this.argOnEnd = onEnd;\n        this.argOnError = onError;\n    }\n    /**\n     * This is a legacy method only called once for an entire run tree\n     * therefore not useful here\n     * @param {Run} _ Not used\n     */\n    persistRun(_) {\n        return Promise.resolve();\n    }\n    async onRunCreate(run) {\n        if (this.rootId) {\n            return;\n        }\n        this.rootId = run.id;\n        if (this.argOnStart) {\n            if (this.argOnStart.length === 1) {\n                await this.argOnStart(run);\n            }\n            else if (this.argOnStart.length === 2) {\n                await this.argOnStart(run, this.config);\n            }\n        }\n    }\n    async onRunUpdate(run) {\n        if (run.id !== this.rootId) {\n            return;\n        }\n        if (!run.error) {\n            if (this.argOnEnd) {\n                if (this.argOnEnd.length === 1) {\n                    await this.argOnEnd(run);\n                }\n                else if (this.argOnEnd.length === 2) {\n                    await this.argOnEnd(run, this.config);\n                }\n            }\n        }\n        else if (this.argOnError) {\n            if (this.argOnError.length === 1) {\n                await this.argOnError(run);\n            }\n            else if (this.argOnError.length === 2) {\n                await this.argOnError(run, this.config);\n            }\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL3Jvb3RfbGlzdGVuZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUM7QUFDaEMsa0NBQWtDLGdEQUFVO0FBQ25ELGtCQUFrQixrQ0FBa0M7QUFDcEQsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdHJhY2Vyc1xccm9vdF9saXN0ZW5lci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlVHJhY2VyIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuZXhwb3J0IGNsYXNzIFJvb3RMaXN0ZW5lcnNUcmFjZXIgZXh0ZW5kcyBCYXNlVHJhY2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNvbmZpZywgb25TdGFydCwgb25FbmQsIG9uRXJyb3IsIH0pIHtcbiAgICAgICAgc3VwZXIoeyBfYXdhaXRIYW5kbGVyOiB0cnVlIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIlJvb3RMaXN0ZW5lcnNUcmFjZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFRoZSBSdW4ncyBJRC4gVHlwZSBVVUlEICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJvb3RJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25maWdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJnT25TdGFydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcmdPbkVuZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcmdPbkVycm9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmFyZ09uU3RhcnQgPSBvblN0YXJ0O1xuICAgICAgICB0aGlzLmFyZ09uRW5kID0gb25FbmQ7XG4gICAgICAgIHRoaXMuYXJnT25FcnJvciA9IG9uRXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBsZWdhY3kgbWV0aG9kIG9ubHkgY2FsbGVkIG9uY2UgZm9yIGFuIGVudGlyZSBydW4gdHJlZVxuICAgICAqIHRoZXJlZm9yZSBub3QgdXNlZnVsIGhlcmVcbiAgICAgKiBAcGFyYW0ge1J1bn0gXyBOb3QgdXNlZFxuICAgICAqL1xuICAgIHBlcnNpc3RSdW4oXykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGFzeW5jIG9uUnVuQ3JlYXRlKHJ1bikge1xuICAgICAgICBpZiAodGhpcy5yb290SWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvb3RJZCA9IHJ1bi5pZDtcbiAgICAgICAgaWYgKHRoaXMuYXJnT25TdGFydCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJnT25TdGFydC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFyZ09uU3RhcnQocnVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYXJnT25TdGFydC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFyZ09uU3RhcnQocnVuLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25SdW5VcGRhdGUocnVuKSB7XG4gICAgICAgIGlmIChydW4uaWQgIT09IHRoaXMucm9vdElkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFydW4uZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFyZ09uRW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJnT25FbmQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXJnT25FbmQocnVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hcmdPbkVuZC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcmdPbkVuZChydW4sIHRoaXMuY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcmdPbkVycm9yKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcmdPbkVycm9yLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXJnT25FcnJvcihydW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hcmdPbkVycm9yLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXJnT25FcnJvcihydW4sIHRoaXMuY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/tracers/root_listener.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/tracer_langchain.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LangChainTracer: () => (/* binding */ LangChainTracer)\n/* harmony export */ });\n/* harmony import */ var langsmith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! langsmith */ \"(action-browser)/./node_modules/langsmith/index.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/env.js */ \"(action-browser)/./node_modules/@langchain/core/dist/utils/env.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/core/dist/tracers/base.js\");\n\n\n\nclass LangChainTracer extends _base_js__WEBPACK_IMPORTED_MODULE_2__.BaseTracer {\n    constructor(fields = {}) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"langchain_tracer\"\n        });\n        Object.defineProperty(this, \"projectName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"exampleId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const { exampleId, projectName, client } = fields;\n        this.projectName =\n            projectName ??\n                (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_1__.getEnvironmentVariable)(\"LANGCHAIN_PROJECT\") ??\n                (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_1__.getEnvironmentVariable)(\"LANGCHAIN_SESSION\");\n        this.exampleId = exampleId;\n        this.client = client ?? new langsmith__WEBPACK_IMPORTED_MODULE_0__.Client({});\n    }\n    async _convertToCreate(run, example_id = undefined) {\n        return {\n            ...run,\n            extra: {\n                ...run.extra,\n                runtime: await (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_1__.getRuntimeEnvironment)(),\n            },\n            child_runs: undefined,\n            session_name: this.projectName,\n            reference_example_id: run.parent_run_id ? undefined : example_id,\n        };\n    }\n    async persistRun(_run) { }\n    async onRunCreate(run) {\n        const persistedRun = await this._convertToCreate(run, this.exampleId);\n        await this.client.createRun(persistedRun);\n    }\n    async onRunUpdate(run) {\n        const runUpdate = {\n            end_time: run.end_time,\n            error: run.error,\n            outputs: run.outputs,\n            events: run.events,\n            inputs: run.inputs,\n            trace_id: run.trace_id,\n            dotted_order: run.dotted_order,\n            parent_run_id: run.parent_run_id,\n        };\n        await this.client.updateRun(run.id, runUpdate);\n    }\n    getRun(id) {\n        return this.runMap.get(id);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL3RyYWNlcl9sYW5nY2hhaW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFtQztBQUM2QztBQUN6QztBQUNoQyw4QkFBOEIsZ0RBQVU7QUFDL0MsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQSxnQkFBZ0IscUVBQXNCO0FBQ3RDLGdCQUFnQixxRUFBc0I7QUFDdEM7QUFDQSxvQ0FBb0MsNkNBQU0sR0FBRztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0VBQXFCO0FBQ3BELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx0cmFjZXJzXFx0cmFjZXJfbGFuZ2NoYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENsaWVudCB9IGZyb20gXCJsYW5nc21pdGhcIjtcbmltcG9ydCB7IGdldEVudmlyb25tZW50VmFyaWFibGUsIGdldFJ1bnRpbWVFbnZpcm9ubWVudCB9IGZyb20gXCIuLi91dGlscy9lbnYuanNcIjtcbmltcG9ydCB7IEJhc2VUcmFjZXIgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5leHBvcnQgY2xhc3MgTGFuZ0NoYWluVHJhY2VyIGV4dGVuZHMgQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzID0ge30pIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJsYW5nY2hhaW5fdHJhY2VyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb2plY3ROYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4YW1wbGVJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBleGFtcGxlSWQsIHByb2plY3ROYW1lLCBjbGllbnQgfSA9IGZpZWxkcztcbiAgICAgICAgdGhpcy5wcm9qZWN0TmFtZSA9XG4gICAgICAgICAgICBwcm9qZWN0TmFtZSA/P1xuICAgICAgICAgICAgICAgIGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fUFJPSkVDVFwiKSA/P1xuICAgICAgICAgICAgICAgIGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fU0VTU0lPTlwiKTtcbiAgICAgICAgdGhpcy5leGFtcGxlSWQgPSBleGFtcGxlSWQ7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50ID8/IG5ldyBDbGllbnQoe30pO1xuICAgIH1cbiAgICBhc3luYyBfY29udmVydFRvQ3JlYXRlKHJ1biwgZXhhbXBsZV9pZCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucnVuLFxuICAgICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgICAgICAuLi5ydW4uZXh0cmEsXG4gICAgICAgICAgICAgICAgcnVudGltZTogYXdhaXQgZ2V0UnVudGltZUVudmlyb25tZW50KCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRfcnVuczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2Vzc2lvbl9uYW1lOiB0aGlzLnByb2plY3ROYW1lLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHJ1bi5wYXJlbnRfcnVuX2lkID8gdW5kZWZpbmVkIDogZXhhbXBsZV9pZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgcGVyc2lzdFJ1bihfcnVuKSB7IH1cbiAgICBhc3luYyBvblJ1bkNyZWF0ZShydW4pIHtcbiAgICAgICAgY29uc3QgcGVyc2lzdGVkUnVuID0gYXdhaXQgdGhpcy5fY29udmVydFRvQ3JlYXRlKHJ1biwgdGhpcy5leGFtcGxlSWQpO1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5jcmVhdGVSdW4ocGVyc2lzdGVkUnVuKTtcbiAgICB9XG4gICAgYXN5bmMgb25SdW5VcGRhdGUocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1blVwZGF0ZSA9IHtcbiAgICAgICAgICAgIGVuZF90aW1lOiBydW4uZW5kX3RpbWUsXG4gICAgICAgICAgICBlcnJvcjogcnVuLmVycm9yLFxuICAgICAgICAgICAgb3V0cHV0czogcnVuLm91dHB1dHMsXG4gICAgICAgICAgICBldmVudHM6IHJ1bi5ldmVudHMsXG4gICAgICAgICAgICBpbnB1dHM6IHJ1bi5pbnB1dHMsXG4gICAgICAgICAgICB0cmFjZV9pZDogcnVuLnRyYWNlX2lkLFxuICAgICAgICAgICAgZG90dGVkX29yZGVyOiBydW4uZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcnVuLnBhcmVudF9ydW5faWQsXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnVwZGF0ZVJ1bihydW4uaWQsIHJ1blVwZGF0ZSk7XG4gICAgfVxuICAgIGdldFJ1bihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5NYXAuZ2V0KGlkKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/tracers/tracer_langchain_v1.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/tracer_langchain_v1.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LangChainTracerV1: () => (/* binding */ LangChainTracerV1)\n/* harmony export */ });\n/* harmony import */ var _messages_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../messages/index.js */ \"(action-browser)/./node_modules/@langchain/core/dist/messages/index.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/env.js */ \"(action-browser)/./node_modules/@langchain/core/dist/utils/env.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/core/dist/tracers/base.js\");\n\n\n\n/** @deprecated Use LangChainTracer instead. */\nclass LangChainTracerV1 extends _base_js__WEBPACK_IMPORTED_MODULE_2__.BaseTracer {\n    constructor() {\n        super();\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"langchain_tracer\"\n        });\n        Object.defineProperty(this, \"endpoint\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_1__.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") || \"http://localhost:1984\"\n        });\n        Object.defineProperty(this, \"headers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                \"Content-Type\": \"application/json\",\n            }\n        });\n        Object.defineProperty(this, \"session\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const apiKey = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_1__.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\");\n        if (apiKey) {\n            this.headers[\"x-api-key\"] = apiKey;\n        }\n    }\n    async newSession(sessionName) {\n        const sessionCreate = {\n            start_time: Date.now(),\n            name: sessionName,\n        };\n        const session = await this.persistSession(sessionCreate);\n        this.session = session;\n        return session;\n    }\n    async loadSession(sessionName) {\n        const endpoint = `${this.endpoint}/sessions?name=${sessionName}`;\n        return this._handleSessionResponse(endpoint);\n    }\n    async loadDefaultSession() {\n        const endpoint = `${this.endpoint}/sessions?name=default`;\n        return this._handleSessionResponse(endpoint);\n    }\n    async convertV2RunToRun(run) {\n        const session = this.session ?? (await this.loadDefaultSession());\n        const serialized = run.serialized;\n        let runResult;\n        if (run.run_type === \"llm\") {\n            const prompts = run.inputs.prompts\n                ? run.inputs.prompts\n                : run.inputs.messages.map((x) => (0,_messages_index_js__WEBPACK_IMPORTED_MODULE_0__.getBufferString)(x));\n            const llmRun = {\n                uuid: run.id,\n                start_time: run.start_time,\n                end_time: run.end_time,\n                execution_order: run.execution_order,\n                child_execution_order: run.child_execution_order,\n                serialized,\n                type: run.run_type,\n                session_id: session.id,\n                prompts,\n                response: run.outputs,\n            };\n            runResult = llmRun;\n        }\n        else if (run.run_type === \"chain\") {\n            const child_runs = await Promise.all(run.child_runs.map((child_run) => this.convertV2RunToRun(child_run)));\n            const chainRun = {\n                uuid: run.id,\n                start_time: run.start_time,\n                end_time: run.end_time,\n                execution_order: run.execution_order,\n                child_execution_order: run.child_execution_order,\n                serialized,\n                type: run.run_type,\n                session_id: session.id,\n                inputs: run.inputs,\n                outputs: run.outputs,\n                child_llm_runs: child_runs.filter((child_run) => child_run.type === \"llm\"),\n                child_chain_runs: child_runs.filter((child_run) => child_run.type === \"chain\"),\n                child_tool_runs: child_runs.filter((child_run) => child_run.type === \"tool\"),\n            };\n            runResult = chainRun;\n        }\n        else if (run.run_type === \"tool\") {\n            const child_runs = await Promise.all(run.child_runs.map((child_run) => this.convertV2RunToRun(child_run)));\n            const toolRun = {\n                uuid: run.id,\n                start_time: run.start_time,\n                end_time: run.end_time,\n                execution_order: run.execution_order,\n                child_execution_order: run.child_execution_order,\n                serialized,\n                type: run.run_type,\n                session_id: session.id,\n                tool_input: run.inputs.input,\n                output: run.outputs?.output,\n                action: JSON.stringify(serialized),\n                child_llm_runs: child_runs.filter((child_run) => child_run.type === \"llm\"),\n                child_chain_runs: child_runs.filter((child_run) => child_run.type === \"chain\"),\n                child_tool_runs: child_runs.filter((child_run) => child_run.type === \"tool\"),\n            };\n            runResult = toolRun;\n        }\n        else {\n            throw new Error(`Unknown run type: ${run.run_type}`);\n        }\n        return runResult;\n    }\n    async persistRun(run) {\n        let endpoint;\n        let v1Run;\n        if (run.run_type !== undefined) {\n            v1Run = await this.convertV2RunToRun(run);\n        }\n        else {\n            v1Run = run;\n        }\n        if (v1Run.type === \"llm\") {\n            endpoint = `${this.endpoint}/llm-runs`;\n        }\n        else if (v1Run.type === \"chain\") {\n            endpoint = `${this.endpoint}/chain-runs`;\n        }\n        else {\n            endpoint = `${this.endpoint}/tool-runs`;\n        }\n        const response = await fetch(endpoint, {\n            method: \"POST\",\n            headers: this.headers,\n            body: JSON.stringify(v1Run),\n        });\n        if (!response.ok) {\n            console.error(`Failed to persist run: ${response.status} ${response.statusText}`);\n        }\n    }\n    async persistSession(sessionCreate) {\n        const endpoint = `${this.endpoint}/sessions`;\n        const response = await fetch(endpoint, {\n            method: \"POST\",\n            headers: this.headers,\n            body: JSON.stringify(sessionCreate),\n        });\n        if (!response.ok) {\n            console.error(`Failed to persist session: ${response.status} ${response.statusText}, using default session.`);\n            return {\n                id: 1,\n                ...sessionCreate,\n            };\n        }\n        return {\n            id: (await response.json()).id,\n            ...sessionCreate,\n        };\n    }\n    async _handleSessionResponse(endpoint) {\n        const response = await fetch(endpoint, {\n            method: \"GET\",\n            headers: this.headers,\n        });\n        let tracerSession;\n        if (!response.ok) {\n            console.error(`Failed to load session: ${response.status} ${response.statusText}`);\n            tracerSession = {\n                id: 1,\n                start_time: Date.now(),\n            };\n            this.session = tracerSession;\n            return tracerSession;\n        }\n        const resp = (await response.json());\n        if (resp.length === 0) {\n            tracerSession = {\n                id: 1,\n                start_time: Date.now(),\n            };\n            this.session = tracerSession;\n            return tracerSession;\n        }\n        [tracerSession] = resp;\n        this.session = tracerSession;\n        return tracerSession;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL3RyYWNlcl9sYW5nY2hhaW5fdjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF1RDtBQUNFO0FBQ2xCO0FBQ3ZDO0FBQ08sZ0NBQWdDLGdEQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFFQUFzQjtBQUN6QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx1QkFBdUIscUVBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYyxpQkFBaUIsWUFBWTtBQUN2RTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsbUVBQWU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGFBQWE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvREFBb0QsaUJBQWlCLEVBQUUsb0JBQW9CO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0RBQXdELGlCQUFpQixFQUFFLG9CQUFvQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxREFBcUQsaUJBQWlCLEVBQUUsb0JBQW9CO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHRyYWNlcnNcXHRyYWNlcl9sYW5nY2hhaW5fdjEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QnVmZmVyU3RyaW5nIH0gZnJvbSBcIi4uL21lc3NhZ2VzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4uL3V0aWxzL2Vudi5qc1wiO1xuaW1wb3J0IHsgQmFzZVRyYWNlciB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgTGFuZ0NoYWluVHJhY2VyIGluc3RlYWQuICovXG5leHBvcnQgY2xhc3MgTGFuZ0NoYWluVHJhY2VyVjEgZXh0ZW5kcyBCYXNlVHJhY2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJsYW5nY2hhaW5fdHJhY2VyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuZHBvaW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0VORFBPSU5UXCIpIHx8IFwiaHR0cDovL2xvY2FsaG9zdDoxOTg0XCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhlYWRlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlc3Npb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9BUElfS0VZXCIpO1xuICAgICAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNbXCJ4LWFwaS1rZXlcIl0gPSBhcGlLZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbmV3U2Vzc2lvbihzZXNzaW9uTmFtZSkge1xuICAgICAgICBjb25zdCBzZXNzaW9uQ3JlYXRlID0ge1xuICAgICAgICAgICAgc3RhcnRfdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIG5hbWU6IHNlc3Npb25OYW1lLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgdGhpcy5wZXJzaXN0U2Vzc2lvbihzZXNzaW9uQ3JlYXRlKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgfVxuICAgIGFzeW5jIGxvYWRTZXNzaW9uKHNlc3Npb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy5lbmRwb2ludH0vc2Vzc2lvbnM/bmFtZT0ke3Nlc3Npb25OYW1lfWA7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVTZXNzaW9uUmVzcG9uc2UoZW5kcG9pbnQpO1xuICAgIH1cbiAgICBhc3luYyBsb2FkRGVmYXVsdFNlc3Npb24oKSB7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy5lbmRwb2ludH0vc2Vzc2lvbnM/bmFtZT1kZWZhdWx0YDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVNlc3Npb25SZXNwb25zZShlbmRwb2ludCk7XG4gICAgfVxuICAgIGFzeW5jIGNvbnZlcnRWMlJ1blRvUnVuKHJ1bikge1xuICAgICAgICBjb25zdCBzZXNzaW9uID0gdGhpcy5zZXNzaW9uID8/IChhd2FpdCB0aGlzLmxvYWREZWZhdWx0U2Vzc2lvbigpKTtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHJ1bi5zZXJpYWxpemVkO1xuICAgICAgICBsZXQgcnVuUmVzdWx0O1xuICAgICAgICBpZiAocnVuLnJ1bl90eXBlID09PSBcImxsbVwiKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9tcHRzID0gcnVuLmlucHV0cy5wcm9tcHRzXG4gICAgICAgICAgICAgICAgPyBydW4uaW5wdXRzLnByb21wdHNcbiAgICAgICAgICAgICAgICA6IHJ1bi5pbnB1dHMubWVzc2FnZXMubWFwKCh4KSA9PiBnZXRCdWZmZXJTdHJpbmcoeCkpO1xuICAgICAgICAgICAgY29uc3QgbGxtUnVuID0ge1xuICAgICAgICAgICAgICAgIHV1aWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgICAgICBzdGFydF90aW1lOiBydW4uc3RhcnRfdGltZSxcbiAgICAgICAgICAgICAgICBlbmRfdGltZTogcnVuLmVuZF90aW1lLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcjogcnVuLmV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IHJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBydW4ucnVuX3R5cGUsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbl9pZDogc2Vzc2lvbi5pZCxcbiAgICAgICAgICAgICAgICBwcm9tcHRzLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBydW4ub3V0cHV0cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBydW5SZXN1bHQgPSBsbG1SdW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVuLnJ1bl90eXBlID09PSBcImNoYWluXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkX3J1bnMgPSBhd2FpdCBQcm9taXNlLmFsbChydW4uY2hpbGRfcnVucy5tYXAoKGNoaWxkX3J1bikgPT4gdGhpcy5jb252ZXJ0VjJSdW5Ub1J1bihjaGlsZF9ydW4pKSk7XG4gICAgICAgICAgICBjb25zdCBjaGFpblJ1biA9IHtcbiAgICAgICAgICAgICAgICB1dWlkOiBydW4uaWQsXG4gICAgICAgICAgICAgICAgc3RhcnRfdGltZTogcnVuLnN0YXJ0X3RpbWUsXG4gICAgICAgICAgICAgICAgZW5kX3RpbWU6IHJ1bi5lbmRfdGltZSxcbiAgICAgICAgICAgICAgICBleGVjdXRpb25fb3JkZXI6IHJ1bi5leGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBydW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQsXG4gICAgICAgICAgICAgICAgdHlwZTogcnVuLnJ1bl90eXBlLFxuICAgICAgICAgICAgICAgIHNlc3Npb25faWQ6IHNlc3Npb24uaWQsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBydW4uaW5wdXRzLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IHJ1bi5vdXRwdXRzLFxuICAgICAgICAgICAgICAgIGNoaWxkX2xsbV9ydW5zOiBjaGlsZF9ydW5zLmZpbHRlcigoY2hpbGRfcnVuKSA9PiBjaGlsZF9ydW4udHlwZSA9PT0gXCJsbG1cIiksXG4gICAgICAgICAgICAgICAgY2hpbGRfY2hhaW5fcnVuczogY2hpbGRfcnVucy5maWx0ZXIoKGNoaWxkX3J1bikgPT4gY2hpbGRfcnVuLnR5cGUgPT09IFwiY2hhaW5cIiksXG4gICAgICAgICAgICAgICAgY2hpbGRfdG9vbF9ydW5zOiBjaGlsZF9ydW5zLmZpbHRlcigoY2hpbGRfcnVuKSA9PiBjaGlsZF9ydW4udHlwZSA9PT0gXCJ0b29sXCIpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJ1blJlc3VsdCA9IGNoYWluUnVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bi5ydW5fdHlwZSA9PT0gXCJ0b29sXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkX3J1bnMgPSBhd2FpdCBQcm9taXNlLmFsbChydW4uY2hpbGRfcnVucy5tYXAoKGNoaWxkX3J1bikgPT4gdGhpcy5jb252ZXJ0VjJSdW5Ub1J1bihjaGlsZF9ydW4pKSk7XG4gICAgICAgICAgICBjb25zdCB0b29sUnVuID0ge1xuICAgICAgICAgICAgICAgIHV1aWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgICAgICBzdGFydF90aW1lOiBydW4uc3RhcnRfdGltZSxcbiAgICAgICAgICAgICAgICBlbmRfdGltZTogcnVuLmVuZF90aW1lLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcjogcnVuLmV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IHJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBydW4ucnVuX3R5cGUsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbl9pZDogc2Vzc2lvbi5pZCxcbiAgICAgICAgICAgICAgICB0b29sX2lucHV0OiBydW4uaW5wdXRzLmlucHV0LFxuICAgICAgICAgICAgICAgIG91dHB1dDogcnVuLm91dHB1dHM/Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBhY3Rpb246IEpTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZWQpLFxuICAgICAgICAgICAgICAgIGNoaWxkX2xsbV9ydW5zOiBjaGlsZF9ydW5zLmZpbHRlcigoY2hpbGRfcnVuKSA9PiBjaGlsZF9ydW4udHlwZSA9PT0gXCJsbG1cIiksXG4gICAgICAgICAgICAgICAgY2hpbGRfY2hhaW5fcnVuczogY2hpbGRfcnVucy5maWx0ZXIoKGNoaWxkX3J1bikgPT4gY2hpbGRfcnVuLnR5cGUgPT09IFwiY2hhaW5cIiksXG4gICAgICAgICAgICAgICAgY2hpbGRfdG9vbF9ydW5zOiBjaGlsZF9ydW5zLmZpbHRlcigoY2hpbGRfcnVuKSA9PiBjaGlsZF9ydW4udHlwZSA9PT0gXCJ0b29sXCIpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJ1blJlc3VsdCA9IHRvb2xSdW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcnVuIHR5cGU6ICR7cnVuLnJ1bl90eXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW5SZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHBlcnNpc3RSdW4ocnVuKSB7XG4gICAgICAgIGxldCBlbmRwb2ludDtcbiAgICAgICAgbGV0IHYxUnVuO1xuICAgICAgICBpZiAocnVuLnJ1bl90eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHYxUnVuID0gYXdhaXQgdGhpcy5jb252ZXJ0VjJSdW5Ub1J1bihydW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdjFSdW4gPSBydW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYxUnVuLnR5cGUgPT09IFwibGxtXCIpIHtcbiAgICAgICAgICAgIGVuZHBvaW50ID0gYCR7dGhpcy5lbmRwb2ludH0vbGxtLXJ1bnNgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYxUnVuLnR5cGUgPT09IFwiY2hhaW5cIikge1xuICAgICAgICAgICAgZW5kcG9pbnQgPSBgJHt0aGlzLmVuZHBvaW50fS9jaGFpbi1ydW5zYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZHBvaW50ID0gYCR7dGhpcy5lbmRwb2ludH0vdG9vbC1ydW5zYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodjFSdW4pLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHBlcnNpc3QgcnVuOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBlcnNpc3RTZXNzaW9uKHNlc3Npb25DcmVhdGUpIHtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLmVuZHBvaW50fS9zZXNzaW9uc2A7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShzZXNzaW9uQ3JlYXRlKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwZXJzaXN0IHNlc3Npb246ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9LCB1c2luZyBkZWZhdWx0IHNlc3Npb24uYCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgICAgIC4uLnNlc3Npb25DcmVhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogKGF3YWl0IHJlc3BvbnNlLmpzb24oKSkuaWQsXG4gICAgICAgICAgICAuLi5zZXNzaW9uQ3JlYXRlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBfaGFuZGxlU2Vzc2lvblJlc3BvbnNlKGVuZHBvaW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB0cmFjZXJTZXNzaW9uO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gbG9hZCBzZXNzaW9uOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICAgICAgdHJhY2VyU2Vzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgICAgICBzdGFydF90aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IHRyYWNlclNlc3Npb247XG4gICAgICAgICAgICByZXR1cm4gdHJhY2VyU2Vzc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwID0gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSk7XG4gICAgICAgIGlmIChyZXNwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdHJhY2VyU2Vzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgICAgICBzdGFydF90aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IHRyYWNlclNlc3Npb247XG4gICAgICAgICAgICByZXR1cm4gdHJhY2VyU2Vzc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBbdHJhY2VyU2Vzc2lvbl0gPSByZXNwO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSB0cmFjZXJTZXNzaW9uO1xuICAgICAgICByZXR1cm4gdHJhY2VyU2Vzc2lvbjtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/tracers/tracer_langchain_v1.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/utils/async_caller.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/async_caller.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(action-browser)/./node_modules/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(action-browser)/./node_modules/p-queue/dist/index.js\");\n\n\nconst STATUS_NO_RETRY = [\n    400,\n    401,\n    402,\n    403,\n    404,\n    405,\n    406,\n    407,\n    409, // Conflict\n];\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst defaultFailedAttemptHandler = (error) => {\n    if (error.message.startsWith(\"Cancel\") ||\n        error.message.startsWith(\"AbortError\") ||\n        error.name === \"AbortError\") {\n        throw error;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (error?.code === \"ECONNABORTED\") {\n        throw error;\n    }\n    const status = \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    error?.response?.status ?? error?.status;\n    if (status && STATUS_NO_RETRY.includes(+status)) {\n        throw error;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (error?.error?.code === \"insufficient_quota\") {\n        const err = new Error(error?.message);\n        err.name = \"InsufficientQuotaError\";\n        throw err;\n    }\n};\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */\nclass AsyncCaller {\n    constructor(params) {\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedAttempt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        this.onFailedAttempt =\n            params.onFailedAttempt ?? defaultFailedAttemptHandler;\n        const PQueue =  true ? p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"] : p_queue__WEBPACK_IMPORTED_MODULE_1__;\n        this.queue = new PQueue({ concurrency: this.maxConcurrency });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        return this.queue.add(() => p_retry__WEBPACK_IMPORTED_MODULE_0__(() => callable(...args).catch((error) => {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (error instanceof Error) {\n                throw error;\n            }\n            else {\n                throw new Error(error);\n            }\n        }), {\n            onFailedAttempt: this.onFailedAttempt,\n            retries: this.maxRetries,\n            randomize: true,\n            // If needed we can change some of the defaults here,\n            // but they're quite sensible.\n        }), { throwOnTimeout: true });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject) => {\n                    options.signal?.addEventListener(\"abort\", () => {\n                        reject(new Error(\"AbortError\"));\n                    });\n                }),\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        return this.call(() => fetch(...args).then((res) => (res.ok ? res : Promise.reject(res))));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9hc3luY19jYWxsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZCO0FBQ0c7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBc0IsR0FBRywrQ0FBaUIsR0FBRyxvQ0FBUztBQUM3RSxrQ0FBa0Msa0NBQWtDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQ0FBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFLLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdXRpbHNcXGFzeW5jX2NhbGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcFJldHJ5IGZyb20gXCJwLXJldHJ5XCI7XG5pbXBvcnQgUFF1ZXVlTW9kIGZyb20gXCJwLXF1ZXVlXCI7XG5jb25zdCBTVEFUVVNfTk9fUkVUUlkgPSBbXG4gICAgNDAwLFxuICAgIDQwMSxcbiAgICA0MDIsXG4gICAgNDAzLFxuICAgIDQwNCxcbiAgICA0MDUsXG4gICAgNDA2LFxuICAgIDQwNyxcbiAgICA0MDksIC8vIENvbmZsaWN0XG5dO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGRlZmF1bHRGYWlsZWRBdHRlbXB0SGFuZGxlciA9IChlcnJvcikgPT4ge1xuICAgIGlmIChlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJDYW5jZWxcIikgfHxcbiAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQWJvcnRFcnJvclwiKSB8fFxuICAgICAgICBlcnJvci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBpZiAoZXJyb3I/LmNvZGUgPT09IFwiRUNPTk5BQk9SVEVEXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IHN0YXR1cyA9IFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZXJyb3I/LnJlc3BvbnNlPy5zdGF0dXMgPz8gZXJyb3I/LnN0YXR1cztcbiAgICBpZiAoc3RhdHVzICYmIFNUQVRVU19OT19SRVRSWS5pbmNsdWRlcygrc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBpZiAoZXJyb3I/LmVycm9yPy5jb2RlID09PSBcImluc3VmZmljaWVudF9xdW90YVwiKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihlcnJvcj8ubWVzc2FnZSk7XG4gICAgICAgIGVyci5uYW1lID0gXCJJbnN1ZmZpY2llbnRRdW90YUVycm9yXCI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59O1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFrZSBhc3luYyBjYWxscyB3aXRoIGNvbmN1cnJlbmN5IGFuZCByZXRyeSBsb2dpYy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgbWFraW5nIGNhbGxzIHRvIGFueSBraW5kIG9mIFwiZXhwZW5zaXZlXCIgZXh0ZXJuYWwgcmVzb3VyY2UsXG4gKiBiZSBpdCBiZWNhdXNlIGl0J3MgcmF0ZS1saW1pdGVkLCBzdWJqZWN0IHRvIG5ldHdvcmsgaXNzdWVzLCBldGMuXG4gKlxuICogQ29uY3VycmVudCBjYWxscyBhcmUgbGltaXRlZCBieSB0aGUgYG1heENvbmN1cnJlbmN5YCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzXG4gKiB0byBgSW5maW5pdHlgLiBUaGlzIG1lYW5zIHRoYXQgYnkgZGVmYXVsdCwgYWxsIGNhbGxzIHdpbGwgYmUgbWFkZSBpbiBwYXJhbGxlbC5cbiAqXG4gKiBSZXRyaWVzIGFyZSBsaW1pdGVkIGJ5IHRoZSBgbWF4UmV0cmllc2AgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0cyB0byA2LiBUaGlzXG4gKiBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGVhY2ggY2FsbCB3aWxsIGJlIHJldHJpZWQgdXAgdG8gNiB0aW1lcywgd2l0aCBhblxuICogZXhwb25lbnRpYWwgYmFja29mZiBiZXR3ZWVuIGVhY2ggYXR0ZW1wdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEFzeW5jQ2FsbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4Q29uY3VycmVuY3lcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4UmV0cmllc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkZhaWxlZEF0dGVtcHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicXVldWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhDb25jdXJyZW5jeSA9IHBhcmFtcy5tYXhDb25jdXJyZW5jeSA/PyBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5tYXhSZXRyaWVzID0gcGFyYW1zLm1heFJldHJpZXMgPz8gNjtcbiAgICAgICAgdGhpcy5vbkZhaWxlZEF0dGVtcHQgPVxuICAgICAgICAgICAgcGFyYW1zLm9uRmFpbGVkQXR0ZW1wdCA/PyBkZWZhdWx0RmFpbGVkQXR0ZW1wdEhhbmRsZXI7XG4gICAgICAgIGNvbnN0IFBRdWV1ZSA9IFwiZGVmYXVsdFwiIGluIFBRdWV1ZU1vZCA/IFBRdWV1ZU1vZC5kZWZhdWx0IDogUFF1ZXVlTW9kO1xuICAgICAgICB0aGlzLnF1ZXVlID0gbmV3IFBRdWV1ZSh7IGNvbmN1cnJlbmN5OiB0aGlzLm1heENvbmN1cnJlbmN5IH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUuYWRkKCgpID0+IHBSZXRyeSgoKSA9PiBjYWxsYWJsZSguLi5hcmdzKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgb25GYWlsZWRBdHRlbXB0OiB0aGlzLm9uRmFpbGVkQXR0ZW1wdCxcbiAgICAgICAgICAgIHJldHJpZXM6IHRoaXMubWF4UmV0cmllcyxcbiAgICAgICAgICAgIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgICAgICAgICAgIC8vIElmIG5lZWRlZCB3ZSBjYW4gY2hhbmdlIHNvbWUgb2YgdGhlIGRlZmF1bHRzIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgdGhleSdyZSBxdWl0ZSBzZW5zaWJsZS5cbiAgICAgICAgfSksIHsgdGhyb3dPblRpbWVvdXQ6IHRydWUgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbFdpdGhPcHRpb25zKG9wdGlvbnMsIGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIE5vdGUgdGhpcyBkb2Vzbid0IGNhbmNlbCB0aGUgdW5kZXJseWluZyByZXF1ZXN0LFxuICAgICAgICAvLyB3aGVuIGF2YWlsYWJsZSBwcmVmZXIgdG8gdXNlIHRoZSBzaWduYWwgb3B0aW9uIG9mIHRoZSB1bmRlcmx5aW5nIGNhbGxcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpLFxuICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQWJvcnRFcnJvclwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbChjYWxsYWJsZSwgLi4uYXJncyk7XG4gICAgfVxuICAgIGZldGNoKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbCgoKSA9PiBmZXRjaCguLi5hcmdzKS50aGVuKChyZXMpID0+IChyZXMub2sgPyByZXMgOiBQcm9taXNlLnJlamVjdChyZXMpKSkpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/utils/async_caller.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/utils/env.js":
/*!********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/env.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnv: () => (/* binding */ getEnv),\n/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable),\n/* harmony export */   getRuntimeEnvironment: () => (/* binding */ getRuntimeEnvironment),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isDeno: () => (/* binding */ isDeno),\n/* harmony export */   isJsDom: () => (/* binding */ isJsDom),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker)\n/* harmony export */ });\nconst isBrowser = () => typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nconst isWebWorker = () => typeof globalThis === \"object\" &&\n    globalThis.constructor &&\n    globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nconst isJsDom = () => (typeof window !== \"undefined\" && window.name === \"nodejs\") ||\n    (typeof navigator !== \"undefined\" &&\n        (navigator.userAgent.includes(\"Node.js\") ||\n            navigator.userAgent.includes(\"jsdom\")));\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nconst isDeno = () => typeof Deno !== \"undefined\";\n// Mark not-as-node if in Supabase Edge Function\nconst isNode = () => typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\" &&\n    !isDeno();\nconst getEnv = () => {\n    let env;\n    if (isBrowser()) {\n        env = \"browser\";\n    }\n    else if (isNode()) {\n        env = \"node\";\n    }\n    else if (isWebWorker()) {\n        env = \"webworker\";\n    }\n    else if (isJsDom()) {\n        env = \"jsdom\";\n    }\n    else if (isDeno()) {\n        env = \"deno\";\n    }\n    else {\n        env = \"other\";\n    }\n    return env;\n};\nlet runtimeEnvironment;\nasync function getRuntimeEnvironment() {\n    if (runtimeEnvironment === undefined) {\n        const env = getEnv();\n        runtimeEnvironment = {\n            library: \"langchain-js\",\n            runtime: env,\n        };\n    }\n    return runtimeEnvironment;\n}\nfunction getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/langchain-ai/langchainjs/issues/1412\n    try {\n        return typeof process !== \"undefined\"\n            ? // eslint-disable-next-line no-process-env\n                process.env?.[name]\n            : undefined;\n    }\n    catch (e) {\n        return undefined;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9lbnYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdXRpbHNcXGVudi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuZXhwb3J0IGNvbnN0IGlzV2ViV29ya2VyID0gKCkgPT4gdHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgJiZcbiAgICBnbG9iYWxUaGlzLmNvbnN0cnVjdG9yICYmXG4gICAgZ2xvYmFsVGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkRlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlXCI7XG5leHBvcnQgY29uc3QgaXNKc0RvbSA9ICgpID0+ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5uYW1lID09PSBcIm5vZGVqc1wiKSB8fFxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIChuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiTm9kZS5qc1wiKSB8fFxuICAgICAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcImpzZG9tXCIpKSk7XG4vLyBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9uIHByb3ZpZGVzIGEgYERlbm9gIGdsb2JhbCBvYmplY3Rcbi8vIHdpdGhvdXQgYHZlcnNpb25gIHByb3BlcnR5XG5leHBvcnQgY29uc3QgaXNEZW5vID0gKCkgPT4gdHlwZW9mIERlbm8gIT09IFwidW5kZWZpbmVkXCI7XG4vLyBNYXJrIG5vdC1hcy1ub2RlIGlmIGluIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb25cbmV4cG9ydCBjb25zdCBpc05vZGUgPSAoKSA9PiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICFpc0Rlbm8oKTtcbmV4cG9ydCBjb25zdCBnZXRFbnYgPSAoKSA9PiB7XG4gICAgbGV0IGVudjtcbiAgICBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgZW52ID0gXCJicm93c2VyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTm9kZSgpKSB7XG4gICAgICAgIGVudiA9IFwibm9kZVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1dlYldvcmtlcigpKSB7XG4gICAgICAgIGVudiA9IFwid2Vid29ya2VyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSnNEb20oKSkge1xuICAgICAgICBlbnYgPSBcImpzZG9tXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGVubygpKSB7XG4gICAgICAgIGVudiA9IFwiZGVub1wiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW52ID0gXCJvdGhlclwiO1xuICAgIH1cbiAgICByZXR1cm4gZW52O1xufTtcbmxldCBydW50aW1lRW52aXJvbm1lbnQ7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UnVudGltZUVudmlyb25tZW50KCkge1xuICAgIGlmIChydW50aW1lRW52aXJvbm1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBlbnYgPSBnZXRFbnYoKTtcbiAgICAgICAgcnVudGltZUVudmlyb25tZW50ID0ge1xuICAgICAgICAgICAgbGlicmFyeTogXCJsYW5nY2hhaW4tanNcIixcbiAgICAgICAgICAgIHJ1bnRpbWU6IGVudixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bnRpbWVFbnZpcm9ubWVudDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKG5hbWUpIHtcbiAgICAvLyBDZXJ0YWluIERlbm8gc2V0dXBzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgeW91IHRyeSB0byBhY2Nlc3MgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xhbmdjaGFpbi1haS9sYW5nY2hhaW5qcy9pc3N1ZXMvMTQxMlxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudj8uW25hbWVdXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/utils/env.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonPatchError: () => (/* reexport safe */ _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.PatchError),\n/* harmony export */   _areEquals: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__._areEquals),\n/* harmony export */   applyOperation: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.applyOperation),\n/* harmony export */   applyPatch: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.applyPatch),\n/* harmony export */   applyReducer: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.applyReducer),\n/* harmony export */   compare: () => (/* reexport safe */ _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__.compare),\n/* harmony export */   deepClone: () => (/* reexport safe */ _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__._deepClone),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   escapePathComponent: () => (/* reexport safe */ _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.escapePathComponent),\n/* harmony export */   generate: () => (/* reexport safe */ _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__.generate),\n/* harmony export */   getValueByPointer: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.getValueByPointer),\n/* harmony export */   observe: () => (/* reexport safe */ _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__.observe),\n/* harmony export */   unescapePathComponent: () => (/* reexport safe */ _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.unescapePathComponent),\n/* harmony export */   unobserve: () => (/* reexport safe */ _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__.unobserve),\n/* harmony export */   validate: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.validate),\n/* harmony export */   validator: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.validator)\n/* harmony export */ });\n/* harmony import */ var _src_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/core.js */ \"(action-browser)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js\");\n/* harmony import */ var _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/duplex.js */ \"(action-browser)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js\");\n/* harmony import */ var _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/helpers.js */ \"(action-browser)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js\");\n\n\n\n/**\n * Default export for backwards compat\n */\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    ..._src_core_js__WEBPACK_IMPORTED_MODULE_0__,\n    // ...duplex,\n    JsonPatchError: _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.PatchError,\n    deepClone: _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__._deepClone,\n    escapePathComponent: _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.escapePathComponent,\n    unescapePathComponent: _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.unescapePathComponent,\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9mYXN0LWpzb24tcGF0Y2gvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QjtBQUNFO0FBQ3NHO0FBQ3RJO0FBQ0E7QUFDQTtBQUNzQztBQUNnRztBQUN0SSxpRUFBZTtBQUNmLE9BQU8seUNBQUk7QUFDWDtBQUNBLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6QixDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx1dGlsc1xcZmFzdC1qc29uLXBhdGNoXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tIFwiLi9zcmMvY29yZS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3JjL2R1cGxleC5qc1wiO1xuZXhwb3J0IHsgUGF0Y2hFcnJvciBhcyBKc29uUGF0Y2hFcnJvciwgX2RlZXBDbG9uZSBhcyBkZWVwQ2xvbmUsIGVzY2FwZVBhdGhDb21wb25lbnQsIHVuZXNjYXBlUGF0aENvbXBvbmVudCwgfSBmcm9tIFwiLi9zcmMvaGVscGVycy5qc1wiO1xuLyoqXG4gKiBEZWZhdWx0IGV4cG9ydCBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5pbXBvcnQgKiBhcyBjb3JlIGZyb20gXCIuL3NyYy9jb3JlLmpzXCI7XG5pbXBvcnQgeyBQYXRjaEVycm9yIGFzIEpzb25QYXRjaEVycm9yLCBfZGVlcENsb25lIGFzIGRlZXBDbG9uZSwgZXNjYXBlUGF0aENvbXBvbmVudCwgdW5lc2NhcGVQYXRoQ29tcG9uZW50LCB9IGZyb20gXCIuL3NyYy9oZWxwZXJzLmpzXCI7XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgLi4uY29yZSxcbiAgICAvLyAuLi5kdXBsZXgsXG4gICAgSnNvblBhdGNoRXJyb3IsXG4gICAgZGVlcENsb25lLFxuICAgIGVzY2FwZVBhdGhDb21wb25lbnQsXG4gICAgdW5lc2NhcGVQYXRoQ29tcG9uZW50LFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonPatchError: () => (/* binding */ JsonPatchError),\n/* harmony export */   _areEquals: () => (/* binding */ _areEquals),\n/* harmony export */   applyOperation: () => (/* binding */ applyOperation),\n/* harmony export */   applyPatch: () => (/* binding */ applyPatch),\n/* harmony export */   applyReducer: () => (/* binding */ applyReducer),\n/* harmony export */   deepClone: () => (/* binding */ deepClone),\n/* harmony export */   getValueByPointer: () => (/* binding */ getValueByPointer),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   validator: () => (/* binding */ validator)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"(action-browser)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js\");\n// @ts-nocheck\n\nconst JsonPatchError = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.PatchError;\nconst deepClone = _helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone;\n/* We use a Javascript hash to store each\n function. Each hash entry (property) uses\n the operation identifiers specified in rfc6902.\n In this way, we can map each patch operation\n to its dedicated function in efficient way.\n */\n/* The operations applicable to an object */\nconst objOps = {\n    add: function (obj, key, document) {\n        obj[key] = this.value;\n        return { newDocument: document };\n    },\n    remove: function (obj, key, document) {\n        var removed = obj[key];\n        delete obj[key];\n        return { newDocument: document, removed };\n    },\n    replace: function (obj, key, document) {\n        var removed = obj[key];\n        obj[key] = this.value;\n        return { newDocument: document, removed };\n    },\n    move: function (obj, key, document) {\n        /* in case move target overwrites an existing value,\n        return the removed value, this can be taxing performance-wise,\n        and is potentially unneeded */\n        let removed = getValueByPointer(document, this.path);\n        if (removed) {\n            removed = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(removed);\n        }\n        const originalValue = applyOperation(document, {\n            op: \"remove\",\n            path: this.from,\n        }).removed;\n        applyOperation(document, {\n            op: \"add\",\n            path: this.path,\n            value: originalValue,\n        });\n        return { newDocument: document, removed };\n    },\n    copy: function (obj, key, document) {\n        const valueToCopy = getValueByPointer(document, this.from);\n        // enforce copy by value so further operations don't affect source (see issue #177)\n        applyOperation(document, {\n            op: \"add\",\n            path: this.path,\n            value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(valueToCopy),\n        });\n        return { newDocument: document };\n    },\n    test: function (obj, key, document) {\n        return { newDocument: document, test: _areEquals(obj[key], this.value) };\n    },\n    _get: function (obj, key, document) {\n        this.value = obj[key];\n        return { newDocument: document };\n    },\n};\n/* The operations applicable to an array. Many are the same as for the object */\nvar arrOps = {\n    add: function (arr, i, document) {\n        if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(i)) {\n            arr.splice(i, 0, this.value);\n        }\n        else {\n            // array props\n            arr[i] = this.value;\n        }\n        // this may be needed when using '-' in an array\n        return { newDocument: document, index: i };\n    },\n    remove: function (arr, i, document) {\n        var removedList = arr.splice(i, 1);\n        return { newDocument: document, removed: removedList[0] };\n    },\n    replace: function (arr, i, document) {\n        var removed = arr[i];\n        arr[i] = this.value;\n        return { newDocument: document, removed };\n    },\n    move: objOps.move,\n    copy: objOps.copy,\n    test: objOps.test,\n    _get: objOps._get,\n};\n/**\n * Retrieves a value from a JSON document by a JSON pointer.\n * Returns the value.\n *\n * @param document The document to get the value from\n * @param pointer an escaped JSON pointer\n * @return The retrieved value\n */\nfunction getValueByPointer(document, pointer) {\n    if (pointer == \"\") {\n        return document;\n    }\n    var getOriginalDestination = { op: \"_get\", path: pointer };\n    applyOperation(document, getOriginalDestination);\n    return getOriginalDestination.value;\n}\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the {newDocument, result} of the operation.\n * It modifies the `document` and `operation` objects - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return `{newDocument, result}` after the operation\n */\nfunction applyOperation(document, operation, validateOperation = false, mutateDocument = true, banPrototypeModifications = true, index = 0) {\n    if (validateOperation) {\n        if (typeof validateOperation == \"function\") {\n            validateOperation(operation, 0, document, operation.path);\n        }\n        else {\n            validator(operation, 0);\n        }\n    }\n    /* ROOT OPERATIONS */\n    if (operation.path === \"\") {\n        let returnValue = { newDocument: document };\n        if (operation.op === \"add\") {\n            returnValue.newDocument = operation.value;\n            return returnValue;\n        }\n        else if (operation.op === \"replace\") {\n            returnValue.newDocument = operation.value;\n            returnValue.removed = document; //document we removed\n            return returnValue;\n        }\n        else if (operation.op === \"move\" || operation.op === \"copy\") {\n            // it's a move or copy to root\n            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field\n            if (operation.op === \"move\") {\n                // report removed item\n                returnValue.removed = document;\n            }\n            return returnValue;\n        }\n        else if (operation.op === \"test\") {\n            returnValue.test = _areEquals(document, operation.value);\n            if (returnValue.test === false) {\n                throw new JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n            }\n            returnValue.newDocument = document;\n            return returnValue;\n        }\n        else if (operation.op === \"remove\") {\n            // a remove on root\n            returnValue.removed = document;\n            returnValue.newDocument = null;\n            return returnValue;\n        }\n        else if (operation.op === \"_get\") {\n            operation.value = document;\n            return returnValue;\n        }\n        else {\n            /* bad operation */\n            if (validateOperation) {\n                throw new JsonPatchError(\"Operation `op` property is not one of operations defined in RFC-6902\", \"OPERATION_OP_INVALID\", index, operation, document);\n            }\n            else {\n                return returnValue;\n            }\n        }\n    } /* END ROOT OPERATIONS */\n    else {\n        if (!mutateDocument) {\n            document = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document);\n        }\n        const path = operation.path || \"\";\n        const keys = path.split(\"/\");\n        let obj = document;\n        let t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift\n        let len = keys.length;\n        let existingPathFragment = undefined;\n        let key;\n        let validateFunction;\n        if (typeof validateOperation == \"function\") {\n            validateFunction = validateOperation;\n        }\n        else {\n            validateFunction = validator;\n        }\n        while (true) {\n            key = keys[t];\n            if (key && key.indexOf(\"~\") != -1) {\n                key = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.unescapePathComponent)(key);\n            }\n            if (banPrototypeModifications &&\n                (key == \"__proto__\" ||\n                    (key == \"prototype\" && t > 0 && keys[t - 1] == \"constructor\"))) {\n                throw new TypeError(\"JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README\");\n            }\n            if (validateOperation) {\n                if (existingPathFragment === undefined) {\n                    if (obj[key] === undefined) {\n                        existingPathFragment = keys.slice(0, t).join(\"/\");\n                    }\n                    else if (t == len - 1) {\n                        existingPathFragment = operation.path;\n                    }\n                    if (existingPathFragment !== undefined) {\n                        validateFunction(operation, 0, document, existingPathFragment);\n                    }\n                }\n            }\n            t++;\n            if (Array.isArray(obj)) {\n                if (key === \"-\") {\n                    key = obj.length;\n                }\n                else {\n                    if (validateOperation && !(0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(key)) {\n                        throw new JsonPatchError(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\", \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\", index, operation, document);\n                    } // only parse key when it's an integer for `arr.prop` to work\n                    else if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(key)) {\n                        key = ~~key;\n                    }\n                }\n                if (t >= len) {\n                    if (validateOperation && operation.op === \"add\" && key > obj.length) {\n                        throw new JsonPatchError(\"The specified index MUST NOT be greater than the number of elements in the array\", \"OPERATION_VALUE_OUT_OF_BOUNDS\", index, operation, document);\n                    }\n                    const returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        throw new JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n            else {\n                if (t >= len) {\n                    const returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        throw new JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n            obj = obj[key];\n            // If we have more keys in the path, but the next value isn't a non-null object,\n            // throw an OPERATION_PATH_UNRESOLVABLE error instead of iterating again.\n            if (validateOperation && t < len && (!obj || typeof obj !== \"object\")) {\n                throw new JsonPatchError(\"Cannot perform operation at the desired path\", \"OPERATION_PATH_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n    }\n}\n/**\n * Apply a full JSON Patch array on a JSON document.\n * Returns the {newDocument, result} of the patch.\n * It modifies the `document` object and `patch` - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.\n *\n * @param document The document to patch\n * @param patch The patch to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return An array of `{newDocument, result}` after the patch\n */\nfunction applyPatch(document, patch, validateOperation, mutateDocument = true, banPrototypeModifications = true) {\n    if (validateOperation) {\n        if (!Array.isArray(patch)) {\n            throw new JsonPatchError(\"Patch sequence must be an array\", \"SEQUENCE_NOT_AN_ARRAY\");\n        }\n    }\n    if (!mutateDocument) {\n        document = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document);\n    }\n    const results = new Array(patch.length);\n    for (let i = 0, length = patch.length; i < length; i++) {\n        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`\n        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);\n        document = results[i].newDocument; // in case root was replaced\n    }\n    results.newDocument = document;\n    return results;\n}\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the updated document.\n * Suitable as a reducer.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @return The updated document\n */\nfunction applyReducer(document, operation, index) {\n    const operationResult = applyOperation(document, operation);\n    if (operationResult.test === false) {\n        // failed test\n        throw new JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n    }\n    return operationResult.newDocument;\n}\n/**\n * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.\n * @param {object} operation - operation object (patch)\n * @param {number} index - index of operation in the sequence\n * @param {object} [document] - object where the operation is supposed to be applied\n * @param {string} [existingPathFragment] - comes along with `document`\n */\nfunction validator(operation, index, document, existingPathFragment) {\n    if (typeof operation !== \"object\" ||\n        operation === null ||\n        Array.isArray(operation)) {\n        throw new JsonPatchError(\"Operation is not an object\", \"OPERATION_NOT_AN_OBJECT\", index, operation, document);\n    }\n    else if (!objOps[operation.op]) {\n        throw new JsonPatchError(\"Operation `op` property is not one of operations defined in RFC-6902\", \"OPERATION_OP_INVALID\", index, operation, document);\n    }\n    else if (typeof operation.path !== \"string\") {\n        throw new JsonPatchError(\"Operation `path` property is not a string\", \"OPERATION_PATH_INVALID\", index, operation, document);\n    }\n    else if (operation.path.indexOf(\"/\") !== 0 && operation.path.length > 0) {\n        // paths that aren't empty string should start with \"/\"\n        throw new JsonPatchError('Operation `path` property must start with \"/\"', \"OPERATION_PATH_INVALID\", index, operation, document);\n    }\n    else if ((operation.op === \"move\" || operation.op === \"copy\") &&\n        typeof operation.from !== \"string\") {\n        throw new JsonPatchError(\"Operation `from` property is not present (applicable in `move` and `copy` operations)\", \"OPERATION_FROM_REQUIRED\", index, operation, document);\n    }\n    else if ((operation.op === \"add\" ||\n        operation.op === \"replace\" ||\n        operation.op === \"test\") &&\n        operation.value === undefined) {\n        throw new JsonPatchError(\"Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)\", \"OPERATION_VALUE_REQUIRED\", index, operation, document);\n    }\n    else if ((operation.op === \"add\" ||\n        operation.op === \"replace\" ||\n        operation.op === \"test\") &&\n        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.hasUndefined)(operation.value)) {\n        throw new JsonPatchError(\"Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)\", \"OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED\", index, operation, document);\n    }\n    else if (document) {\n        if (operation.op == \"add\") {\n            var pathLen = operation.path.split(\"/\").length;\n            var existingPathLen = existingPathFragment.split(\"/\").length;\n            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {\n                throw new JsonPatchError(\"Cannot perform an `add` operation at the desired path\", \"OPERATION_PATH_CANNOT_ADD\", index, operation, document);\n            }\n        }\n        else if (operation.op === \"replace\" ||\n            operation.op === \"remove\" ||\n            operation.op === \"_get\") {\n            if (operation.path !== existingPathFragment) {\n                throw new JsonPatchError(\"Cannot perform the operation at a path that does not exist\", \"OPERATION_PATH_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n        else if (operation.op === \"move\" || operation.op === \"copy\") {\n            var existingValue = {\n                op: \"_get\",\n                path: operation.from,\n                value: undefined,\n            };\n            var error = validate([existingValue], document);\n            if (error && error.name === \"OPERATION_PATH_UNRESOLVABLE\") {\n                throw new JsonPatchError(\"Cannot perform the operation from a path that does not exist\", \"OPERATION_FROM_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n    }\n}\n/**\n * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.\n * If error is encountered, returns a JsonPatchError object\n * @param sequence\n * @param document\n * @returns {JsonPatchError|undefined}\n */\nfunction validate(sequence, document, externalValidator) {\n    try {\n        if (!Array.isArray(sequence)) {\n            throw new JsonPatchError(\"Patch sequence must be an array\", \"SEQUENCE_NOT_AN_ARRAY\");\n        }\n        if (document) {\n            //clone document and sequence so that we can safely try applying operations\n            applyPatch((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document), (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(sequence), externalValidator || true);\n        }\n        else {\n            externalValidator = externalValidator || validator;\n            for (var i = 0; i < sequence.length; i++) {\n                externalValidator(sequence[i], i, document, undefined);\n            }\n        }\n    }\n    catch (e) {\n        if (e instanceof JsonPatchError) {\n            return e;\n        }\n        else {\n            throw e;\n        }\n    }\n}\n// based on https://github.com/epoberezkin/fast-deep-equal\n// MIT License\n// Copyright (c) 2017 Evgeny Poberezkin\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nfunction _areEquals(a, b) {\n    if (a === b)\n        return true;\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;\n        if (arrA && arrB) {\n            length = a.length;\n            if (length != b.length)\n                return false;\n            for (i = length; i-- !== 0;)\n                if (!_areEquals(a[i], b[i]))\n                    return false;\n            return true;\n        }\n        if (arrA != arrB)\n            return false;\n        var keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length)\n            return false;\n        for (i = length; i-- !== 0;)\n            if (!b.hasOwnProperty(keys[i]))\n                return false;\n        for (i = length; i-- !== 0;) {\n            key = keys[i];\n            if (!_areEquals(a[key], b[key]))\n                return false;\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9mYXN0LWpzb24tcGF0Y2gvc3JjL2NvcmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3VHO0FBQ2hHLHVCQUF1QixtREFBVTtBQUNqQyxrQkFBa0IsbURBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdURBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdURBQVU7QUFDN0IsU0FBUztBQUNULGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx1QkFBdUIsdURBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0VBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHNEQUFTO0FBQ3ZEO0FBQ0Esc0JBQXNCO0FBQ3RCLDZCQUE2QixzREFBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1REFBVTtBQUM3QjtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUFVLFlBQVksdURBQVU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx1dGlsc1xcZmFzdC1qc29uLXBhdGNoXFxzcmNcXGNvcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLW5vY2hlY2tcbmltcG9ydCB7IFBhdGNoRXJyb3IsIF9kZWVwQ2xvbmUsIGlzSW50ZWdlciwgdW5lc2NhcGVQYXRoQ29tcG9uZW50LCBoYXNVbmRlZmluZWQsIH0gZnJvbSBcIi4vaGVscGVycy5qc1wiO1xuZXhwb3J0IGNvbnN0IEpzb25QYXRjaEVycm9yID0gUGF0Y2hFcnJvcjtcbmV4cG9ydCBjb25zdCBkZWVwQ2xvbmUgPSBfZGVlcENsb25lO1xuLyogV2UgdXNlIGEgSmF2YXNjcmlwdCBoYXNoIHRvIHN0b3JlIGVhY2hcbiBmdW5jdGlvbi4gRWFjaCBoYXNoIGVudHJ5IChwcm9wZXJ0eSkgdXNlc1xuIHRoZSBvcGVyYXRpb24gaWRlbnRpZmllcnMgc3BlY2lmaWVkIGluIHJmYzY5MDIuXG4gSW4gdGhpcyB3YXksIHdlIGNhbiBtYXAgZWFjaCBwYXRjaCBvcGVyYXRpb25cbiB0byBpdHMgZGVkaWNhdGVkIGZ1bmN0aW9uIGluIGVmZmljaWVudCB3YXkuXG4gKi9cbi8qIFRoZSBvcGVyYXRpb25zIGFwcGxpY2FibGUgdG8gYW4gb2JqZWN0ICovXG5jb25zdCBvYmpPcHMgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIG9ialtrZXldID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBvYmpba2V5XTtcbiAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBvYmpba2V5XTtcbiAgICAgICAgb2JqW2tleV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIG1vdmU6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgLyogaW4gY2FzZSBtb3ZlIHRhcmdldCBvdmVyd3JpdGVzIGFuIGV4aXN0aW5nIHZhbHVlLFxuICAgICAgICByZXR1cm4gdGhlIHJlbW92ZWQgdmFsdWUsIHRoaXMgY2FuIGJlIHRheGluZyBwZXJmb3JtYW5jZS13aXNlLFxuICAgICAgICBhbmQgaXMgcG90ZW50aWFsbHkgdW5uZWVkZWQgKi9cbiAgICAgICAgbGV0IHJlbW92ZWQgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgdGhpcy5wYXRoKTtcbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJlbW92ZWQgPSBfZGVlcENsb25lKHJlbW92ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsVmFsdWUgPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwge1xuICAgICAgICAgICAgb3A6IFwicmVtb3ZlXCIsXG4gICAgICAgICAgICBwYXRoOiB0aGlzLmZyb20sXG4gICAgICAgIH0pLnJlbW92ZWQ7XG4gICAgICAgIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCB7XG4gICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICAgICAgICAgIHZhbHVlOiBvcmlnaW5hbFZhbHVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkIH07XG4gICAgfSxcbiAgICBjb3B5OiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlVG9Db3B5ID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIHRoaXMuZnJvbSk7XG4gICAgICAgIC8vIGVuZm9yY2UgY29weSBieSB2YWx1ZSBzbyBmdXJ0aGVyIG9wZXJhdGlvbnMgZG9uJ3QgYWZmZWN0IHNvdXJjZSAoc2VlIGlzc3VlICMxNzcpXG4gICAgICAgIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCB7XG4gICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICAgICAgICAgIHZhbHVlOiBfZGVlcENsb25lKHZhbHVlVG9Db3B5KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgIH0sXG4gICAgdGVzdDogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHRlc3Q6IF9hcmVFcXVhbHMob2JqW2tleV0sIHRoaXMudmFsdWUpIH07XG4gICAgfSxcbiAgICBfZ2V0OiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgfSxcbn07XG4vKiBUaGUgb3BlcmF0aW9ucyBhcHBsaWNhYmxlIHRvIGFuIGFycmF5LiBNYW55IGFyZSB0aGUgc2FtZSBhcyBmb3IgdGhlIG9iamVjdCAqL1xudmFyIGFyck9wcyA9IHtcbiAgICBhZGQ6IGZ1bmN0aW9uIChhcnIsIGksIGRvY3VtZW50KSB7XG4gICAgICAgIGlmIChpc0ludGVnZXIoaSkpIHtcbiAgICAgICAgICAgIGFyci5zcGxpY2UoaSwgMCwgdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhcnJheSBwcm9wc1xuICAgICAgICAgICAgYXJyW2ldID0gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIG1heSBiZSBuZWVkZWQgd2hlbiB1c2luZyAnLScgaW4gYW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCBpbmRleDogaSB9O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgcmVtb3ZlZExpc3QgPSBhcnIuc3BsaWNlKGksIDEpO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWRMaXN0WzBdIH07XG4gICAgfSxcbiAgICByZXBsYWNlOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IGFycltpXTtcbiAgICAgICAgYXJyW2ldID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkIH07XG4gICAgfSxcbiAgICBtb3ZlOiBvYmpPcHMubW92ZSxcbiAgICBjb3B5OiBvYmpPcHMuY29weSxcbiAgICB0ZXN0OiBvYmpPcHMudGVzdCxcbiAgICBfZ2V0OiBvYmpPcHMuX2dldCxcbn07XG4vKipcbiAqIFJldHJpZXZlcyBhIHZhbHVlIGZyb20gYSBKU09OIGRvY3VtZW50IGJ5IGEgSlNPTiBwb2ludGVyLlxuICogUmV0dXJucyB0aGUgdmFsdWUuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBnZXQgdGhlIHZhbHVlIGZyb21cbiAqIEBwYXJhbSBwb2ludGVyIGFuIGVzY2FwZWQgSlNPTiBwb2ludGVyXG4gKiBAcmV0dXJuIFRoZSByZXRyaWV2ZWQgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCBwb2ludGVyKSB7XG4gICAgaWYgKHBvaW50ZXIgPT0gXCJcIikge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfVxuICAgIHZhciBnZXRPcmlnaW5hbERlc3RpbmF0aW9uID0geyBvcDogXCJfZ2V0XCIsIHBhdGg6IHBvaW50ZXIgfTtcbiAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgZ2V0T3JpZ2luYWxEZXN0aW5hdGlvbik7XG4gICAgcmV0dXJuIGdldE9yaWdpbmFsRGVzdGluYXRpb24udmFsdWU7XG59XG4vKipcbiAqIEFwcGx5IGEgc2luZ2xlIEpTT04gUGF0Y2ggT3BlcmF0aW9uIG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHtuZXdEb2N1bWVudCwgcmVzdWx0fSBvZiB0aGUgb3BlcmF0aW9uLlxuICogSXQgbW9kaWZpZXMgdGhlIGBkb2N1bWVudGAgYW5kIGBvcGVyYXRpb25gIG9iamVjdHMgLSBpdCBnZXRzIHRoZSB2YWx1ZXMgYnkgcmVmZXJlbmNlLlxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gYXZvaWQgdG91Y2hpbmcgeW91ciB2YWx1ZXMsIGNsb25lIHRoZW06XG4gKiBganNvbnBhdGNoLmFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBqc29ucGF0Y2guX2RlZXBDbG9uZShvcGVyYXRpb24pKWAuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICogQHBhcmFtIG9wZXJhdGlvbiBUaGUgb3BlcmF0aW9uIHRvIGFwcGx5XG4gKiBAcGFyYW0gdmFsaWRhdGVPcGVyYXRpb24gYGZhbHNlYCBpcyB3aXRob3V0IHZhbGlkYXRpb24sIGB0cnVlYCB0byB1c2UgZGVmYXVsdCBqc29ucGF0Y2gncyB2YWxpZGF0aW9uLCBvciB5b3UgY2FuIHBhc3MgYSBgdmFsaWRhdGVPcGVyYXRpb25gIGNhbGxiYWNrIHRvIGJlIHVzZWQgZm9yIHZhbGlkYXRpb24uXG4gKiBAcGFyYW0gbXV0YXRlRG9jdW1lbnQgV2hldGhlciB0byBtdXRhdGUgdGhlIG9yaWdpbmFsIGRvY3VtZW50IG9yIGNsb25lIGl0IGJlZm9yZSBhcHBseWluZ1xuICogQHBhcmFtIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgV2hldGhlciB0byBiYW4gbW9kaWZpY2F0aW9ucyB0byBgX19wcm90b19fYCwgZGVmYXVsdHMgdG8gYHRydWVgLlxuICogQHJldHVybiBge25ld0RvY3VtZW50LCByZXN1bHR9YCBhZnRlciB0aGUgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgb3BlcmF0aW9uLCB2YWxpZGF0ZU9wZXJhdGlvbiA9IGZhbHNlLCBtdXRhdGVEb2N1bWVudCA9IHRydWUsIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgPSB0cnVlLCBpbmRleCA9IDApIHtcbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZGF0ZU9wZXJhdGlvbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlT3BlcmF0aW9uKG9wZXJhdGlvbiwgMCwgZG9jdW1lbnQsIG9wZXJhdGlvbi5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcihvcGVyYXRpb24sIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIFJPT1QgT1BFUkFUSU9OUyAqL1xuICAgIGlmIChvcGVyYXRpb24ucGF0aCA9PT0gXCJcIikge1xuICAgICAgICBsZXQgcmV0dXJuVmFsdWUgPSB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09PSBcImFkZFwiKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG9wZXJhdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09IFwicmVwbGFjZVwiKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG9wZXJhdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDsgLy9kb2N1bWVudCB3ZSByZW1vdmVkXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcIm1vdmVcIiB8fCBvcGVyYXRpb24ub3AgPT09IFwiY29weVwiKSB7XG4gICAgICAgICAgICAvLyBpdCdzIGEgbW92ZSBvciBjb3B5IHRvIHJvb3RcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIG9wZXJhdGlvbi5mcm9tKTsgLy8gZ2V0IHRoZSB2YWx1ZSBieSBqc29uLXBvaW50ZXIgaW4gYGZyb21gIGZpZWxkXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09PSBcIm1vdmVcIikge1xuICAgICAgICAgICAgICAgIC8vIHJlcG9ydCByZW1vdmVkIGl0ZW1cbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInRlc3RcIikge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUudGVzdCA9IF9hcmVFcXVhbHMoZG9jdW1lbnQsIG9wZXJhdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgXCJURVNUX09QRVJBVElPTl9GQUlMRURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09IFwicmVtb3ZlXCIpIHtcbiAgICAgICAgICAgIC8vIGEgcmVtb3ZlIG9uIHJvb3RcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09IFwiX2dldFwiKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24udmFsdWUgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIGJhZCBvcGVyYXRpb24gKi9cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIk9wZXJhdGlvbiBgb3BgIHByb3BlcnR5IGlzIG5vdCBvbmUgb2Ygb3BlcmF0aW9ucyBkZWZpbmVkIGluIFJGQy02OTAyXCIsIFwiT1BFUkFUSU9OX09QX0lOVkFMSURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSAvKiBFTkQgUk9PVCBPUEVSQVRJT05TICovXG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghbXV0YXRlRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50ID0gX2RlZXBDbG9uZShkb2N1bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aCA9IG9wZXJhdGlvbi5wYXRoIHx8IFwiXCI7XG4gICAgICAgIGNvbnN0IGtleXMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgbGV0IG9iaiA9IGRvY3VtZW50O1xuICAgICAgICBsZXQgdCA9IDE7IC8vc2tpcCBlbXB0eSBlbGVtZW50IC0gaHR0cDovL2pzcGVyZi5jb20vdG8tc2hpZnQtb3Itbm90LXRvLXNoaWZ0XG4gICAgICAgIGxldCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgbGV0IGV4aXN0aW5nUGF0aEZyYWdtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBsZXQgdmFsaWRhdGVGdW5jdGlvbjtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZGF0ZU9wZXJhdGlvbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24gPSB2YWxpZGF0ZU9wZXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24gPSB2YWxpZGF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbdF07XG4gICAgICAgICAgICBpZiAoa2V5ICYmIGtleS5pbmRleE9mKFwiflwiKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgIGtleSA9IHVuZXNjYXBlUGF0aENvbXBvbmVudChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgJiZcbiAgICAgICAgICAgICAgICAoa2V5ID09IFwiX19wcm90b19fXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgKGtleSA9PSBcInByb3RvdHlwZVwiICYmIHQgPiAwICYmIGtleXNbdCAtIDFdID09IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkpTT04tUGF0Y2g6IG1vZGlmeWluZyBgX19wcm90b19fYCBvciBgY29uc3RydWN0b3IvcHJvdG90eXBlYCBwcm9wIGlzIGJhbm5lZCBmb3Igc2VjdXJpdHkgcmVhc29ucywgaWYgdGhpcyB3YXMgb24gcHVycG9zZSwgcGxlYXNlIHNldCBgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9uc2AgZmxhZyBmYWxzZSBhbmQgcGFzcyBpdCB0byB0aGlzIGZ1bmN0aW9uLiBNb3JlIGluZm8gaW4gZmFzdC1qc29uLXBhdGNoIFJFQURNRVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1BhdGhGcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1BhdGhGcmFnbWVudCA9IGtleXMuc2xpY2UoMCwgdCkuam9pbihcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodCA9PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1BhdGhGcmFnbWVudCA9IG9wZXJhdGlvbi5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1BhdGhGcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uKG9wZXJhdGlvbiwgMCwgZG9jdW1lbnQsIGV4aXN0aW5nUGF0aEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQrKztcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIi1cIikge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBvYmoubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uICYmICFpc0ludGVnZXIoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiRXhwZWN0ZWQgYW4gdW5zaWduZWQgYmFzZS0xMCBpbnRlZ2VyIHZhbHVlLCBtYWtpbmcgdGhlIG5ldyByZWZlcmVuY2VkIHZhbHVlIHRoZSBhcnJheSBlbGVtZW50IHdpdGggdGhlIHplcm8tYmFzZWQgaW5kZXhcIiwgXCJPUEVSQVRJT05fUEFUSF9JTExFR0FMX0FSUkFZX0lOREVYXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBvbmx5IHBhcnNlIGtleSB3aGVuIGl0J3MgYW4gaW50ZWdlciBmb3IgYGFyci5wcm9wYCB0byB3b3JrXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSW50ZWdlcihrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSB+fmtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uICYmIG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIiAmJiBrZXkgPiBvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJUaGUgc3BlY2lmaWVkIGluZGV4IE1VU1QgTk9UIGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheVwiLCBcIk9QRVJBVElPTl9WQUxVRV9PVVRfT0ZfQk9VTkRTXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IGFyck9wc1tvcGVyYXRpb24ub3BdLmNhbGwob3BlcmF0aW9uLCBvYmosIGtleSwgZG9jdW1lbnQpOyAvLyBBcHBseSBwYXRjaFxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCBcIlRFU1RfT1BFUkFUSU9OX0ZBSUxFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0ID49IGxlbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IG9iak9wc1tvcGVyYXRpb24ub3BdLmNhbGwob3BlcmF0aW9uLCBvYmosIGtleSwgZG9jdW1lbnQpOyAvLyBBcHBseSBwYXRjaFxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCBcIlRFU1RfT1BFUkFUSU9OX0ZBSUxFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaiA9IG9ialtrZXldO1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBtb3JlIGtleXMgaW4gdGhlIHBhdGgsIGJ1dCB0aGUgbmV4dCB2YWx1ZSBpc24ndCBhIG5vbi1udWxsIG9iamVjdCxcbiAgICAgICAgICAgIC8vIHRocm93IGFuIE9QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRSBlcnJvciBpbnN0ZWFkIG9mIGl0ZXJhdGluZyBhZ2Fpbi5cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiB0IDwgbGVuICYmICghb2JqIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiQ2Fubm90IHBlcmZvcm0gb3BlcmF0aW9uIGF0IHRoZSBkZXNpcmVkIHBhdGhcIiwgXCJPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEVcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBcHBseSBhIGZ1bGwgSlNPTiBQYXRjaCBhcnJheSBvbiBhIEpTT04gZG9jdW1lbnQuXG4gKiBSZXR1cm5zIHRoZSB7bmV3RG9jdW1lbnQsIHJlc3VsdH0gb2YgdGhlIHBhdGNoLlxuICogSXQgbW9kaWZpZXMgdGhlIGBkb2N1bWVudGAgb2JqZWN0IGFuZCBgcGF0Y2hgIC0gaXQgZ2V0cyB0aGUgdmFsdWVzIGJ5IHJlZmVyZW5jZS5cbiAqIElmIHlvdSB3b3VsZCBsaWtlIHRvIGF2b2lkIHRvdWNoaW5nIHlvdXIgdmFsdWVzLCBjbG9uZSB0aGVtOlxuICogYGpzb25wYXRjaC5hcHBseVBhdGNoKGRvY3VtZW50LCBqc29ucGF0Y2guX2RlZXBDbG9uZShwYXRjaCkpYC5cbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIHBhdGNoXG4gKiBAcGFyYW0gcGF0Y2ggVGhlIHBhdGNoIHRvIGFwcGx5XG4gKiBAcGFyYW0gdmFsaWRhdGVPcGVyYXRpb24gYGZhbHNlYCBpcyB3aXRob3V0IHZhbGlkYXRpb24sIGB0cnVlYCB0byB1c2UgZGVmYXVsdCBqc29ucGF0Y2gncyB2YWxpZGF0aW9uLCBvciB5b3UgY2FuIHBhc3MgYSBgdmFsaWRhdGVPcGVyYXRpb25gIGNhbGxiYWNrIHRvIGJlIHVzZWQgZm9yIHZhbGlkYXRpb24uXG4gKiBAcGFyYW0gbXV0YXRlRG9jdW1lbnQgV2hldGhlciB0byBtdXRhdGUgdGhlIG9yaWdpbmFsIGRvY3VtZW50IG9yIGNsb25lIGl0IGJlZm9yZSBhcHBseWluZ1xuICogQHBhcmFtIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgV2hldGhlciB0byBiYW4gbW9kaWZpY2F0aW9ucyB0byBgX19wcm90b19fYCwgZGVmYXVsdHMgdG8gYHRydWVgLlxuICogQHJldHVybiBBbiBhcnJheSBvZiBge25ld0RvY3VtZW50LCByZXN1bHR9YCBhZnRlciB0aGUgcGF0Y2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGF0Y2goZG9jdW1lbnQsIHBhdGNoLCB2YWxpZGF0ZU9wZXJhdGlvbiwgbXV0YXRlRG9jdW1lbnQgPSB0cnVlLCBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zID0gdHJ1ZSkge1xuICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0Y2gpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJQYXRjaCBzZXF1ZW5jZSBtdXN0IGJlIGFuIGFycmF5XCIsIFwiU0VRVUVOQ0VfTk9UX0FOX0FSUkFZXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbXV0YXRlRG9jdW1lbnQpIHtcbiAgICAgICAgZG9jdW1lbnQgPSBfZGVlcENsb25lKGRvY3VtZW50KTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShwYXRjaC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBwYXRjaC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHBhc3MgbXV0YXRlRG9jdW1lbnQgYXJndW1lbnQgYmVjYXVzZSBpZiBpdCB3YXMgdHJ1ZSwgd2UgYWxyZWFkeSBkZWVwIGNsb25lZCB0aGUgb2JqZWN0LCB3ZSdsbCBqdXN0IHBhc3MgYHRydWVgXG4gICAgICAgIHJlc3VsdHNbaV0gPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgcGF0Y2hbaV0sIHZhbGlkYXRlT3BlcmF0aW9uLCB0cnVlLCBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zLCBpKTtcbiAgICAgICAgZG9jdW1lbnQgPSByZXN1bHRzW2ldLm5ld0RvY3VtZW50OyAvLyBpbiBjYXNlIHJvb3Qgd2FzIHJlcGxhY2VkXG4gICAgfVxuICAgIHJlc3VsdHMubmV3RG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICByZXR1cm4gcmVzdWx0cztcbn1cbi8qKlxuICogQXBwbHkgYSBzaW5nbGUgSlNPTiBQYXRjaCBPcGVyYXRpb24gb24gYSBKU09OIGRvY3VtZW50LlxuICogUmV0dXJucyB0aGUgdXBkYXRlZCBkb2N1bWVudC5cbiAqIFN1aXRhYmxlIGFzIGEgcmVkdWNlci5cbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIHBhdGNoXG4gKiBAcGFyYW0gb3BlcmF0aW9uIFRoZSBvcGVyYXRpb24gdG8gYXBwbHlcbiAqIEByZXR1cm4gVGhlIHVwZGF0ZWQgZG9jdW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UmVkdWNlcihkb2N1bWVudCwgb3BlcmF0aW9uLCBpbmRleCkge1xuICAgIGNvbnN0IG9wZXJhdGlvblJlc3VsdCA9IGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBvcGVyYXRpb24pO1xuICAgIGlmIChvcGVyYXRpb25SZXN1bHQudGVzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gZmFpbGVkIHRlc3RcbiAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsIFwiVEVTVF9PUEVSQVRJT05fRkFJTEVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wZXJhdGlvblJlc3VsdC5uZXdEb2N1bWVudDtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgc2luZ2xlIG9wZXJhdGlvbi4gQ2FsbGVkIGZyb20gYGpzb25wYXRjaC52YWxpZGF0ZWAuIFRocm93cyBgSnNvblBhdGNoRXJyb3JgIGluIGNhc2Ugb2YgYW4gZXJyb3IuXG4gKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0aW9uIC0gb3BlcmF0aW9uIG9iamVjdCAocGF0Y2gpXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCBvZiBvcGVyYXRpb24gaW4gdGhlIHNlcXVlbmNlXG4gKiBAcGFyYW0ge29iamVjdH0gW2RvY3VtZW50XSAtIG9iamVjdCB3aGVyZSB0aGUgb3BlcmF0aW9uIGlzIHN1cHBvc2VkIHRvIGJlIGFwcGxpZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXhpc3RpbmdQYXRoRnJhZ21lbnRdIC0gY29tZXMgYWxvbmcgd2l0aCBgZG9jdW1lbnRgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0b3Iob3BlcmF0aW9uLCBpbmRleCwgZG9jdW1lbnQsIGV4aXN0aW5nUGF0aEZyYWdtZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvcGVyYXRpb24gIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgb3BlcmF0aW9uID09PSBudWxsIHx8XG4gICAgICAgIEFycmF5LmlzQXJyYXkob3BlcmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gaXMgbm90IGFuIG9iamVjdFwiLCBcIk9QRVJBVElPTl9OT1RfQU5fT0JKRUNUXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIW9iak9wc1tvcGVyYXRpb24ub3BdKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIk9wZXJhdGlvbiBgb3BgIHByb3BlcnR5IGlzIG5vdCBvbmUgb2Ygb3BlcmF0aW9ucyBkZWZpbmVkIGluIFJGQy02OTAyXCIsIFwiT1BFUkFUSU9OX09QX0lOVkFMSURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3BlcmF0aW9uLnBhdGggIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGBwYXRoYCBwcm9wZXJ0eSBpcyBub3QgYSBzdHJpbmdcIiwgXCJPUEVSQVRJT05fUEFUSF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnBhdGguaW5kZXhPZihcIi9cIikgIT09IDAgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBwYXRocyB0aGF0IGFyZW4ndCBlbXB0eSBzdHJpbmcgc2hvdWxkIHN0YXJ0IHdpdGggXCIvXCJcbiAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYHBhdGhgIHByb3BlcnR5IG11c3Qgc3RhcnQgd2l0aCBcIi9cIicsIFwiT1BFUkFUSU9OX1BBVEhfSU5WQUxJRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcGVyYXRpb24ub3AgPT09IFwibW92ZVwiIHx8IG9wZXJhdGlvbi5vcCA9PT0gXCJjb3B5XCIpICYmXG4gICAgICAgIHR5cGVvZiBvcGVyYXRpb24uZnJvbSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYGZyb21gIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBtb3ZlYCBhbmQgYGNvcHlgIG9wZXJhdGlvbnMpXCIsIFwiT1BFUkFUSU9OX0ZST01fUkVRVUlSRURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgob3BlcmF0aW9uLm9wID09PSBcImFkZFwiIHx8XG4gICAgICAgIG9wZXJhdGlvbi5vcCA9PT0gXCJyZXBsYWNlXCIgfHxcbiAgICAgICAgb3BlcmF0aW9uLm9wID09PSBcInRlc3RcIikgJiZcbiAgICAgICAgb3BlcmF0aW9uLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGB2YWx1ZWAgcHJvcGVydHkgaXMgbm90IHByZXNlbnQgKGFwcGxpY2FibGUgaW4gYGFkZGAsIGByZXBsYWNlYCBhbmQgYHRlc3RgIG9wZXJhdGlvbnMpXCIsIFwiT1BFUkFUSU9OX1ZBTFVFX1JFUVVJUkVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIiB8fFxuICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwicmVwbGFjZVwiIHx8XG4gICAgICAgIG9wZXJhdGlvbi5vcCA9PT0gXCJ0ZXN0XCIpICYmXG4gICAgICAgIGhhc1VuZGVmaW5lZChvcGVyYXRpb24udmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIk9wZXJhdGlvbiBgdmFsdWVgIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBhZGRgLCBgcmVwbGFjZWAgYW5kIGB0ZXN0YCBvcGVyYXRpb25zKVwiLCBcIk9QRVJBVElPTl9WQUxVRV9DQU5OT1RfQ09OVEFJTl9VTkRFRklORURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkb2N1bWVudCkge1xuICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09IFwiYWRkXCIpIHtcbiAgICAgICAgICAgIHZhciBwYXRoTGVuID0gb3BlcmF0aW9uLnBhdGguc3BsaXQoXCIvXCIpLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ1BhdGhMZW4gPSBleGlzdGluZ1BhdGhGcmFnbWVudC5zcGxpdChcIi9cIikubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBhdGhMZW4gIT09IGV4aXN0aW5nUGF0aExlbiArIDEgJiYgcGF0aExlbiAhPT0gZXhpc3RpbmdQYXRoTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiQ2Fubm90IHBlcmZvcm0gYW4gYGFkZGAgb3BlcmF0aW9uIGF0IHRoZSBkZXNpcmVkIHBhdGhcIiwgXCJPUEVSQVRJT05fUEFUSF9DQU5OT1RfQUREXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09IFwicmVwbGFjZVwiIHx8XG4gICAgICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwicmVtb3ZlXCIgfHxcbiAgICAgICAgICAgIG9wZXJhdGlvbi5vcCA9PT0gXCJfZ2V0XCIpIHtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ucGF0aCAhPT0gZXhpc3RpbmdQYXRoRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJDYW5ub3QgcGVyZm9ybSB0aGUgb3BlcmF0aW9uIGF0IGEgcGF0aCB0aGF0IGRvZXMgbm90IGV4aXN0XCIsIFwiT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09IFwibW92ZVwiIHx8IG9wZXJhdGlvbi5vcCA9PT0gXCJjb3B5XCIpIHtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0ge1xuICAgICAgICAgICAgICAgIG9wOiBcIl9nZXRcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBvcGVyYXRpb24uZnJvbSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IHZhbGlkYXRlKFtleGlzdGluZ1ZhbHVlXSwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLm5hbWUgPT09IFwiT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJDYW5ub3QgcGVyZm9ybSB0aGUgb3BlcmF0aW9uIGZyb20gYSBwYXRoIHRoYXQgZG9lcyBub3QgZXhpc3RcIiwgXCJPUEVSQVRJT05fRlJPTV9VTlJFU09MVkFCTEVcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSBzZXF1ZW5jZSBvZiBvcGVyYXRpb25zLiBJZiBgZG9jdW1lbnRgIHBhcmFtZXRlciBpcyBwcm92aWRlZCwgdGhlIHNlcXVlbmNlIGlzIGFkZGl0aW9uYWxseSB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgb2JqZWN0IGRvY3VtZW50LlxuICogSWYgZXJyb3IgaXMgZW5jb3VudGVyZWQsIHJldHVybnMgYSBKc29uUGF0Y2hFcnJvciBvYmplY3RcbiAqIEBwYXJhbSBzZXF1ZW5jZVxuICogQHBhcmFtIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7SnNvblBhdGNoRXJyb3J8dW5kZWZpbmVkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoc2VxdWVuY2UsIGRvY3VtZW50LCBleHRlcm5hbFZhbGlkYXRvcikge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzZXF1ZW5jZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIlBhdGNoIHNlcXVlbmNlIG11c3QgYmUgYW4gYXJyYXlcIiwgXCJTRVFVRU5DRV9OT1RfQU5fQVJSQVlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgICAgICAvL2Nsb25lIGRvY3VtZW50IGFuZCBzZXF1ZW5jZSBzbyB0aGF0IHdlIGNhbiBzYWZlbHkgdHJ5IGFwcGx5aW5nIG9wZXJhdGlvbnNcbiAgICAgICAgICAgIGFwcGx5UGF0Y2goX2RlZXBDbG9uZShkb2N1bWVudCksIF9kZWVwQ2xvbmUoc2VxdWVuY2UpLCBleHRlcm5hbFZhbGlkYXRvciB8fCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4dGVybmFsVmFsaWRhdG9yID0gZXh0ZXJuYWxWYWxpZGF0b3IgfHwgdmFsaWRhdG9yO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGV4dGVybmFsVmFsaWRhdG9yKHNlcXVlbmNlW2ldLCBpLCBkb2N1bWVudCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEpzb25QYXRjaEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZXBvYmVyZXpraW4vZmFzdC1kZWVwLWVxdWFsXG4vLyBNSVQgTGljZW5zZVxuLy8gQ29weXJpZ2h0IChjKSAyMDE3IEV2Z2VueSBQb2JlcmV6a2luXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4vLyBTT0ZUV0FSRS5cbmV4cG9ydCBmdW5jdGlvbiBfYXJlRXF1YWxzKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBiID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIGFyckEgPSBBcnJheS5pc0FycmF5KGEpLCBhcnJCID0gQXJyYXkuaXNBcnJheShiKSwgaSwgbGVuZ3RoLCBrZXk7XG4gICAgICAgIGlmIChhcnJBICYmIGFyckIpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgICAgICAgICAgaWYgKCFfYXJlRXF1YWxzKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyQSAhPSBhcnJCKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgICAgICBpZiAoIWIuaGFzT3duUHJvcGVydHkoa2V5c1tpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIV9hcmVFcXVhbHMoYVtrZXldLCBiW2tleV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compare: () => (/* binding */ compare),\n/* harmony export */   generate: () => (/* binding */ generate),\n/* harmony export */   observe: () => (/* binding */ observe),\n/* harmony export */   unobserve: () => (/* binding */ unobserve)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"(action-browser)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js\");\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.js */ \"(action-browser)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js\");\n// @ts-nocheck\n// Inlined because of ESM import issues\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2013-2021 Joachim Wester\n * MIT license\n */\n\n\nvar beforeDict = new WeakMap();\nclass Mirror {\n    constructor(obj) {\n        Object.defineProperty(this, \"obj\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.obj = obj;\n    }\n}\nclass ObserverInfo {\n    constructor(callback, observer) {\n        Object.defineProperty(this, \"callback\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.callback = callback;\n        this.observer = observer;\n    }\n}\nfunction getMirror(obj) {\n    return beforeDict.get(obj);\n}\nfunction getObserverFromMirror(mirror, callback) {\n    return mirror.observers.get(callback);\n}\nfunction removeObserverFromMirror(mirror, observer) {\n    mirror.observers.delete(observer.callback);\n}\n/**\n * Detach an observer from an object\n */\nfunction unobserve(root, observer) {\n    observer.unobserve();\n}\n/**\n * Observes changes made to an object, which can then be retrieved using generate\n */\nfunction observe(obj, callback) {\n    var patches = [];\n    var observer;\n    var mirror = getMirror(obj);\n    if (!mirror) {\n        mirror = new Mirror(obj);\n        beforeDict.set(obj, mirror);\n    }\n    else {\n        const observerInfo = getObserverFromMirror(mirror, callback);\n        observer = observerInfo && observerInfo.observer;\n    }\n    if (observer) {\n        return observer;\n    }\n    observer = {};\n    mirror.value = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(obj);\n    if (callback) {\n        observer.callback = callback;\n        observer.next = null;\n        var dirtyCheck = () => {\n            generate(observer);\n        };\n        var fastCheck = () => {\n            clearTimeout(observer.next);\n            observer.next = setTimeout(dirtyCheck);\n        };\n        if (typeof window !== \"undefined\") {\n            //not Node\n            window.addEventListener(\"mouseup\", fastCheck);\n            window.addEventListener(\"keyup\", fastCheck);\n            window.addEventListener(\"mousedown\", fastCheck);\n            window.addEventListener(\"keydown\", fastCheck);\n            window.addEventListener(\"change\", fastCheck);\n        }\n    }\n    observer.patches = patches;\n    observer.object = obj;\n    observer.unobserve = () => {\n        generate(observer);\n        clearTimeout(observer.next);\n        removeObserverFromMirror(mirror, observer);\n        if (typeof window !== \"undefined\") {\n            window.removeEventListener(\"mouseup\", fastCheck);\n            window.removeEventListener(\"keyup\", fastCheck);\n            window.removeEventListener(\"mousedown\", fastCheck);\n            window.removeEventListener(\"keydown\", fastCheck);\n            window.removeEventListener(\"change\", fastCheck);\n        }\n    };\n    mirror.observers.set(callback, new ObserverInfo(callback, observer));\n    return observer;\n}\n/**\n * Generate an array of patches from an observer\n */\nfunction generate(observer, invertible = false) {\n    var mirror = beforeDict.get(observer.object);\n    _generate(mirror.value, observer.object, observer.patches, \"\", invertible);\n    if (observer.patches.length) {\n        (0,_core_js__WEBPACK_IMPORTED_MODULE_1__.applyPatch)(mirror.value, observer.patches);\n    }\n    var temp = observer.patches;\n    if (temp.length > 0) {\n        observer.patches = [];\n        if (observer.callback) {\n            observer.callback(temp);\n        }\n    }\n    return temp;\n}\n// Dirty check if obj is different from mirror, generate patches and update mirror\nfunction _generate(mirror, obj, patches, path, invertible) {\n    if (obj === mirror) {\n        return;\n    }\n    if (typeof obj.toJSON === \"function\") {\n        obj = obj.toJSON();\n    }\n    var newKeys = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._objectKeys)(obj);\n    var oldKeys = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._objectKeys)(mirror);\n    var changed = false;\n    var deleted = false;\n    //if ever \"move\" operation is implemented here, make sure this test runs OK: \"should not generate the same patch twice (move)\"\n    for (var t = oldKeys.length - 1; t >= 0; t--) {\n        var key = oldKeys[t];\n        var oldVal = mirror[key];\n        if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(obj, key) &&\n            !(obj[key] === undefined &&\n                oldVal !== undefined &&\n                Array.isArray(obj) === false)) {\n            var newVal = obj[key];\n            if (typeof oldVal == \"object\" &&\n                oldVal != null &&\n                typeof newVal == \"object\" &&\n                newVal != null &&\n                Array.isArray(oldVal) === Array.isArray(newVal)) {\n                _generate(oldVal, newVal, patches, path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), invertible);\n            }\n            else {\n                if (oldVal !== newVal) {\n                    changed = true;\n                    if (invertible) {\n                        patches.push({\n                            op: \"test\",\n                            path: path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),\n                            value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(oldVal),\n                        });\n                    }\n                    patches.push({\n                        op: \"replace\",\n                        path: path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),\n                        value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(newVal),\n                    });\n                }\n            }\n        }\n        else if (Array.isArray(mirror) === Array.isArray(obj)) {\n            if (invertible) {\n                patches.push({\n                    op: \"test\",\n                    path: path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),\n                    value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(oldVal),\n                });\n            }\n            patches.push({\n                op: \"remove\",\n                path: path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),\n            });\n            deleted = true; // property has been deleted\n        }\n        else {\n            if (invertible) {\n                patches.push({ op: \"test\", path, value: mirror });\n            }\n            patches.push({ op: \"replace\", path, value: obj });\n            changed = true;\n        }\n    }\n    if (!deleted && newKeys.length == oldKeys.length) {\n        return;\n    }\n    for (var t = 0; t < newKeys.length; t++) {\n        var key = newKeys[t];\n        if (!(0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(mirror, key) && obj[key] !== undefined) {\n            patches.push({\n                op: \"add\",\n                path: path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),\n                value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(obj[key]),\n            });\n        }\n    }\n}\n/**\n * Create an array of patches from the differences in two objects\n */\nfunction compare(tree1, tree2, invertible = false) {\n    var patches = [];\n    _generate(tree1, tree2, patches, \"\", invertible);\n    return patches;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9mYXN0LWpzb24tcGF0Y2gvc3JjL2R1cGxleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RjtBQUN0RDtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdURBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3REFBVztBQUM3QixrQkFBa0Isd0RBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBLFlBQVksMkRBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGdFQUFtQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnRUFBbUI7QUFDbEUsbUNBQW1DLHVEQUFVO0FBQzdDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0VBQW1CO0FBQzlELCtCQUErQix1REFBVTtBQUN6QyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0VBQW1CO0FBQzFELDJCQUEyQix1REFBVTtBQUNyQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdFQUFtQjtBQUN0RCxhQUFhO0FBQ2IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQ0FBaUM7QUFDaEU7QUFDQSwyQkFBMkIsaUNBQWlDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQSxhQUFhLDJEQUFjO0FBQzNCO0FBQ0E7QUFDQSxtQ0FBbUMsZ0VBQW1CO0FBQ3RELHVCQUF1Qix1REFBVTtBQUNqQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHV0aWxzXFxmYXN0LWpzb24tcGF0Y2hcXHNyY1xcZHVwbGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1ub2NoZWNrXG4vLyBJbmxpbmVkIGJlY2F1c2Ugb2YgRVNNIGltcG9ydCBpc3N1ZXNcbi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL1N0YXJjb3VudGVyLUphY2svSlNPTi1QYXRjaFxuICogKGMpIDIwMTMtMjAyMSBKb2FjaGltIFdlc3RlclxuICogTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgX2RlZXBDbG9uZSwgX29iamVjdEtleXMsIGVzY2FwZVBhdGhDb21wb25lbnQsIGhhc093blByb3BlcnR5LCB9IGZyb20gXCIuL2hlbHBlcnMuanNcIjtcbmltcG9ydCB7IGFwcGx5UGF0Y2ggfSBmcm9tIFwiLi9jb3JlLmpzXCI7XG52YXIgYmVmb3JlRGljdCA9IG5ldyBXZWFrTWFwKCk7XG5jbGFzcyBNaXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvYmpcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib2JzZXJ2ZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgIH1cbn1cbmNsYXNzIE9ic2VydmVySW5mbyB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIG9ic2VydmVyKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxiYWNrXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9ic2VydmVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldE1pcnJvcihvYmopIHtcbiAgICByZXR1cm4gYmVmb3JlRGljdC5nZXQob2JqKTtcbn1cbmZ1bmN0aW9uIGdldE9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG1pcnJvci5vYnNlcnZlcnMuZ2V0KGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIG9ic2VydmVyKSB7XG4gICAgbWlycm9yLm9ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIuY2FsbGJhY2spO1xufVxuLyoqXG4gKiBEZXRhY2ggYW4gb2JzZXJ2ZXIgZnJvbSBhbiBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVub2JzZXJ2ZShyb290LCBvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLnVub2JzZXJ2ZSgpO1xufVxuLyoqXG4gKiBPYnNlcnZlcyBjaGFuZ2VzIG1hZGUgdG8gYW4gb2JqZWN0LCB3aGljaCBjYW4gdGhlbiBiZSByZXRyaWV2ZWQgdXNpbmcgZ2VuZXJhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmUob2JqLCBjYWxsYmFjaykge1xuICAgIHZhciBwYXRjaGVzID0gW107XG4gICAgdmFyIG9ic2VydmVyO1xuICAgIHZhciBtaXJyb3IgPSBnZXRNaXJyb3Iob2JqKTtcbiAgICBpZiAoIW1pcnJvcikge1xuICAgICAgICBtaXJyb3IgPSBuZXcgTWlycm9yKG9iaik7XG4gICAgICAgIGJlZm9yZURpY3Quc2V0KG9iaiwgbWlycm9yKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG9ic2VydmVySW5mbyA9IGdldE9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIGNhbGxiYWNrKTtcbiAgICAgICAgb2JzZXJ2ZXIgPSBvYnNlcnZlckluZm8gJiYgb2JzZXJ2ZXJJbmZvLm9ic2VydmVyO1xuICAgIH1cbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cbiAgICBvYnNlcnZlciA9IHt9O1xuICAgIG1pcnJvci52YWx1ZSA9IF9kZWVwQ2xvbmUob2JqKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgb2JzZXJ2ZXIuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgb2JzZXJ2ZXIubmV4dCA9IG51bGw7XG4gICAgICAgIHZhciBkaXJ0eUNoZWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgZ2VuZXJhdGUob2JzZXJ2ZXIpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZmFzdENoZWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG9ic2VydmVyLm5leHQpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCA9IHNldFRpbWVvdXQoZGlydHlDaGVjayk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvL25vdCBOb2RlXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZhc3RDaGVjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2JzZXJ2ZXIucGF0Y2hlcyA9IHBhdGNoZXM7XG4gICAgb2JzZXJ2ZXIub2JqZWN0ID0gb2JqO1xuICAgIG9ic2VydmVyLnVub2JzZXJ2ZSA9ICgpID0+IHtcbiAgICAgICAgZ2VuZXJhdGUob2JzZXJ2ZXIpO1xuICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIHJlbW92ZU9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIG9ic2VydmVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbWlycm9yLm9ic2VydmVycy5zZXQoY2FsbGJhY2ssIG5ldyBPYnNlcnZlckluZm8oY2FsbGJhY2ssIG9ic2VydmVyKSk7XG4gICAgcmV0dXJuIG9ic2VydmVyO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBhcnJheSBvZiBwYXRjaGVzIGZyb20gYW4gb2JzZXJ2ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlKG9ic2VydmVyLCBpbnZlcnRpYmxlID0gZmFsc2UpIHtcbiAgICB2YXIgbWlycm9yID0gYmVmb3JlRGljdC5nZXQob2JzZXJ2ZXIub2JqZWN0KTtcbiAgICBfZ2VuZXJhdGUobWlycm9yLnZhbHVlLCBvYnNlcnZlci5vYmplY3QsIG9ic2VydmVyLnBhdGNoZXMsIFwiXCIsIGludmVydGlibGUpO1xuICAgIGlmIChvYnNlcnZlci5wYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICBhcHBseVBhdGNoKG1pcnJvci52YWx1ZSwgb2JzZXJ2ZXIucGF0Y2hlcyk7XG4gICAgfVxuICAgIHZhciB0ZW1wID0gb2JzZXJ2ZXIucGF0Y2hlcztcbiAgICBpZiAodGVtcC5sZW5ndGggPiAwKSB7XG4gICAgICAgIG9ic2VydmVyLnBhdGNoZXMgPSBbXTtcbiAgICAgICAgaWYgKG9ic2VydmVyLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5jYWxsYmFjayh0ZW1wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGVtcDtcbn1cbi8vIERpcnR5IGNoZWNrIGlmIG9iaiBpcyBkaWZmZXJlbnQgZnJvbSBtaXJyb3IsIGdlbmVyYXRlIHBhdGNoZXMgYW5kIHVwZGF0ZSBtaXJyb3JcbmZ1bmN0aW9uIF9nZW5lcmF0ZShtaXJyb3IsIG9iaiwgcGF0Y2hlcywgcGF0aCwgaW52ZXJ0aWJsZSkge1xuICAgIGlmIChvYmogPT09IG1pcnJvcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgICB9XG4gICAgdmFyIG5ld0tleXMgPSBfb2JqZWN0S2V5cyhvYmopO1xuICAgIHZhciBvbGRLZXlzID0gX29iamVjdEtleXMobWlycm9yKTtcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBkZWxldGVkID0gZmFsc2U7XG4gICAgLy9pZiBldmVyIFwibW92ZVwiIG9wZXJhdGlvbiBpcyBpbXBsZW1lbnRlZCBoZXJlLCBtYWtlIHN1cmUgdGhpcyB0ZXN0IHJ1bnMgT0s6IFwic2hvdWxkIG5vdCBnZW5lcmF0ZSB0aGUgc2FtZSBwYXRjaCB0d2ljZSAobW92ZSlcIlxuICAgIGZvciAodmFyIHQgPSBvbGRLZXlzLmxlbmd0aCAtIDE7IHQgPj0gMDsgdC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvbGRLZXlzW3RdO1xuICAgICAgICB2YXIgb2xkVmFsID0gbWlycm9yW2tleV07XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIGtleSkgJiZcbiAgICAgICAgICAgICEob2JqW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIG9sZFZhbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShvYmopID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdWYWwgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2xkVmFsID09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBvbGRWYWwgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBuZXdWYWwgPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIG5ld1ZhbCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShvbGRWYWwpID09PSBBcnJheS5pc0FycmF5KG5ld1ZhbCkpIHtcbiAgICAgICAgICAgICAgICBfZ2VuZXJhdGUob2xkVmFsLCBuZXdWYWwsIHBhdGNoZXMsIHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSwgaW52ZXJ0aWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsICE9PSBuZXdWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcInRlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoICsgXCIvXCIgKyBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF9kZWVwQ2xvbmUob2xkVmFsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoICsgXCIvXCIgKyBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX2RlZXBDbG9uZShuZXdWYWwpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtaXJyb3IpID09PSBBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwidGVzdFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoICsgXCIvXCIgKyBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfZGVlcENsb25lKG9sZFZhbCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiBcInJlbW92ZVwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7IC8vIHByb3BlcnR5IGhhcyBiZWVuIGRlbGV0ZWRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwidGVzdFwiLCBwYXRoLCB2YWx1ZTogbWlycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwicmVwbGFjZVwiLCBwYXRoLCB2YWx1ZTogb2JqIH0pO1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkZWxldGVkICYmIG5ld0tleXMubGVuZ3RoID09IG9sZEtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBuZXdLZXlzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBuZXdLZXlzW3RdO1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KG1pcnJvciwga2V5KSAmJiBvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogX2RlZXBDbG9uZShvYmpba2V5XSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IG9mIHBhdGNoZXMgZnJvbSB0aGUgZGlmZmVyZW5jZXMgaW4gdHdvIG9iamVjdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmUodHJlZTEsIHRyZWUyLCBpbnZlcnRpYmxlID0gZmFsc2UpIHtcbiAgICB2YXIgcGF0Y2hlcyA9IFtdO1xuICAgIF9nZW5lcmF0ZSh0cmVlMSwgdHJlZTIsIHBhdGNoZXMsIFwiXCIsIGludmVydGlibGUpO1xuICAgIHJldHVybiBwYXRjaGVzO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PatchError: () => (/* binding */ PatchError),\n/* harmony export */   _deepClone: () => (/* binding */ _deepClone),\n/* harmony export */   _getPathRecursive: () => (/* binding */ _getPathRecursive),\n/* harmony export */   _objectKeys: () => (/* binding */ _objectKeys),\n/* harmony export */   escapePathComponent: () => (/* binding */ escapePathComponent),\n/* harmony export */   getPath: () => (/* binding */ getPath),\n/* harmony export */   hasOwnProperty: () => (/* binding */ hasOwnProperty),\n/* harmony export */   hasUndefined: () => (/* binding */ hasUndefined),\n/* harmony export */   isInteger: () => (/* binding */ isInteger),\n/* harmony export */   unescapePathComponent: () => (/* binding */ unescapePathComponent)\n/* harmony export */ });\n// @ts-nocheck\n// Inlined because of ESM import issues\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2017-2022 Joachim Wester\n * MIT licensed\n */\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(obj, key) {\n    return _hasOwnProperty.call(obj, key);\n}\nfunction _objectKeys(obj) {\n    if (Array.isArray(obj)) {\n        const keys = new Array(obj.length);\n        for (let k = 0; k < keys.length; k++) {\n            keys[k] = \"\" + k;\n        }\n        return keys;\n    }\n    if (Object.keys) {\n        return Object.keys(obj);\n    }\n    let keys = [];\n    for (let i in obj) {\n        if (hasOwnProperty(obj, i)) {\n            keys.push(i);\n        }\n    }\n    return keys;\n}\n/**\n * Deeply clone the object.\n * https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\n * @param  {any} obj value to clone\n * @return {any} cloned obj\n */\nfunction _deepClone(obj) {\n    switch (typeof obj) {\n        case \"object\":\n            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\n        case \"undefined\":\n            return null; //this is how JSON.stringify behaves for array items\n        default:\n            return obj; //no need to clone primitives\n    }\n}\n//3x faster than cached /^\\d+$/.test(str)\nfunction isInteger(str) {\n    let i = 0;\n    const len = str.length;\n    let charCode;\n    while (i < len) {\n        charCode = str.charCodeAt(i);\n        if (charCode >= 48 && charCode <= 57) {\n            i++;\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Escapes a json pointer path\n * @param path The raw pointer\n * @return the Escaped path\n */\nfunction escapePathComponent(path) {\n    if (path.indexOf(\"/\") === -1 && path.indexOf(\"~\") === -1)\n        return path;\n    return path.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\n/**\n * Unescapes a json pointer path\n * @param path The escaped pointer\n * @return The unescaped path\n */\nfunction unescapePathComponent(path) {\n    return path.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nfunction _getPathRecursive(root, obj) {\n    let found;\n    for (let key in root) {\n        if (hasOwnProperty(root, key)) {\n            if (root[key] === obj) {\n                return escapePathComponent(key) + \"/\";\n            }\n            else if (typeof root[key] === \"object\") {\n                found = _getPathRecursive(root[key], obj);\n                if (found != \"\") {\n                    return escapePathComponent(key) + \"/\" + found;\n                }\n            }\n        }\n    }\n    return \"\";\n}\nfunction getPath(root, obj) {\n    if (root === obj) {\n        return \"/\";\n    }\n    const path = _getPathRecursive(root, obj);\n    if (path === \"\") {\n        throw new Error(\"Object not found in root\");\n    }\n    return `/${path}`;\n}\n/**\n * Recursively checks whether an object has any undefined values inside.\n */\nfunction hasUndefined(obj) {\n    if (obj === undefined) {\n        return true;\n    }\n    if (obj) {\n        if (Array.isArray(obj)) {\n            for (let i = 0, len = obj.length; i < len; i++) {\n                if (hasUndefined(obj[i])) {\n                    return true;\n                }\n            }\n        }\n        else if (typeof obj === \"object\") {\n            const objKeys = _objectKeys(obj);\n            const objKeysLength = objKeys.length;\n            for (var i = 0; i < objKeysLength; i++) {\n                if (hasUndefined(obj[objKeys[i]])) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nfunction patchErrorMessageFormatter(message, args) {\n    const messageParts = [message];\n    for (const key in args) {\n        const value = typeof args[key] === \"object\"\n            ? JSON.stringify(args[key], null, 2)\n            : args[key]; // pretty print\n        if (typeof value !== \"undefined\") {\n            messageParts.push(`${key}: ${value}`);\n        }\n    }\n    return messageParts.join(\"\\n\");\n}\nclass PatchError extends Error {\n    constructor(message, name, index, operation, tree) {\n        super(patchErrorMessageFormatter(message, { name, index, operation, tree }));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: name\n        });\n        Object.defineProperty(this, \"index\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: index\n        });\n        Object.defineProperty(this, \"operation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: operation\n        });\n        Object.defineProperty(this, \"tree\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: tree\n        });\n        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359\n        this.message = patchErrorMessageFormatter(message, {\n            name,\n            index,\n            operation,\n            tree,\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9mYXN0LWpzb24tcGF0Y2gvc3JjL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakI7QUFDTztBQUNQO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQ0FBaUMsSUFBSSxJQUFJLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0RBQW9ELDhCQUE4QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx1dGlsc1xcZmFzdC1qc29uLXBhdGNoXFxzcmNcXGhlbHBlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLW5vY2hlY2tcbi8vIElubGluZWQgYmVjYXVzZSBvZiBFU00gaW1wb3J0IGlzc3Vlc1xuLyohXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU3RhcmNvdW50ZXItSmFjay9KU09OLVBhdGNoXG4gKiAoYykgMjAxNy0yMDIyIEpvYWNoaW0gV2VzdGVyXG4gKiBNSVQgbGljZW5zZWRcbiAqL1xuY29uc3QgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIGtleSkge1xuICAgIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5leHBvcnQgZnVuY3Rpb24gX29iamVjdEtleXMob2JqKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICBjb25zdCBrZXlzID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGtleXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGtleXNba10gPSBcIlwiICsgaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xuICAgIH1cbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIGkpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59XG4vKipcbiAqIERlZXBseSBjbG9uZSB0aGUgb2JqZWN0LlxuICogaHR0cHM6Ly9qc3BlcmYuY29tL2RlZXAtY29weS12cy1qc29uLXN0cmluZ2lmeS1qc29uLXBhcnNlLzI1IChyZWN1cnNpdmVEZWVwQ29weSlcbiAqIEBwYXJhbSAge2FueX0gb2JqIHZhbHVlIHRvIGNsb25lXG4gKiBAcmV0dXJuIHthbnl9IGNsb25lZCBvYmpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZWVwQ2xvbmUob2JqKSB7XG4gICAgc3dpdGNoICh0eXBlb2Ygb2JqKSB7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpOyAvL0Zhc3RlciB0aGFuIEVTNSBjbG9uZSAtIGh0dHA6Ly9qc3BlcmYuY29tL2RlZXAtY2xvbmluZy1vZi1vYmplY3RzLzVcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vdGhpcyBpcyBob3cgSlNPTi5zdHJpbmdpZnkgYmVoYXZlcyBmb3IgYXJyYXkgaXRlbXNcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBvYmo7IC8vbm8gbmVlZCB0byBjbG9uZSBwcmltaXRpdmVzXG4gICAgfVxufVxuLy8zeCBmYXN0ZXIgdGhhbiBjYWNoZWQgL15cXGQrJC8udGVzdChzdHIpXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlZ2VyKHN0cikge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGxldCBjaGFyQ29kZTtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEVzY2FwZXMgYSBqc29uIHBvaW50ZXIgcGF0aFxuICogQHBhcmFtIHBhdGggVGhlIHJhdyBwb2ludGVyXG4gKiBAcmV0dXJuIHRoZSBFc2NhcGVkIHBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZVBhdGhDb21wb25lbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmluZGV4T2YoXCIvXCIpID09PSAtMSAmJiBwYXRoLmluZGV4T2YoXCJ+XCIpID09PSAtMSlcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpO1xufVxuLyoqXG4gKiBVbmVzY2FwZXMgYSBqc29uIHBvaW50ZXIgcGF0aFxuICogQHBhcmFtIHBhdGggVGhlIGVzY2FwZWQgcG9pbnRlclxuICogQHJldHVybiBUaGUgdW5lc2NhcGVkIHBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuZXNjYXBlUGF0aENvbXBvbmVudChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvfjEvZywgXCIvXCIpLnJlcGxhY2UoL34wL2csIFwiflwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopIHtcbiAgICBsZXQgZm91bmQ7XG4gICAgZm9yIChsZXQga2V5IGluIHJvb3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KHJvb3QsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChyb290W2tleV0gPT09IG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgKyBcIi9cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByb290W2tleV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IF9nZXRQYXRoUmVjdXJzaXZlKHJvb3Rba2V5XSwgb2JqKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgIT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlUGF0aENvbXBvbmVudChrZXkpICsgXCIvXCIgKyBmb3VuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0aChyb290LCBvYmopIHtcbiAgICBpZiAocm9vdCA9PT0gb2JqKSB7XG4gICAgICAgIHJldHVybiBcIi9cIjtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IF9nZXRQYXRoUmVjdXJzaXZlKHJvb3QsIG9iaik7XG4gICAgaWYgKHBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0IG5vdCBmb3VuZCBpbiByb290XCIpO1xuICAgIH1cbiAgICByZXR1cm4gYC8ke3BhdGh9YDtcbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgY2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhbnkgdW5kZWZpbmVkIHZhbHVlcyBpbnNpZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNVbmRlZmluZWQob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVW5kZWZpbmVkKG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iaktleXMgPSBfb2JqZWN0S2V5cyhvYmopO1xuICAgICAgICAgICAgY29uc3Qgb2JqS2V5c0xlbmd0aCA9IG9iaktleXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmpLZXlzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVW5kZWZpbmVkKG9ialtvYmpLZXlzW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhdGNoRXJyb3JNZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UsIGFyZ3MpIHtcbiAgICBjb25zdCBtZXNzYWdlUGFydHMgPSBbbWVzc2FnZV07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXJncykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBhcmdzW2tleV0gPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoYXJnc1trZXldLCBudWxsLCAyKVxuICAgICAgICAgICAgOiBhcmdzW2tleV07IC8vIHByZXR0eSBwcmludFxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBtZXNzYWdlUGFydHMucHVzaChgJHtrZXl9OiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlUGFydHMuam9pbihcIlxcblwiKTtcbn1cbmV4cG9ydCBjbGFzcyBQYXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG5hbWUsIGluZGV4LCBvcGVyYXRpb24sIHRyZWUpIHtcbiAgICAgICAgc3VwZXIocGF0Y2hFcnJvck1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSwgeyBuYW1lLCBpbmRleCwgb3BlcmF0aW9uLCB0cmVlIH0pKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5kZXhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGluZGV4XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcGVyYXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJlZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJlZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTsgLy8gcmVzdG9yZSBwcm90b3R5cGUgY2hhaW4sIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDgzNDIzNTlcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gcGF0Y2hFcnJvck1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSwge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICAgICAgdHJlZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/utils/json.js":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/json.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseJsonMarkdown: () => (/* binding */ parseJsonMarkdown),\n/* harmony export */   parsePartialJson: () => (/* binding */ parsePartialJson)\n/* harmony export */ });\nfunction parseJsonMarkdown(s, parser = parsePartialJson) {\n    // eslint-disable-next-line no-param-reassign\n    s = s.trim();\n    const match = /```(json)?(.*)```/s.exec(s);\n    if (!match) {\n        return parser(s);\n    }\n    else {\n        return parser(match[2]);\n    }\n}\n// Adapted from https://github.com/KillianLucas/open-interpreter/blob/main/interpreter/core/llm/utils/parse_partial_json.py\n// MIT License\nfunction parsePartialJson(s) {\n    // If the input is undefined, return null to indicate failure.\n    if (typeof s === \"undefined\") {\n        return null;\n    }\n    // Attempt to parse the string as-is.\n    try {\n        return JSON.parse(s);\n    }\n    catch (error) {\n        // Pass\n    }\n    // Initialize variables.\n    let new_s = \"\";\n    const stack = [];\n    let isInsideString = false;\n    let escaped = false;\n    // Process each character in the string one at a time.\n    for (let char of s) {\n        if (isInsideString) {\n            if (char === '\"' && !escaped) {\n                isInsideString = false;\n            }\n            else if (char === \"\\n\" && !escaped) {\n                char = \"\\\\n\"; // Replace the newline character with the escape sequence.\n            }\n            else if (char === \"\\\\\") {\n                escaped = !escaped;\n            }\n            else {\n                escaped = false;\n            }\n        }\n        else {\n            if (char === '\"') {\n                isInsideString = true;\n                escaped = false;\n            }\n            else if (char === \"{\") {\n                stack.push(\"}\");\n            }\n            else if (char === \"[\") {\n                stack.push(\"]\");\n            }\n            else if (char === \"}\" || char === \"]\") {\n                if (stack && stack[stack.length - 1] === char) {\n                    stack.pop();\n                }\n                else {\n                    // Mismatched closing character; the input is malformed.\n                    return null;\n                }\n            }\n        }\n        // Append the processed character to the new string.\n        new_s += char;\n    }\n    // If we're still inside a string at the end of processing,\n    // we need to close the string.\n    if (isInsideString) {\n        new_s += '\"';\n    }\n    // Close any remaining open structures in the reverse order that they were opened.\n    for (let i = stack.length - 1; i >= 0; i -= 1) {\n        new_s += stack[i];\n    }\n    // Attempt to parse the modified string as JSON.\n    try {\n        return JSON.parse(new_s);\n    }\n    catch (error) {\n        // If we still can't parse the string as JSON, return null to indicate failure.\n        return null;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9qc29uLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHV0aWxzXFxqc29uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBwYXJzZUpzb25NYXJrZG93bihzLCBwYXJzZXIgPSBwYXJzZVBhcnRpYWxKc29uKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcyA9IHMudHJpbSgpO1xuICAgIGNvbnN0IG1hdGNoID0gL2BgYChqc29uKT8oLiopYGBgL3MuZXhlYyhzKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZXIocyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyc2VyKG1hdGNoWzJdKTtcbiAgICB9XG59XG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0tpbGxpYW5MdWNhcy9vcGVuLWludGVycHJldGVyL2Jsb2IvbWFpbi9pbnRlcnByZXRlci9jb3JlL2xsbS91dGlscy9wYXJzZV9wYXJ0aWFsX2pzb24ucHlcbi8vIE1JVCBMaWNlbnNlXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQYXJ0aWFsSnNvbihzKSB7XG4gICAgLy8gSWYgdGhlIGlucHV0IGlzIHVuZGVmaW5lZCwgcmV0dXJuIG51bGwgdG8gaW5kaWNhdGUgZmFpbHVyZS5cbiAgICBpZiAodHlwZW9mIHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgdGhlIHN0cmluZyBhcy1pcy5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFBhc3NcbiAgICB9XG4gICAgLy8gSW5pdGlhbGl6ZSB2YXJpYWJsZXMuXG4gICAgbGV0IG5ld19zID0gXCJcIjtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgIGxldCBpc0luc2lkZVN0cmluZyA9IGZhbHNlO1xuICAgIGxldCBlc2NhcGVkID0gZmFsc2U7XG4gICAgLy8gUHJvY2VzcyBlYWNoIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nIG9uZSBhdCBhIHRpbWUuXG4gICAgZm9yIChsZXQgY2hhciBvZiBzKSB7XG4gICAgICAgIGlmIChpc0luc2lkZVN0cmluZykge1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdcIicgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICBpc0luc2lkZVN0cmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gXCJcXG5cIiAmJiAhZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgIGNoYXIgPSBcIlxcXFxuXCI7IC8vIFJlcGxhY2UgdGhlIG5ld2xpbmUgY2hhcmFjdGVyIHdpdGggdGhlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBpc0luc2lkZVN0cmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKFwifVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChcIl1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBcIn1cIiB8fCBjaGFyID09PSBcIl1cIikge1xuICAgICAgICAgICAgICAgIGlmIChzdGFjayAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gY2hhcikge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1pc21hdGNoZWQgY2xvc2luZyBjaGFyYWN0ZXI7IHRoZSBpbnB1dCBpcyBtYWxmb3JtZWQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBlbmQgdGhlIHByb2Nlc3NlZCBjaGFyYWN0ZXIgdG8gdGhlIG5ldyBzdHJpbmcuXG4gICAgICAgIG5ld19zICs9IGNoYXI7XG4gICAgfVxuICAgIC8vIElmIHdlJ3JlIHN0aWxsIGluc2lkZSBhIHN0cmluZyBhdCB0aGUgZW5kIG9mIHByb2Nlc3NpbmcsXG4gICAgLy8gd2UgbmVlZCB0byBjbG9zZSB0aGUgc3RyaW5nLlxuICAgIGlmIChpc0luc2lkZVN0cmluZykge1xuICAgICAgICBuZXdfcyArPSAnXCInO1xuICAgIH1cbiAgICAvLyBDbG9zZSBhbnkgcmVtYWluaW5nIG9wZW4gc3RydWN0dXJlcyBpbiB0aGUgcmV2ZXJzZSBvcmRlciB0aGF0IHRoZXkgd2VyZSBvcGVuZWQuXG4gICAgZm9yIChsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIG5ld19zICs9IHN0YWNrW2ldO1xuICAgIH1cbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIHRoZSBtb2RpZmllZCBzdHJpbmcgYXMgSlNPTi5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShuZXdfcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiB3ZSBzdGlsbCBjYW4ndCBwYXJzZSB0aGUgc3RyaW5nIGFzIEpTT04sIHJldHVybiBudWxsIHRvIGluZGljYXRlIGZhaWx1cmUuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/utils/json.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/dist/utils/stream.js":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/stream.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncGeneratorWithSetup: () => (/* binding */ AsyncGeneratorWithSetup),\n/* harmony export */   IterableReadableStream: () => (/* binding */ IterableReadableStream),\n/* harmony export */   atee: () => (/* binding */ atee),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   pipeGeneratorWithSetup: () => (/* binding */ pipeGeneratorWithSetup)\n/* harmony export */ });\n/*\n * Support async iterator syntax for ReadableStreams in all environments.\n * Source: https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nclass IterableReadableStream extends ReadableStream {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"reader\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    ensureReader() {\n        if (!this.reader) {\n            this.reader = this.getReader();\n        }\n    }\n    async next() {\n        this.ensureReader();\n        try {\n            const result = await this.reader.read();\n            if (result.done) {\n                this.reader.releaseLock(); // release lock when stream becomes closed\n                return {\n                    done: true,\n                    value: undefined,\n                };\n            }\n            else {\n                return {\n                    done: false,\n                    value: result.value,\n                };\n            }\n        }\n        catch (e) {\n            this.reader.releaseLock(); // release lock when stream becomes errored\n            throw e;\n        }\n    }\n    async return() {\n        this.ensureReader();\n        // If wrapped in a Node stream, cancel is already called.\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        return { done: true, value: undefined };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async throw(e) {\n        this.ensureReader();\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        throw e;\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    static fromReadableStream(stream) {\n        // From https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#reading_the_stream\n        const reader = stream.getReader();\n        return new IterableReadableStream({\n            start(controller) {\n                return pump();\n                function pump() {\n                    return reader.read().then(({ done, value }) => {\n                        // When no more data needs to be consumed, close the stream\n                        if (done) {\n                            controller.close();\n                            return;\n                        }\n                        // Enqueue the next data chunk into our target stream\n                        controller.enqueue(value);\n                        return pump();\n                    });\n                }\n            },\n            cancel() {\n                reader.releaseLock();\n            },\n        });\n    }\n    static fromAsyncGenerator(generator) {\n        return new IterableReadableStream({\n            async pull(controller) {\n                const { value, done } = await generator.next();\n                // When no more data needs to be consumed, close the stream\n                if (done) {\n                    controller.close();\n                }\n                // Fix: `else if (value)` will hang the streaming when nullish value (e.g. empty string) is pulled\n                controller.enqueue(value);\n            },\n            async cancel(reason) {\n                await generator.return(reason);\n            },\n        });\n    }\n}\nfunction atee(iter, length = 2) {\n    const buffers = Array.from({ length }, () => []);\n    return buffers.map(async function* makeIter(buffer) {\n        while (true) {\n            if (buffer.length === 0) {\n                const result = await iter.next();\n                for (const buffer of buffers) {\n                    buffer.push(result);\n                }\n            }\n            else if (buffer[0].done) {\n                return;\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                yield buffer.shift().value;\n            }\n        }\n    });\n}\nfunction concat(first, second) {\n    if (Array.isArray(first) && Array.isArray(second)) {\n        return first.concat(second);\n    }\n    else if (typeof first === \"string\" && typeof second === \"string\") {\n        return (first + second);\n    }\n    else if (typeof first === \"number\" && typeof second === \"number\") {\n        return (first + second);\n    }\n    else if (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    \"concat\" in first &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        typeof first.concat === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return first.concat(second);\n    }\n    else if (typeof first === \"object\" && typeof second === \"object\") {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const chunk = { ...first };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        for (const [key, value] of Object.entries(second)) {\n            if (key in chunk && !Array.isArray(chunk[key])) {\n                chunk[key] = concat(chunk[key], value);\n            }\n            else {\n                chunk[key] = value;\n            }\n        }\n        return chunk;\n    }\n    else {\n        throw new Error(`Cannot concat ${typeof first} and ${typeof second}`);\n    }\n}\nclass AsyncGeneratorWithSetup {\n    constructor(generator, startSetup) {\n        Object.defineProperty(this, \"generator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"setup\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"firstResult\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"firstResultUsed\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.generator = generator;\n        // setup is a promise that resolves only after the first iterator value\n        // is available. this is useful when setup of several piped generators\n        // needs to happen in logical order, ie. in the order in which input to\n        // to each generator is available.\n        this.setup = new Promise((resolve, reject) => {\n            this.firstResult = generator.next();\n            if (startSetup) {\n                this.firstResult.then(startSetup).then(resolve, reject);\n            }\n            else {\n                this.firstResult.then((_result) => resolve(undefined), reject);\n            }\n        });\n    }\n    async next(...args) {\n        if (!this.firstResultUsed) {\n            this.firstResultUsed = true;\n            return this.firstResult;\n        }\n        return this.generator.next(...args);\n    }\n    async return(value) {\n        return this.generator.return(value);\n    }\n    async throw(e) {\n        return this.generator.throw(e);\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n}\nasync function pipeGeneratorWithSetup(to, generator, startSetup, ...args) {\n    const gen = new AsyncGeneratorWithSetup(generator, startSetup);\n    const setup = await gen.setup;\n    return { output: to(gen, setup, ...args), setup };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9zdHJlYW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCx1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsdUNBQXVDO0FBQ3ZDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1AsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxjQUFjLE1BQU0sY0FBYztBQUMzRTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdXRpbHNcXHN0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogU3VwcG9ydCBhc3luYyBpdGVyYXRvciBzeW50YXggZm9yIFJlYWRhYmxlU3RyZWFtcyBpbiBhbGwgZW52aXJvbm1lbnRzLlxuICogU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vTWF0dGlhc0J1ZWxlbnMvd2ViLXN0cmVhbXMtcG9seWZpbGwvcHVsbC8xMjIjaXNzdWVjb21tZW50LTE2MjczNTQ0OTBcbiAqL1xuZXhwb3J0IGNsYXNzIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0gZXh0ZW5kcyBSZWFkYWJsZVN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlYWRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbnN1cmVSZWFkZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyID0gdGhpcy5nZXRSZWFkZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICB0aGlzLmVuc3VyZVJlYWRlcigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgY2xvc2VkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgZXJyb3JlZFxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZXR1cm4oKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVhZGVyKCk7XG4gICAgICAgIC8vIElmIHdyYXBwZWQgaW4gYSBOb2RlIHN0cmVhbSwgY2FuY2VsIGlzIGFscmVhZHkgY2FsbGVkLlxuICAgICAgICBpZiAodGhpcy5sb2NrZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSB0aGlzLnJlYWRlci5jYW5jZWwoKTsgLy8gY2FuY2VsIGZpcnN0LCBidXQgZG9uJ3QgYXdhaXQgeWV0XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgZmlyc3RcbiAgICAgICAgICAgIGF3YWl0IGNhbmNlbFByb21pc2U7IC8vIG5vdyBhd2FpdCBpdFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyB0aHJvdyhlKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVhZGVyKCk7XG4gICAgICAgIGlmICh0aGlzLmxvY2tlZCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IHRoaXMucmVhZGVyLmNhbmNlbCgpOyAvLyBjYW5jZWwgZmlyc3QsIGJ1dCBkb24ndCBhd2FpdCB5ZXRcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayBmaXJzdFxuICAgICAgICAgICAgYXdhaXQgY2FuY2VsUHJvbWlzZTsgLy8gbm93IGF3YWl0IGl0XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIC8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N0cmVhbXNfQVBJL1VzaW5nX3JlYWRhYmxlX3N0cmVhbXMjcmVhZGluZ190aGVfc3RyZWFtXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHVtcCgpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZCgpLnRoZW4oKHsgZG9uZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBubyBtb3JlIGRhdGEgbmVlZHMgdG8gYmUgY29uc3VtZWQsIGNsb3NlIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVucXVldWUgdGhlIG5leHQgZGF0YSBjaHVuayBpbnRvIG91ciB0YXJnZXQgc3RyZWFtXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbmNlbCgpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFzeW5jR2VuZXJhdG9yKGdlbmVyYXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgZ2VuZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIG5vIG1vcmUgZGF0YSBuZWVkcyB0byBiZSBjb25zdW1lZCwgY2xvc2UgdGhlIHN0cmVhbVxuICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRml4OiBgZWxzZSBpZiAodmFsdWUpYCB3aWxsIGhhbmcgdGhlIHN0cmVhbWluZyB3aGVuIG51bGxpc2ggdmFsdWUgKGUuZy4gZW1wdHkgc3RyaW5nKSBpcyBwdWxsZWRcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jIGNhbmNlbChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBnZW5lcmF0b3IucmV0dXJuKHJlYXNvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYXRlZShpdGVyLCBsZW5ndGggPSAyKSB7XG4gICAgY29uc3QgYnVmZmVycyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSwgKCkgPT4gW10pO1xuICAgIHJldHVybiBidWZmZXJzLm1hcChhc3luYyBmdW5jdGlvbiogbWFrZUl0ZXIoYnVmZmVyKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGl0ZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIGJ1ZmZlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChidWZmZXJbMF0uZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgeWllbGQgYnVmZmVyLnNoaWZ0KCkudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoZmlyc3QsIHNlY29uZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZpcnN0KSAmJiBBcnJheS5pc0FycmF5KHNlY29uZCkpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0LmNvbmNhdChzZWNvbmQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZmlyc3QgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHNlY29uZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gKGZpcnN0ICsgc2Vjb25kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZpcnN0ID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBzZWNvbmQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIChmaXJzdCArIHNlY29uZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgXCJjb25jYXRcIiBpbiBmaXJzdCAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0eXBlb2YgZmlyc3QuY29uY2F0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIGZpcnN0LmNvbmNhdChzZWNvbmQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZmlyc3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHNlY29uZCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBjaHVuayA9IHsgLi4uZmlyc3QgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc2Vjb25kKSkge1xuICAgICAgICAgICAgaWYgKGtleSBpbiBjaHVuayAmJiAhQXJyYXkuaXNBcnJheShjaHVua1trZXldKSkge1xuICAgICAgICAgICAgICAgIGNodW5rW2tleV0gPSBjb25jYXQoY2h1bmtba2V5XSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2h1bmtba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbmNhdCAke3R5cGVvZiBmaXJzdH0gYW5kICR7dHlwZW9mIHNlY29uZH1gKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAge1xuICAgIGNvbnN0cnVjdG9yKGdlbmVyYXRvciwgc3RhcnRTZXR1cCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZW5lcmF0b3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0dXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmlyc3RSZXN1bHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmlyc3RSZXN1bHRVc2VkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgIC8vIHNldHVwIGlzIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9ubHkgYWZ0ZXIgdGhlIGZpcnN0IGl0ZXJhdG9yIHZhbHVlXG4gICAgICAgIC8vIGlzIGF2YWlsYWJsZS4gdGhpcyBpcyB1c2VmdWwgd2hlbiBzZXR1cCBvZiBzZXZlcmFsIHBpcGVkIGdlbmVyYXRvcnNcbiAgICAgICAgLy8gbmVlZHMgdG8gaGFwcGVuIGluIGxvZ2ljYWwgb3JkZXIsIGllLiBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggaW5wdXQgdG9cbiAgICAgICAgLy8gdG8gZWFjaCBnZW5lcmF0b3IgaXMgYXZhaWxhYmxlLlxuICAgICAgICB0aGlzLnNldHVwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5maXJzdFJlc3VsdCA9IGdlbmVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoc3RhcnRTZXR1cCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RSZXN1bHQudGhlbihzdGFydFNldHVwKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0UmVzdWx0LnRoZW4oKF9yZXN1bHQpID0+IHJlc29sdmUodW5kZWZpbmVkKSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIG5leHQoLi4uYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuZmlyc3RSZXN1bHRVc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0UmVzdWx0VXNlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0b3IubmV4dCguLi5hcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgcmV0dXJuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRvci5yZXR1cm4odmFsdWUpO1xuICAgIH1cbiAgICBhc3luYyB0aHJvdyhlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRvci50aHJvdyhlKTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBpcGVHZW5lcmF0b3JXaXRoU2V0dXAodG8sIGdlbmVyYXRvciwgc3RhcnRTZXR1cCwgLi4uYXJncykge1xuICAgIGNvbnN0IGdlbiA9IG5ldyBBc3luY0dlbmVyYXRvcldpdGhTZXR1cChnZW5lcmF0b3IsIHN0YXJ0U2V0dXApO1xuICAgIGNvbnN0IHNldHVwID0gYXdhaXQgZ2VuLnNldHVwO1xuICAgIHJldHVybiB7IG91dHB1dDogdG8oZ2VuLCBzZXR1cCwgLi4uYXJncyksIHNldHVwIH07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/dist/utils/stream.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/documents.js":
/*!***************************************************!*\
  !*** ./node_modules/@langchain/core/documents.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseDocumentTransformer: () => (/* reexport safe */ _dist_documents_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseDocumentTransformer),
/* harmony export */   Document: () => (/* reexport safe */ _dist_documents_index_js__WEBPACK_IMPORTED_MODULE_0__.Document),
/* harmony export */   MappingDocumentTransformer: () => (/* reexport safe */ _dist_documents_index_js__WEBPACK_IMPORTED_MODULE_0__.MappingDocumentTransformer)
/* harmony export */ });
/* harmony import */ var _dist_documents_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/documents/index.js */ "(action-browser)/./node_modules/@langchain/core/dist/documents/index.js");


/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/node_modules/ansi-styles/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/ansi-styles/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nconst ANSI_BACKGROUND_OFFSET = 10;\n\nconst wrapAnsi256 = (offset = 0) => code => `\\u001B[${38 + offset};5;${code}m`;\n\nconst wrapAnsi16m = (offset = 0) => (red, green, blue) => `\\u001B[${38 + offset};2;${red};${green};${blue}m`;\n\nfunction assembleStyles() {\n\tconst codes = new Map();\n\tconst styles = {\n\t\tmodifier: {\n\t\t\treset: [0, 0],\n\t\t\t// 21 isn't widely supported and 22 does the same thing\n\t\t\tbold: [1, 22],\n\t\t\tdim: [2, 22],\n\t\t\titalic: [3, 23],\n\t\t\tunderline: [4, 24],\n\t\t\toverline: [53, 55],\n\t\t\tinverse: [7, 27],\n\t\t\thidden: [8, 28],\n\t\t\tstrikethrough: [9, 29]\n\t\t},\n\t\tcolor: {\n\t\t\tblack: [30, 39],\n\t\t\tred: [31, 39],\n\t\t\tgreen: [32, 39],\n\t\t\tyellow: [33, 39],\n\t\t\tblue: [34, 39],\n\t\t\tmagenta: [35, 39],\n\t\t\tcyan: [36, 39],\n\t\t\twhite: [37, 39],\n\n\t\t\t// Bright color\n\t\t\tblackBright: [90, 39],\n\t\t\tredBright: [91, 39],\n\t\t\tgreenBright: [92, 39],\n\t\t\tyellowBright: [93, 39],\n\t\t\tblueBright: [94, 39],\n\t\t\tmagentaBright: [95, 39],\n\t\t\tcyanBright: [96, 39],\n\t\t\twhiteBright: [97, 39]\n\t\t},\n\t\tbgColor: {\n\t\t\tbgBlack: [40, 49],\n\t\t\tbgRed: [41, 49],\n\t\t\tbgGreen: [42, 49],\n\t\t\tbgYellow: [43, 49],\n\t\t\tbgBlue: [44, 49],\n\t\t\tbgMagenta: [45, 49],\n\t\t\tbgCyan: [46, 49],\n\t\t\tbgWhite: [47, 49],\n\n\t\t\t// Bright color\n\t\t\tbgBlackBright: [100, 49],\n\t\t\tbgRedBright: [101, 49],\n\t\t\tbgGreenBright: [102, 49],\n\t\t\tbgYellowBright: [103, 49],\n\t\t\tbgBlueBright: [104, 49],\n\t\t\tbgMagentaBright: [105, 49],\n\t\t\tbgCyanBright: [106, 49],\n\t\t\tbgWhiteBright: [107, 49]\n\t\t}\n\t};\n\n\t// Alias bright black as gray (and grey)\n\tstyles.color.gray = styles.color.blackBright;\n\tstyles.bgColor.bgGray = styles.bgColor.bgBlackBright;\n\tstyles.color.grey = styles.color.blackBright;\n\tstyles.bgColor.bgGrey = styles.bgColor.bgBlackBright;\n\n\tfor (const [groupName, group] of Object.entries(styles)) {\n\t\tfor (const [styleName, style] of Object.entries(group)) {\n\t\t\tstyles[styleName] = {\n\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\tclose: `\\u001B[${style[1]}m`\n\t\t\t};\n\n\t\t\tgroup[styleName] = styles[styleName];\n\n\t\t\tcodes.set(style[0], style[1]);\n\t\t}\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false\n\t\t});\n\t}\n\n\tObject.defineProperty(styles, 'codes', {\n\t\tvalue: codes,\n\t\tenumerable: false\n\t});\n\n\tstyles.color.close = '\\u001B[39m';\n\tstyles.bgColor.close = '\\u001B[49m';\n\n\tstyles.color.ansi256 = wrapAnsi256();\n\tstyles.color.ansi16m = wrapAnsi16m();\n\tstyles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);\n\tstyles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);\n\n\t// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js\n\tObject.defineProperties(styles, {\n\t\trgbToAnsi256: {\n\t\t\tvalue: (red, green, blue) => {\n\t\t\t\t// We use the extended greyscale palette here, with the exception of\n\t\t\t\t// black and white. normal palette only has 4 greyscale shades.\n\t\t\t\tif (red === green && green === blue) {\n\t\t\t\t\tif (red < 8) {\n\t\t\t\t\t\treturn 16;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (red > 248) {\n\t\t\t\t\t\treturn 231;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Math.round(((red - 8) / 247) * 24) + 232;\n\t\t\t\t}\n\n\t\t\t\treturn 16 +\n\t\t\t\t\t(36 * Math.round(red / 255 * 5)) +\n\t\t\t\t\t(6 * Math.round(green / 255 * 5)) +\n\t\t\t\t\tMath.round(blue / 255 * 5);\n\t\t\t},\n\t\t\tenumerable: false\n\t\t},\n\t\thexToRgb: {\n\t\t\tvalue: hex => {\n\t\t\t\tconst matches = /(?<colorString>[a-f\\d]{6}|[a-f\\d]{3})/i.exec(hex.toString(16));\n\t\t\t\tif (!matches) {\n\t\t\t\t\treturn [0, 0, 0];\n\t\t\t\t}\n\n\t\t\t\tlet {colorString} = matches.groups;\n\n\t\t\t\tif (colorString.length === 3) {\n\t\t\t\t\tcolorString = colorString.split('').map(character => character + character).join('');\n\t\t\t\t}\n\n\t\t\t\tconst integer = Number.parseInt(colorString, 16);\n\n\t\t\t\treturn [\n\t\t\t\t\t(integer >> 16) & 0xFF,\n\t\t\t\t\t(integer >> 8) & 0xFF,\n\t\t\t\t\tinteger & 0xFF\n\t\t\t\t];\n\t\t\t},\n\t\t\tenumerable: false\n\t\t},\n\t\thexToAnsi256: {\n\t\t\tvalue: hex => styles.rgbToAnsi256(...styles.hexToRgb(hex)),\n\t\t\tenumerable: false\n\t\t}\n\t});\n\n\treturn styles;\n}\n\n// Make the export immutable\nObject.defineProperty(module, 'exports', {\n\tenumerable: true,\n\tget: assembleStyles\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL2Fuc2ktc3R5bGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBYTs7QUFFYjs7QUFFQSxzREFBc0QsYUFBYSxFQUFFLEVBQUUsS0FBSzs7QUFFNUUsb0VBQW9FLGFBQWEsRUFBRSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsS0FBSzs7QUFFMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0IscUJBQXFCLFNBQVM7QUFDOUI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0Q0FBNEMsRUFBRSxTQUFTLEVBQUU7QUFDekQ7QUFDQTtBQUNBOztBQUVBLFNBQVMsYUFBYTs7QUFFdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcbm9kZV9tb2R1bGVzXFxhbnNpLXN0eWxlc1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBTlNJX0JBQ0tHUk9VTkRfT0ZGU0VUID0gMTA7XG5cbmNvbnN0IHdyYXBBbnNpMjU2ID0gKG9mZnNldCA9IDApID0+IGNvZGUgPT4gYFxcdTAwMUJbJHszOCArIG9mZnNldH07NTske2NvZGV9bWA7XG5cbmNvbnN0IHdyYXBBbnNpMTZtID0gKG9mZnNldCA9IDApID0+IChyZWQsIGdyZWVuLCBibHVlKSA9PiBgXFx1MDAxQlskezM4ICsgb2Zmc2V0fTsyOyR7cmVkfTske2dyZWVufTske2JsdWV9bWA7XG5cbmZ1bmN0aW9uIGFzc2VtYmxlU3R5bGVzKCkge1xuXHRjb25zdCBjb2RlcyA9IG5ldyBNYXAoKTtcblx0Y29uc3Qgc3R5bGVzID0ge1xuXHRcdG1vZGlmaWVyOiB7XG5cdFx0XHRyZXNldDogWzAsIDBdLFxuXHRcdFx0Ly8gMjEgaXNuJ3Qgd2lkZWx5IHN1cHBvcnRlZCBhbmQgMjIgZG9lcyB0aGUgc2FtZSB0aGluZ1xuXHRcdFx0Ym9sZDogWzEsIDIyXSxcblx0XHRcdGRpbTogWzIsIDIyXSxcblx0XHRcdGl0YWxpYzogWzMsIDIzXSxcblx0XHRcdHVuZGVybGluZTogWzQsIDI0XSxcblx0XHRcdG92ZXJsaW5lOiBbNTMsIDU1XSxcblx0XHRcdGludmVyc2U6IFs3LCAyN10sXG5cdFx0XHRoaWRkZW46IFs4LCAyOF0sXG5cdFx0XHRzdHJpa2V0aHJvdWdoOiBbOSwgMjldXG5cdFx0fSxcblx0XHRjb2xvcjoge1xuXHRcdFx0YmxhY2s6IFszMCwgMzldLFxuXHRcdFx0cmVkOiBbMzEsIDM5XSxcblx0XHRcdGdyZWVuOiBbMzIsIDM5XSxcblx0XHRcdHllbGxvdzogWzMzLCAzOV0sXG5cdFx0XHRibHVlOiBbMzQsIDM5XSxcblx0XHRcdG1hZ2VudGE6IFszNSwgMzldLFxuXHRcdFx0Y3lhbjogWzM2LCAzOV0sXG5cdFx0XHR3aGl0ZTogWzM3LCAzOV0sXG5cblx0XHRcdC8vIEJyaWdodCBjb2xvclxuXHRcdFx0YmxhY2tCcmlnaHQ6IFs5MCwgMzldLFxuXHRcdFx0cmVkQnJpZ2h0OiBbOTEsIDM5XSxcblx0XHRcdGdyZWVuQnJpZ2h0OiBbOTIsIDM5XSxcblx0XHRcdHllbGxvd0JyaWdodDogWzkzLCAzOV0sXG5cdFx0XHRibHVlQnJpZ2h0OiBbOTQsIDM5XSxcblx0XHRcdG1hZ2VudGFCcmlnaHQ6IFs5NSwgMzldLFxuXHRcdFx0Y3lhbkJyaWdodDogWzk2LCAzOV0sXG5cdFx0XHR3aGl0ZUJyaWdodDogWzk3LCAzOV1cblx0XHR9LFxuXHRcdGJnQ29sb3I6IHtcblx0XHRcdGJnQmxhY2s6IFs0MCwgNDldLFxuXHRcdFx0YmdSZWQ6IFs0MSwgNDldLFxuXHRcdFx0YmdHcmVlbjogWzQyLCA0OV0sXG5cdFx0XHRiZ1llbGxvdzogWzQzLCA0OV0sXG5cdFx0XHRiZ0JsdWU6IFs0NCwgNDldLFxuXHRcdFx0YmdNYWdlbnRhOiBbNDUsIDQ5XSxcblx0XHRcdGJnQ3lhbjogWzQ2LCA0OV0sXG5cdFx0XHRiZ1doaXRlOiBbNDcsIDQ5XSxcblxuXHRcdFx0Ly8gQnJpZ2h0IGNvbG9yXG5cdFx0XHRiZ0JsYWNrQnJpZ2h0OiBbMTAwLCA0OV0sXG5cdFx0XHRiZ1JlZEJyaWdodDogWzEwMSwgNDldLFxuXHRcdFx0YmdHcmVlbkJyaWdodDogWzEwMiwgNDldLFxuXHRcdFx0YmdZZWxsb3dCcmlnaHQ6IFsxMDMsIDQ5XSxcblx0XHRcdGJnQmx1ZUJyaWdodDogWzEwNCwgNDldLFxuXHRcdFx0YmdNYWdlbnRhQnJpZ2h0OiBbMTA1LCA0OV0sXG5cdFx0XHRiZ0N5YW5CcmlnaHQ6IFsxMDYsIDQ5XSxcblx0XHRcdGJnV2hpdGVCcmlnaHQ6IFsxMDcsIDQ5XVxuXHRcdH1cblx0fTtcblxuXHQvLyBBbGlhcyBicmlnaHQgYmxhY2sgYXMgZ3JheSAoYW5kIGdyZXkpXG5cdHN0eWxlcy5jb2xvci5ncmF5ID0gc3R5bGVzLmNvbG9yLmJsYWNrQnJpZ2h0O1xuXHRzdHlsZXMuYmdDb2xvci5iZ0dyYXkgPSBzdHlsZXMuYmdDb2xvci5iZ0JsYWNrQnJpZ2h0O1xuXHRzdHlsZXMuY29sb3IuZ3JleSA9IHN0eWxlcy5jb2xvci5ibGFja0JyaWdodDtcblx0c3R5bGVzLmJnQ29sb3IuYmdHcmV5ID0gc3R5bGVzLmJnQ29sb3IuYmdCbGFja0JyaWdodDtcblxuXHRmb3IgKGNvbnN0IFtncm91cE5hbWUsIGdyb3VwXSBvZiBPYmplY3QuZW50cmllcyhzdHlsZXMpKSB7XG5cdFx0Zm9yIChjb25zdCBbc3R5bGVOYW1lLCBzdHlsZV0gb2YgT2JqZWN0LmVudHJpZXMoZ3JvdXApKSB7XG5cdFx0XHRzdHlsZXNbc3R5bGVOYW1lXSA9IHtcblx0XHRcdFx0b3BlbjogYFxcdTAwMUJbJHtzdHlsZVswXX1tYCxcblx0XHRcdFx0Y2xvc2U6IGBcXHUwMDFCWyR7c3R5bGVbMV19bWBcblx0XHRcdH07XG5cblx0XHRcdGdyb3VwW3N0eWxlTmFtZV0gPSBzdHlsZXNbc3R5bGVOYW1lXTtcblxuXHRcdFx0Y29kZXMuc2V0KHN0eWxlWzBdLCBzdHlsZVsxXSk7XG5cdFx0fVxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHN0eWxlcywgZ3JvdXBOYW1lLCB7XG5cdFx0XHR2YWx1ZTogZ3JvdXAsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZVxuXHRcdH0pO1xuXHR9XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHN0eWxlcywgJ2NvZGVzJywge1xuXHRcdHZhbHVlOiBjb2Rlcyxcblx0XHRlbnVtZXJhYmxlOiBmYWxzZVxuXHR9KTtcblxuXHRzdHlsZXMuY29sb3IuY2xvc2UgPSAnXFx1MDAxQlszOW0nO1xuXHRzdHlsZXMuYmdDb2xvci5jbG9zZSA9ICdcXHUwMDFCWzQ5bSc7XG5cblx0c3R5bGVzLmNvbG9yLmFuc2kyNTYgPSB3cmFwQW5zaTI1NigpO1xuXHRzdHlsZXMuY29sb3IuYW5zaTE2bSA9IHdyYXBBbnNpMTZtKCk7XG5cdHN0eWxlcy5iZ0NvbG9yLmFuc2kyNTYgPSB3cmFwQW5zaTI1NihBTlNJX0JBQ0tHUk9VTkRfT0ZGU0VUKTtcblx0c3R5bGVzLmJnQ29sb3IuYW5zaTE2bSA9IHdyYXBBbnNpMTZtKEFOU0lfQkFDS0dST1VORF9PRkZTRVQpO1xuXG5cdC8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL1FpeC0vY29sb3ItY29udmVydC9ibG9iLzNmMGUwZDRlOTJlMjM1Nzk2Y2NiMTdmNmU4NWM3MjA5NGE2NTFmNDkvY29udmVyc2lvbnMuanNcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3R5bGVzLCB7XG5cdFx0cmdiVG9BbnNpMjU2OiB7XG5cdFx0XHR2YWx1ZTogKHJlZCwgZ3JlZW4sIGJsdWUpID0+IHtcblx0XHRcdFx0Ly8gV2UgdXNlIHRoZSBleHRlbmRlZCBncmV5c2NhbGUgcGFsZXR0ZSBoZXJlLCB3aXRoIHRoZSBleGNlcHRpb24gb2Zcblx0XHRcdFx0Ly8gYmxhY2sgYW5kIHdoaXRlLiBub3JtYWwgcGFsZXR0ZSBvbmx5IGhhcyA0IGdyZXlzY2FsZSBzaGFkZXMuXG5cdFx0XHRcdGlmIChyZWQgPT09IGdyZWVuICYmIGdyZWVuID09PSBibHVlKSB7XG5cdFx0XHRcdFx0aWYgKHJlZCA8IDgpIHtcblx0XHRcdFx0XHRcdHJldHVybiAxNjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAocmVkID4gMjQ4KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gMjMxO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCgocmVkIC0gOCkgLyAyNDcpICogMjQpICsgMjMyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIDE2ICtcblx0XHRcdFx0XHQoMzYgKiBNYXRoLnJvdW5kKHJlZCAvIDI1NSAqIDUpKSArXG5cdFx0XHRcdFx0KDYgKiBNYXRoLnJvdW5kKGdyZWVuIC8gMjU1ICogNSkpICtcblx0XHRcdFx0XHRNYXRoLnJvdW5kKGJsdWUgLyAyNTUgKiA1KTtcblx0XHRcdH0sXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZVxuXHRcdH0sXG5cdFx0aGV4VG9SZ2I6IHtcblx0XHRcdHZhbHVlOiBoZXggPT4ge1xuXHRcdFx0XHRjb25zdCBtYXRjaGVzID0gLyg/PGNvbG9yU3RyaW5nPlthLWZcXGRdezZ9fFthLWZcXGRdezN9KS9pLmV4ZWMoaGV4LnRvU3RyaW5nKDE2KSk7XG5cdFx0XHRcdGlmICghbWF0Y2hlcykge1xuXHRcdFx0XHRcdHJldHVybiBbMCwgMCwgMF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZXQge2NvbG9yU3RyaW5nfSA9IG1hdGNoZXMuZ3JvdXBzO1xuXG5cdFx0XHRcdGlmIChjb2xvclN0cmluZy5sZW5ndGggPT09IDMpIHtcblx0XHRcdFx0XHRjb2xvclN0cmluZyA9IGNvbG9yU3RyaW5nLnNwbGl0KCcnKS5tYXAoY2hhcmFjdGVyID0+IGNoYXJhY3RlciArIGNoYXJhY3Rlcikuam9pbignJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBpbnRlZ2VyID0gTnVtYmVyLnBhcnNlSW50KGNvbG9yU3RyaW5nLCAxNik7XG5cblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHQoaW50ZWdlciA+PiAxNikgJiAweEZGLFxuXHRcdFx0XHRcdChpbnRlZ2VyID4+IDgpICYgMHhGRixcblx0XHRcdFx0XHRpbnRlZ2VyICYgMHhGRlxuXHRcdFx0XHRdO1xuXHRcdFx0fSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fSxcblx0XHRoZXhUb0Fuc2kyNTY6IHtcblx0XHRcdHZhbHVlOiBoZXggPT4gc3R5bGVzLnJnYlRvQW5zaTI1NiguLi5zdHlsZXMuaGV4VG9SZ2IoaGV4KSksXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZVxuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuLy8gTWFrZSB0aGUgZXhwb3J0IGltbXV0YWJsZVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgJ2V4cG9ydHMnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogYXNzZW1ibGVTdHlsZXNcbn0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/node_modules/ansi-styles/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID: (crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9uYXRpdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRCO0FBQzVCLGlFQUFlO0FBQ2YsY0FBYywwREFBaUI7QUFDL0IsQ0FBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXG5vZGVfbW9kdWxlc1xcdXVpZFxcZGlzdFxcZXNtLW5vZGVcXG5hdGl2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5leHBvcnQgZGVmYXVsdCB7XG4gIHJhbmRvbVVVSUQ6IGNyeXB0by5yYW5kb21VVUlEXG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9yZWdleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYyxFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxHQUFHLHlDQUF5QyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXG5vZGVfbW9kdWxlc1xcdXVpZFxcZGlzdFxcZXNtLW5vZGVcXHJlZ2V4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9ybmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRCO0FBQzVCLHVDQUF1Qzs7QUFFdkM7QUFDZTtBQUNmO0FBQ0EsSUFBSSw0REFBcUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcbm9kZV9tb2R1bGVzXFx1dWlkXFxkaXN0XFxlc20tbm9kZVxccm5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmNvbnN0IHJuZHM4UG9vbCA9IG5ldyBVaW50OEFycmF5KDI1Nik7IC8vICMgb2YgcmFuZG9tIHZhbHVlcyB0byBwcmUtYWxsb2NhdGVcblxubGV0IHBvb2xQdHIgPSBybmRzOFBvb2wubGVuZ3RoO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICBpZiAocG9vbFB0ciA+IHJuZHM4UG9vbC5sZW5ndGggLSAxNikge1xuICAgIGNyeXB0by5yYW5kb21GaWxsU3luYyhybmRzOFBvb2wpO1xuICAgIHBvb2xQdHIgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJuZHM4UG9vbC5zbGljZShwb29sUHRyLCBwb29sUHRyICs9IDE2KTtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zdHJpbmdpZnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLFNBQVMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1ub2RlXFxzdHJpbmdpZnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5cbmNvbnN0IGJ5dGVUb0hleCA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zbGljZSgxKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICByZXR1cm4gYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV07XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgY29uc3QgdXVpZCA9IHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlDO0FBQ047QUFDc0I7O0FBRWpEO0FBQ0EsTUFBTSxrREFBTTtBQUNaLFdBQVcsa0RBQU07QUFDakI7O0FBRUE7QUFDQSxpREFBaUQsK0NBQUcsS0FBSzs7QUFFekQ7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUEsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVMsOERBQWU7QUFDeEI7O0FBRUEsaUVBQWUsRUFBRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXG5vZGVfbW9kdWxlc1xcdXVpZFxcZGlzdFxcZXNtLW5vZGVcXHY0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBuYXRpdmUgZnJvbSAnLi9uYXRpdmUuanMnO1xuaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGlmIChuYXRpdmUucmFuZG9tVVVJRCAmJiAhYnVmICYmICFvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5hdGl2ZS5yYW5kb21VVUlEKCk7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiB1bnNhZmVTdHJpbmdpZnkocm5kcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHY0OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92YWxpZGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQjs7QUFFL0I7QUFDQSxxQ0FBcUMsaURBQUs7QUFDMUM7O0FBRUEsaUVBQWUsUUFBUSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXG5vZGVfbW9kdWxlc1xcdXVpZFxcZGlzdFxcZXNtLW5vZGVcXHZhbGlkYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/core/utils/env.js":
/*!***************************************************!*\
  !*** ./node_modules/@langchain/core/utils/env.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getEnv: () => (/* reexport safe */ _dist_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnv),
/* harmony export */   getEnvironmentVariable: () => (/* reexport safe */ _dist_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable),
/* harmony export */   getRuntimeEnvironment: () => (/* reexport safe */ _dist_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getRuntimeEnvironment),
/* harmony export */   isBrowser: () => (/* reexport safe */ _dist_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.isBrowser),
/* harmony export */   isDeno: () => (/* reexport safe */ _dist_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.isDeno),
/* harmony export */   isJsDom: () => (/* reexport safe */ _dist_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.isJsDom),
/* harmony export */   isNode: () => (/* reexport safe */ _dist_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.isNode),
/* harmony export */   isWebWorker: () => (/* reexport safe */ _dist_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.isWebWorker)
/* harmony export */ });
/* harmony import */ var _dist_utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/utils/env.js */ "(action-browser)/./node_modules/@langchain/core/dist/utils/env.js");


/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CharacterTextSplitter: () => (/* reexport safe */ _text_splitter_js__WEBPACK_IMPORTED_MODULE_0__.CharacterTextSplitter),\n/* harmony export */   LatexTextSplitter: () => (/* reexport safe */ _text_splitter_js__WEBPACK_IMPORTED_MODULE_0__.LatexTextSplitter),\n/* harmony export */   MarkdownTextSplitter: () => (/* reexport safe */ _text_splitter_js__WEBPACK_IMPORTED_MODULE_0__.MarkdownTextSplitter),\n/* harmony export */   RecursiveCharacterTextSplitter: () => (/* reexport safe */ _text_splitter_js__WEBPACK_IMPORTED_MODULE_0__.RecursiveCharacterTextSplitter),\n/* harmony export */   SupportedTextSplitterLanguages: () => (/* reexport safe */ _text_splitter_js__WEBPACK_IMPORTED_MODULE_0__.SupportedTextSplitterLanguages),\n/* harmony export */   TextSplitter: () => (/* reexport safe */ _text_splitter_js__WEBPACK_IMPORTED_MODULE_0__.TextSplitter),\n/* harmony export */   TokenTextSplitter: () => (/* reexport safe */ _text_splitter_js__WEBPACK_IMPORTED_MODULE_0__.TokenTextSplitter)\n/* harmony export */ });\n/* harmony import */ var _text_splitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text_splitter.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/dist/text_splitter.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFtQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXHRleHRzcGxpdHRlcnNcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL3RleHRfc3BsaXR0ZXIuanNcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/dist/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/dist/text_splitter.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/dist/text_splitter.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CharacterTextSplitter: () => (/* binding */ CharacterTextSplitter),\n/* harmony export */   LatexTextSplitter: () => (/* binding */ LatexTextSplitter),\n/* harmony export */   MarkdownTextSplitter: () => (/* binding */ MarkdownTextSplitter),\n/* harmony export */   RecursiveCharacterTextSplitter: () => (/* binding */ RecursiveCharacterTextSplitter),\n/* harmony export */   SupportedTextSplitterLanguages: () => (/* binding */ SupportedTextSplitterLanguages),\n/* harmony export */   TextSplitter: () => (/* binding */ TextSplitter),\n/* harmony export */   TokenTextSplitter: () => (/* binding */ TokenTextSplitter)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_documents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/documents */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/documents.js\");\n/* harmony import */ var _langchain_core_utils_tiktoken__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/core/utils/tiktoken */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/utils/tiktoken.js\");\n\n\nclass TextSplitter extends _langchain_core_documents__WEBPACK_IMPORTED_MODULE_0__.BaseDocumentTransformer {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"document_transformers\", \"text_splitters\"]\n        });\n        Object.defineProperty(this, \"chunkSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 1000\n        });\n        Object.defineProperty(this, \"chunkOverlap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 200\n        });\n        Object.defineProperty(this, \"keepSeparator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lengthFunction\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.chunkSize = fields?.chunkSize ?? this.chunkSize;\n        this.chunkOverlap = fields?.chunkOverlap ?? this.chunkOverlap;\n        this.keepSeparator = fields?.keepSeparator ?? this.keepSeparator;\n        this.lengthFunction =\n            fields?.lengthFunction ?? ((text) => text.length);\n        if (this.chunkOverlap >= this.chunkSize) {\n            throw new Error(\"Cannot have chunkOverlap >= chunkSize\");\n        }\n    }\n    async transformDocuments(documents, chunkHeaderOptions = {}) {\n        return this.splitDocuments(documents, chunkHeaderOptions);\n    }\n    splitOnSeparator(text, separator) {\n        let splits;\n        if (separator) {\n            if (this.keepSeparator) {\n                const regexEscapedSeparator = separator.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n                splits = text.split(new RegExp(`(?=${regexEscapedSeparator})`));\n            }\n            else {\n                splits = text.split(separator);\n            }\n        }\n        else {\n            splits = text.split(\"\");\n        }\n        return splits.filter((s) => s !== \"\");\n    }\n    async createDocuments(texts, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadatas = [], chunkHeaderOptions = {}) {\n        // if no metadata is provided, we create an empty one for each text\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const _metadatas = metadatas.length > 0\n            ? metadatas\n            : [...Array(texts.length)].map(() => ({}));\n        const { chunkHeader = \"\", chunkOverlapHeader = \"(cont'd) \", appendChunkOverlapHeader = false, } = chunkHeaderOptions;\n        const documents = new Array();\n        for (let i = 0; i < texts.length; i += 1) {\n            const text = texts[i];\n            let lineCounterIndex = 1;\n            let prevChunk = null;\n            let indexPrevChunk = -1;\n            for (const chunk of await this.splitText(text)) {\n                let pageContent = chunkHeader;\n                // we need to count the \\n that are in the text before getting removed by the splitting\n                const indexChunk = text.indexOf(chunk, indexPrevChunk + 1);\n                if (prevChunk === null) {\n                    const newLinesBeforeFirstChunk = this.numberOfNewLines(text, 0, indexChunk);\n                    lineCounterIndex += newLinesBeforeFirstChunk;\n                }\n                else {\n                    const indexEndPrevChunk = indexPrevChunk + (await this.lengthFunction(prevChunk));\n                    if (indexEndPrevChunk < indexChunk) {\n                        const numberOfIntermediateNewLines = this.numberOfNewLines(text, indexEndPrevChunk, indexChunk);\n                        lineCounterIndex += numberOfIntermediateNewLines;\n                    }\n                    else if (indexEndPrevChunk > indexChunk) {\n                        const numberOfIntermediateNewLines = this.numberOfNewLines(text, indexChunk, indexEndPrevChunk);\n                        lineCounterIndex -= numberOfIntermediateNewLines;\n                    }\n                    if (appendChunkOverlapHeader) {\n                        pageContent += chunkOverlapHeader;\n                    }\n                }\n                const newLinesCount = this.numberOfNewLines(chunk);\n                const loc = _metadatas[i].loc && typeof _metadatas[i].loc === \"object\"\n                    ? { ..._metadatas[i].loc }\n                    : {};\n                loc.lines = {\n                    from: lineCounterIndex,\n                    to: lineCounterIndex + newLinesCount,\n                };\n                const metadataWithLinesNumber = {\n                    ..._metadatas[i],\n                    loc,\n                };\n                pageContent += chunk;\n                documents.push(new _langchain_core_documents__WEBPACK_IMPORTED_MODULE_0__.Document({\n                    pageContent,\n                    metadata: metadataWithLinesNumber,\n                }));\n                lineCounterIndex += newLinesCount;\n                prevChunk = chunk;\n                indexPrevChunk = indexChunk;\n            }\n        }\n        return documents;\n    }\n    numberOfNewLines(text, start, end) {\n        const textSection = text.slice(start, end);\n        return (textSection.match(/\\n/g) || []).length;\n    }\n    async splitDocuments(documents, chunkHeaderOptions = {}) {\n        const selectedDocuments = documents.filter((doc) => doc.pageContent !== undefined);\n        const texts = selectedDocuments.map((doc) => doc.pageContent);\n        const metadatas = selectedDocuments.map((doc) => doc.metadata);\n        return this.createDocuments(texts, metadatas, chunkHeaderOptions);\n    }\n    joinDocs(docs, separator) {\n        const text = docs.join(separator).trim();\n        return text === \"\" ? null : text;\n    }\n    async mergeSplits(splits, separator) {\n        const docs = [];\n        const currentDoc = [];\n        let total = 0;\n        for (const d of splits) {\n            const _len = await this.lengthFunction(d);\n            if (total + _len + currentDoc.length * separator.length >\n                this.chunkSize) {\n                if (total > this.chunkSize) {\n                    console.warn(`Created a chunk of size ${total}, +\nwhich is longer than the specified ${this.chunkSize}`);\n                }\n                if (currentDoc.length > 0) {\n                    const doc = this.joinDocs(currentDoc, separator);\n                    if (doc !== null) {\n                        docs.push(doc);\n                    }\n                    // Keep on popping if:\n                    // - we have a larger chunk than in the chunk overlap\n                    // - or if we still have any chunks and the length is long\n                    while (total > this.chunkOverlap ||\n                        (total + _len + currentDoc.length * separator.length >\n                            this.chunkSize &&\n                            total > 0)) {\n                        total -= await this.lengthFunction(currentDoc[0]);\n                        currentDoc.shift();\n                    }\n                }\n            }\n            currentDoc.push(d);\n            total += _len;\n        }\n        const doc = this.joinDocs(currentDoc, separator);\n        if (doc !== null) {\n            docs.push(doc);\n        }\n        return docs;\n    }\n}\nclass CharacterTextSplitter extends TextSplitter {\n    static lc_name() {\n        return \"CharacterTextSplitter\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"separator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\\n\\n\"\n        });\n        this.separator = fields?.separator ?? this.separator;\n    }\n    async splitText(text) {\n        // First we naively split the large input into a bunch of smaller ones.\n        const splits = this.splitOnSeparator(text, this.separator);\n        return this.mergeSplits(splits, this.keepSeparator ? \"\" : this.separator);\n    }\n}\nconst SupportedTextSplitterLanguages = [\n    \"cpp\",\n    \"go\",\n    \"java\",\n    \"js\",\n    \"php\",\n    \"proto\",\n    \"python\",\n    \"rst\",\n    \"ruby\",\n    \"rust\",\n    \"scala\",\n    \"swift\",\n    \"markdown\",\n    \"latex\",\n    \"html\",\n    \"sol\",\n];\nclass RecursiveCharacterTextSplitter extends TextSplitter {\n    static lc_name() {\n        return \"RecursiveCharacterTextSplitter\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"separators\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"\\n\\n\", \"\\n\", \" \", \"\"]\n        });\n        this.separators = fields?.separators ?? this.separators;\n        this.keepSeparator = fields?.keepSeparator ?? true;\n    }\n    async _splitText(text, separators) {\n        const finalChunks = [];\n        // Get appropriate separator to use\n        let separator = separators[separators.length - 1];\n        let newSeparators;\n        for (let i = 0; i < separators.length; i += 1) {\n            const s = separators[i];\n            if (s === \"\") {\n                separator = s;\n                break;\n            }\n            if (text.includes(s)) {\n                separator = s;\n                newSeparators = separators.slice(i + 1);\n                break;\n            }\n        }\n        // Now that we have the separator, split the text\n        const splits = this.splitOnSeparator(text, separator);\n        // Now go merging things, recursively splitting longer texts.\n        let goodSplits = [];\n        const _separator = this.keepSeparator ? \"\" : separator;\n        for (const s of splits) {\n            if ((await this.lengthFunction(s)) < this.chunkSize) {\n                goodSplits.push(s);\n            }\n            else {\n                if (goodSplits.length) {\n                    const mergedText = await this.mergeSplits(goodSplits, _separator);\n                    finalChunks.push(...mergedText);\n                    goodSplits = [];\n                }\n                if (!newSeparators) {\n                    finalChunks.push(s);\n                }\n                else {\n                    const otherInfo = await this._splitText(s, newSeparators);\n                    finalChunks.push(...otherInfo);\n                }\n            }\n        }\n        if (goodSplits.length) {\n            const mergedText = await this.mergeSplits(goodSplits, _separator);\n            finalChunks.push(...mergedText);\n        }\n        return finalChunks;\n    }\n    async splitText(text) {\n        return this._splitText(text, this.separators);\n    }\n    static fromLanguage(language, options) {\n        return new RecursiveCharacterTextSplitter({\n            ...options,\n            separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(language),\n        });\n    }\n    static getSeparatorsForLanguage(language) {\n        if (language === \"cpp\") {\n            return [\n                // Split along class definitions\n                \"\\nclass \",\n                // Split along function definitions\n                \"\\nvoid \",\n                \"\\nint \",\n                \"\\nfloat \",\n                \"\\ndouble \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"go\") {\n            return [\n                // Split along function definitions\n                \"\\nfunc \",\n                \"\\nvar \",\n                \"\\nconst \",\n                \"\\ntype \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"java\") {\n            return [\n                // Split along class definitions\n                \"\\nclass \",\n                // Split along method definitions\n                \"\\npublic \",\n                \"\\nprotected \",\n                \"\\nprivate \",\n                \"\\nstatic \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"js\") {\n            return [\n                // Split along function definitions\n                \"\\nfunction \",\n                \"\\nconst \",\n                \"\\nlet \",\n                \"\\nvar \",\n                \"\\nclass \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                \"\\ndefault \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"php\") {\n            return [\n                // Split along function definitions\n                \"\\nfunction \",\n                // Split along class definitions\n                \"\\nclass \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nforeach \",\n                \"\\nwhile \",\n                \"\\ndo \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"proto\") {\n            return [\n                // Split along message definitions\n                \"\\nmessage \",\n                // Split along service definitions\n                \"\\nservice \",\n                // Split along enum definitions\n                \"\\nenum \",\n                // Split along option definitions\n                \"\\noption \",\n                // Split along import statements\n                \"\\nimport \",\n                // Split along syntax declarations\n                \"\\nsyntax \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"python\") {\n            return [\n                // First, try to split along class definitions\n                \"\\nclass \",\n                \"\\ndef \",\n                \"\\n\\tdef \",\n                // Now split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"rst\") {\n            return [\n                // Split along section titles\n                \"\\n===\\n\",\n                \"\\n---\\n\",\n                \"\\n***\\n\",\n                // Split along directive markers\n                \"\\n.. \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"ruby\") {\n            return [\n                // Split along method definitions\n                \"\\ndef \",\n                \"\\nclass \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nunless \",\n                \"\\nwhile \",\n                \"\\nfor \",\n                \"\\ndo \",\n                \"\\nbegin \",\n                \"\\nrescue \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"rust\") {\n            return [\n                // Split along function definitions\n                \"\\nfn \",\n                \"\\nconst \",\n                \"\\nlet \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nwhile \",\n                \"\\nfor \",\n                \"\\nloop \",\n                \"\\nmatch \",\n                \"\\nconst \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"scala\") {\n            return [\n                // Split along class definitions\n                \"\\nclass \",\n                \"\\nobject \",\n                // Split along method definitions\n                \"\\ndef \",\n                \"\\nval \",\n                \"\\nvar \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nmatch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"swift\") {\n            return [\n                // Split along function definitions\n                \"\\nfunc \",\n                // Split along class definitions\n                \"\\nclass \",\n                \"\\nstruct \",\n                \"\\nenum \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\ndo \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"markdown\") {\n            return [\n                // First, try to split along Markdown headings (starting with level 2)\n                \"\\n## \",\n                \"\\n### \",\n                \"\\n#### \",\n                \"\\n##### \",\n                \"\\n###### \",\n                // Note the alternative syntax for headings (below) is not handled here\n                // Heading level 2\n                // ---------------\n                // End of code block\n                \"```\\n\\n\",\n                // Horizontal lines\n                \"\\n\\n***\\n\\n\",\n                \"\\n\\n---\\n\\n\",\n                \"\\n\\n___\\n\\n\",\n                // Note that this splitter doesn't handle horizontal lines defined\n                // by *three or more* of ***, ---, or ___, but this is not handled\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"latex\") {\n            return [\n                // First, try to split along Latex sections\n                \"\\n\\\\chapter{\",\n                \"\\n\\\\section{\",\n                \"\\n\\\\subsection{\",\n                \"\\n\\\\subsubsection{\",\n                // Now split by environments\n                \"\\n\\\\begin{enumerate}\",\n                \"\\n\\\\begin{itemize}\",\n                \"\\n\\\\begin{description}\",\n                \"\\n\\\\begin{list}\",\n                \"\\n\\\\begin{quote}\",\n                \"\\n\\\\begin{quotation}\",\n                \"\\n\\\\begin{verse}\",\n                \"\\n\\\\begin{verbatim}\",\n                // Now split by math environments\n                \"\\n\\\\begin{align}\",\n                \"$$\",\n                \"$\",\n                // Now split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"html\") {\n            return [\n                // First, try to split along HTML tags\n                \"<body>\",\n                \"<div>\",\n                \"<p>\",\n                \"<br>\",\n                \"<li>\",\n                \"<h1>\",\n                \"<h2>\",\n                \"<h3>\",\n                \"<h4>\",\n                \"<h5>\",\n                \"<h6>\",\n                \"<span>\",\n                \"<table>\",\n                \"<tr>\",\n                \"<td>\",\n                \"<th>\",\n                \"<ul>\",\n                \"<ol>\",\n                \"<header>\",\n                \"<footer>\",\n                \"<nav>\",\n                // Head\n                \"<head>\",\n                \"<style>\",\n                \"<script>\",\n                \"<meta>\",\n                \"<title>\",\n                // Normal type of lines\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"sol\") {\n            return [\n                // Split along compiler informations definitions\n                \"\\npragma \",\n                \"\\nusing \",\n                // Split along contract definitions\n                \"\\ncontract \",\n                \"\\ninterface \",\n                \"\\nlibrary \",\n                // Split along method definitions\n                \"\\nconstructor \",\n                \"\\ntype \",\n                \"\\nfunction \",\n                \"\\nevent \",\n                \"\\nmodifier \",\n                \"\\nerror \",\n                \"\\nstruct \",\n                \"\\nenum \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\ndo while \",\n                \"\\nassembly \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else {\n            throw new Error(`Language ${language} is not supported.`);\n        }\n    }\n}\n/**\n * Implementation of splitter which looks at tokens.\n */\nclass TokenTextSplitter extends TextSplitter {\n    static lc_name() {\n        return \"TokenTextSplitter\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"encodingName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"allowedSpecial\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"disallowedSpecial\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tokenizer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.encodingName = fields?.encodingName ?? \"gpt2\";\n        this.allowedSpecial = fields?.allowedSpecial ?? [];\n        this.disallowedSpecial = fields?.disallowedSpecial ?? \"all\";\n    }\n    async splitText(text) {\n        if (!this.tokenizer) {\n            this.tokenizer = await (0,_langchain_core_utils_tiktoken__WEBPACK_IMPORTED_MODULE_1__.getEncoding)(this.encodingName);\n        }\n        const splits = [];\n        const input_ids = this.tokenizer.encode(text, this.allowedSpecial, this.disallowedSpecial);\n        let start_idx = 0;\n        while (start_idx < input_ids.length) {\n            if (start_idx > 0) {\n                start_idx -= this.chunkOverlap;\n            }\n            const end_idx = Math.min(start_idx + this.chunkSize, input_ids.length);\n            const chunk_ids = input_ids.slice(start_idx, end_idx);\n            splits.push(this.tokenizer.decode(chunk_ids));\n            start_idx = end_idx;\n        }\n        return splits;\n    }\n}\nclass MarkdownTextSplitter extends RecursiveCharacterTextSplitter {\n    constructor(fields) {\n        super({\n            ...fields,\n            separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(\"markdown\"),\n        });\n    }\n}\nclass LatexTextSplitter extends RecursiveCharacterTextSplitter {\n    constructor(fields) {\n        super({\n            ...fields,\n            separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(\"latex\"),\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvZGlzdC90ZXh0X3NwbGl0dGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUE4RTtBQUNqQjtBQUN0RCwyQkFBMkIsOEVBQXVCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRixxREFBcUQsc0JBQXNCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxnQkFBZ0Isd0ZBQXdGO0FBQ3hHO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywrREFBUTtBQUMzQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELE1BQU07QUFDbEUscUNBQXFDLGVBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsZ0NBQWdDO0FBQ2hDLG1DQUFtQztBQUNuQztBQUNBLDJCQUEyQixVQUFVO0FBQ3JDLDJCQUEyQixRQUFRO0FBQ25DLDJCQUEyQixZQUFZO0FBQ3ZDLDJCQUEyQixLQUFLO0FBQ2hDLDJCQUEyQixNQUFNO0FBQ2pDLDJCQUEyQixVQUFVO0FBQ3JDLDJCQUEyQixNQUFNO0FBQ2pDLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyRUFBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXHRleHRzcGxpdHRlcnNcXGRpc3RcXHRleHRfc3BsaXR0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRG9jdW1lbnQsIEJhc2VEb2N1bWVudFRyYW5zZm9ybWVyIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9kb2N1bWVudHNcIjtcbmltcG9ydCB7IGdldEVuY29kaW5nIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS91dGlscy90aWt0b2tlblwiO1xuZXhwb3J0IGNsYXNzIFRleHRTcGxpdHRlciBleHRlbmRzIEJhc2VEb2N1bWVudFRyYW5zZm9ybWVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJkb2N1bWVudF90cmFuc2Zvcm1lcnNcIiwgXCJ0ZXh0X3NwbGl0dGVyc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2h1bmtTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAxMDAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaHVua092ZXJsYXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDIwMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2VlcFNlcGFyYXRvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxlbmd0aEZ1bmN0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2h1bmtTaXplID0gZmllbGRzPy5jaHVua1NpemUgPz8gdGhpcy5jaHVua1NpemU7XG4gICAgICAgIHRoaXMuY2h1bmtPdmVybGFwID0gZmllbGRzPy5jaHVua092ZXJsYXAgPz8gdGhpcy5jaHVua092ZXJsYXA7XG4gICAgICAgIHRoaXMua2VlcFNlcGFyYXRvciA9IGZpZWxkcz8ua2VlcFNlcGFyYXRvciA/PyB0aGlzLmtlZXBTZXBhcmF0b3I7XG4gICAgICAgIHRoaXMubGVuZ3RoRnVuY3Rpb24gPVxuICAgICAgICAgICAgZmllbGRzPy5sZW5ndGhGdW5jdGlvbiA/PyAoKHRleHQpID0+IHRleHQubGVuZ3RoKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtPdmVybGFwID49IHRoaXMuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaGF2ZSBjaHVua092ZXJsYXAgPj0gY2h1bmtTaXplXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHRyYW5zZm9ybURvY3VtZW50cyhkb2N1bWVudHMsIGNodW5rSGVhZGVyT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwbGl0RG9jdW1lbnRzKGRvY3VtZW50cywgY2h1bmtIZWFkZXJPcHRpb25zKTtcbiAgICB9XG4gICAgc3BsaXRPblNlcGFyYXRvcih0ZXh0LCBzZXBhcmF0b3IpIHtcbiAgICAgICAgbGV0IHNwbGl0cztcbiAgICAgICAgaWYgKHNlcGFyYXRvcikge1xuICAgICAgICAgICAgaWYgKHRoaXMua2VlcFNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4RXNjYXBlZFNlcGFyYXRvciA9IHNlcGFyYXRvci5yZXBsYWNlKC9bL1xcLVxcXFxeJCorPy4oKXxbXFxde31dL2csIFwiXFxcXCQmXCIpO1xuICAgICAgICAgICAgICAgIHNwbGl0cyA9IHRleHQuc3BsaXQobmV3IFJlZ0V4cChgKD89JHtyZWdleEVzY2FwZWRTZXBhcmF0b3J9KWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwbGl0cyA9IHRleHQuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNwbGl0cyA9IHRleHQuc3BsaXQoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0cy5maWx0ZXIoKHMpID0+IHMgIT09IFwiXCIpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVEb2N1bWVudHModGV4dHMsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbWV0YWRhdGFzID0gW10sIGNodW5rSGVhZGVyT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIGlmIG5vIG1ldGFkYXRhIGlzIHByb3ZpZGVkLCB3ZSBjcmVhdGUgYW4gZW1wdHkgb25lIGZvciBlYWNoIHRleHRcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgX21ldGFkYXRhcyA9IG1ldGFkYXRhcy5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IG1ldGFkYXRhc1xuICAgICAgICAgICAgOiBbLi4uQXJyYXkodGV4dHMubGVuZ3RoKV0ubWFwKCgpID0+ICh7fSkpO1xuICAgICAgICBjb25zdCB7IGNodW5rSGVhZGVyID0gXCJcIiwgY2h1bmtPdmVybGFwSGVhZGVyID0gXCIoY29udCdkKSBcIiwgYXBwZW5kQ2h1bmtPdmVybGFwSGVhZGVyID0gZmFsc2UsIH0gPSBjaHVua0hlYWRlck9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50cyA9IG5ldyBBcnJheSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gdGV4dHNbaV07XG4gICAgICAgICAgICBsZXQgbGluZUNvdW50ZXJJbmRleCA9IDE7XG4gICAgICAgICAgICBsZXQgcHJldkNodW5rID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBpbmRleFByZXZDaHVuayA9IC0xO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBhd2FpdCB0aGlzLnNwbGl0VGV4dCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIGxldCBwYWdlQ29udGVudCA9IGNodW5rSGVhZGVyO1xuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY291bnQgdGhlIFxcbiB0aGF0IGFyZSBpbiB0aGUgdGV4dCBiZWZvcmUgZ2V0dGluZyByZW1vdmVkIGJ5IHRoZSBzcGxpdHRpbmdcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleENodW5rID0gdGV4dC5pbmRleE9mKGNodW5rLCBpbmRleFByZXZDaHVuayArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2Q2h1bmsgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3TGluZXNCZWZvcmVGaXJzdENodW5rID0gdGhpcy5udW1iZXJPZk5ld0xpbmVzKHRleHQsIDAsIGluZGV4Q2h1bmspO1xuICAgICAgICAgICAgICAgICAgICBsaW5lQ291bnRlckluZGV4ICs9IG5ld0xpbmVzQmVmb3JlRmlyc3RDaHVuaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4RW5kUHJldkNodW5rID0gaW5kZXhQcmV2Q2h1bmsgKyAoYXdhaXQgdGhpcy5sZW5ndGhGdW5jdGlvbihwcmV2Q2h1bmspKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4RW5kUHJldkNodW5rIDwgaW5kZXhDaHVuaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZJbnRlcm1lZGlhdGVOZXdMaW5lcyA9IHRoaXMubnVtYmVyT2ZOZXdMaW5lcyh0ZXh0LCBpbmRleEVuZFByZXZDaHVuaywgaW5kZXhDaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lQ291bnRlckluZGV4ICs9IG51bWJlck9mSW50ZXJtZWRpYXRlTmV3TGluZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXhFbmRQcmV2Q2h1bmsgPiBpbmRleENodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJPZkludGVybWVkaWF0ZU5ld0xpbmVzID0gdGhpcy5udW1iZXJPZk5ld0xpbmVzKHRleHQsIGluZGV4Q2h1bmssIGluZGV4RW5kUHJldkNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVDb3VudGVySW5kZXggLT0gbnVtYmVyT2ZJbnRlcm1lZGlhdGVOZXdMaW5lcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXBwZW5kQ2h1bmtPdmVybGFwSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlQ29udGVudCArPSBjaHVua092ZXJsYXBIZWFkZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TGluZXNDb3VudCA9IHRoaXMubnVtYmVyT2ZOZXdMaW5lcyhjaHVuayk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jID0gX21ldGFkYXRhc1tpXS5sb2MgJiYgdHlwZW9mIF9tZXRhZGF0YXNbaV0ubG9jID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgICAgID8geyAuLi5fbWV0YWRhdGFzW2ldLmxvYyB9XG4gICAgICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICAgICAgbG9jLmxpbmVzID0ge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBsaW5lQ291bnRlckluZGV4LFxuICAgICAgICAgICAgICAgICAgICB0bzogbGluZUNvdW50ZXJJbmRleCArIG5ld0xpbmVzQ291bnQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YVdpdGhMaW5lc051bWJlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uX21ldGFkYXRhc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgbG9jLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcGFnZUNvbnRlbnQgKz0gY2h1bms7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRzLnB1c2gobmV3IERvY3VtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YVdpdGhMaW5lc051bWJlcixcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgbGluZUNvdW50ZXJJbmRleCArPSBuZXdMaW5lc0NvdW50O1xuICAgICAgICAgICAgICAgIHByZXZDaHVuayA9IGNodW5rO1xuICAgICAgICAgICAgICAgIGluZGV4UHJldkNodW5rID0gaW5kZXhDaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jdW1lbnRzO1xuICAgIH1cbiAgICBudW1iZXJPZk5ld0xpbmVzKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgY29uc3QgdGV4dFNlY3Rpb24gPSB0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICByZXR1cm4gKHRleHRTZWN0aW9uLm1hdGNoKC9cXG4vZykgfHwgW10pLmxlbmd0aDtcbiAgICB9XG4gICAgYXN5bmMgc3BsaXREb2N1bWVudHMoZG9jdW1lbnRzLCBjaHVua0hlYWRlck9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBzZWxlY3RlZERvY3VtZW50cyA9IGRvY3VtZW50cy5maWx0ZXIoKGRvYykgPT4gZG9jLnBhZ2VDb250ZW50ICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCB0ZXh0cyA9IHNlbGVjdGVkRG9jdW1lbnRzLm1hcCgoZG9jKSA9PiBkb2MucGFnZUNvbnRlbnQpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YXMgPSBzZWxlY3RlZERvY3VtZW50cy5tYXAoKGRvYykgPT4gZG9jLm1ldGFkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRG9jdW1lbnRzKHRleHRzLCBtZXRhZGF0YXMsIGNodW5rSGVhZGVyT3B0aW9ucyk7XG4gICAgfVxuICAgIGpvaW5Eb2NzKGRvY3MsIHNlcGFyYXRvcikge1xuICAgICAgICBjb25zdCB0ZXh0ID0gZG9jcy5qb2luKHNlcGFyYXRvcikudHJpbSgpO1xuICAgICAgICByZXR1cm4gdGV4dCA9PT0gXCJcIiA/IG51bGwgOiB0ZXh0O1xuICAgIH1cbiAgICBhc3luYyBtZXJnZVNwbGl0cyhzcGxpdHMsIHNlcGFyYXRvcikge1xuICAgICAgICBjb25zdCBkb2NzID0gW107XG4gICAgICAgIGNvbnN0IGN1cnJlbnREb2MgPSBbXTtcbiAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIHNwbGl0cykge1xuICAgICAgICAgICAgY29uc3QgX2xlbiA9IGF3YWl0IHRoaXMubGVuZ3RoRnVuY3Rpb24oZCk7XG4gICAgICAgICAgICBpZiAodG90YWwgKyBfbGVuICsgY3VycmVudERvYy5sZW5ndGggKiBzZXBhcmF0b3IubGVuZ3RoID5cbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rU2l6ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0b3RhbCA+IHRoaXMuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ3JlYXRlZCBhIGNodW5rIG9mIHNpemUgJHt0b3RhbH0sICtcbndoaWNoIGlzIGxvbmdlciB0aGFuIHRoZSBzcGVjaWZpZWQgJHt0aGlzLmNodW5rU2l6ZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnREb2MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2MgPSB0aGlzLmpvaW5Eb2NzKGN1cnJlbnREb2MsIHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3MucHVzaChkb2MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgb24gcG9wcGluZyBpZjpcbiAgICAgICAgICAgICAgICAgICAgLy8gLSB3ZSBoYXZlIGEgbGFyZ2VyIGNodW5rIHRoYW4gaW4gdGhlIGNodW5rIG92ZXJsYXBcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBvciBpZiB3ZSBzdGlsbCBoYXZlIGFueSBjaHVua3MgYW5kIHRoZSBsZW5ndGggaXMgbG9uZ1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodG90YWwgPiB0aGlzLmNodW5rT3ZlcmxhcCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRvdGFsICsgX2xlbiArIGN1cnJlbnREb2MubGVuZ3RoICogc2VwYXJhdG9yLmxlbmd0aCA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVua1NpemUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCAtPSBhd2FpdCB0aGlzLmxlbmd0aEZ1bmN0aW9uKGN1cnJlbnREb2NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERvYy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudERvYy5wdXNoKGQpO1xuICAgICAgICAgICAgdG90YWwgKz0gX2xlbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb2MgPSB0aGlzLmpvaW5Eb2NzKGN1cnJlbnREb2MsIHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChkb2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRvY3MucHVzaChkb2MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2NzO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDaGFyYWN0ZXJUZXh0U3BsaXR0ZXIgZXh0ZW5kcyBUZXh0U3BsaXR0ZXIge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJDaGFyYWN0ZXJUZXh0U3BsaXR0ZXJcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlcGFyYXRvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJcXG5cXG5cIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXBhcmF0b3IgPSBmaWVsZHM/LnNlcGFyYXRvciA/PyB0aGlzLnNlcGFyYXRvcjtcbiAgICB9XG4gICAgYXN5bmMgc3BsaXRUZXh0KHRleHQpIHtcbiAgICAgICAgLy8gRmlyc3Qgd2UgbmFpdmVseSBzcGxpdCB0aGUgbGFyZ2UgaW5wdXQgaW50byBhIGJ1bmNoIG9mIHNtYWxsZXIgb25lcy5cbiAgICAgICAgY29uc3Qgc3BsaXRzID0gdGhpcy5zcGxpdE9uU2VwYXJhdG9yKHRleHQsIHRoaXMuc2VwYXJhdG9yKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VTcGxpdHMoc3BsaXRzLCB0aGlzLmtlZXBTZXBhcmF0b3IgPyBcIlwiIDogdGhpcy5zZXBhcmF0b3IpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBTdXBwb3J0ZWRUZXh0U3BsaXR0ZXJMYW5ndWFnZXMgPSBbXG4gICAgXCJjcHBcIixcbiAgICBcImdvXCIsXG4gICAgXCJqYXZhXCIsXG4gICAgXCJqc1wiLFxuICAgIFwicGhwXCIsXG4gICAgXCJwcm90b1wiLFxuICAgIFwicHl0aG9uXCIsXG4gICAgXCJyc3RcIixcbiAgICBcInJ1YnlcIixcbiAgICBcInJ1c3RcIixcbiAgICBcInNjYWxhXCIsXG4gICAgXCJzd2lmdFwiLFxuICAgIFwibWFya2Rvd25cIixcbiAgICBcImxhdGV4XCIsXG4gICAgXCJodG1sXCIsXG4gICAgXCJzb2xcIixcbl07XG5leHBvcnQgY2xhc3MgUmVjdXJzaXZlQ2hhcmFjdGVyVGV4dFNwbGl0dGVyIGV4dGVuZHMgVGV4dFNwbGl0dGVyIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUmVjdXJzaXZlQ2hhcmFjdGVyVGV4dFNwbGl0dGVyXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXBhcmF0b3JzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJcXG5cXG5cIiwgXCJcXG5cIiwgXCIgXCIsIFwiXCJdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlcGFyYXRvcnMgPSBmaWVsZHM/LnNlcGFyYXRvcnMgPz8gdGhpcy5zZXBhcmF0b3JzO1xuICAgICAgICB0aGlzLmtlZXBTZXBhcmF0b3IgPSBmaWVsZHM/LmtlZXBTZXBhcmF0b3IgPz8gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgX3NwbGl0VGV4dCh0ZXh0LCBzZXBhcmF0b3JzKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsQ2h1bmtzID0gW107XG4gICAgICAgIC8vIEdldCBhcHByb3ByaWF0ZSBzZXBhcmF0b3IgdG8gdXNlXG4gICAgICAgIGxldCBzZXBhcmF0b3IgPSBzZXBhcmF0b3JzW3NlcGFyYXRvcnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBuZXdTZXBhcmF0b3JzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcGFyYXRvcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBzZXBhcmF0b3JzW2ldO1xuICAgICAgICAgICAgaWYgKHMgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IgPSBzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRleHQuaW5jbHVkZXMocykpIHtcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IgPSBzO1xuICAgICAgICAgICAgICAgIG5ld1NlcGFyYXRvcnMgPSBzZXBhcmF0b3JzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIHRoZSBzZXBhcmF0b3IsIHNwbGl0IHRoZSB0ZXh0XG4gICAgICAgIGNvbnN0IHNwbGl0cyA9IHRoaXMuc3BsaXRPblNlcGFyYXRvcih0ZXh0LCBzZXBhcmF0b3IpO1xuICAgICAgICAvLyBOb3cgZ28gbWVyZ2luZyB0aGluZ3MsIHJlY3Vyc2l2ZWx5IHNwbGl0dGluZyBsb25nZXIgdGV4dHMuXG4gICAgICAgIGxldCBnb29kU3BsaXRzID0gW107XG4gICAgICAgIGNvbnN0IF9zZXBhcmF0b3IgPSB0aGlzLmtlZXBTZXBhcmF0b3IgPyBcIlwiIDogc2VwYXJhdG9yO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2Ygc3BsaXRzKSB7XG4gICAgICAgICAgICBpZiAoKGF3YWl0IHRoaXMubGVuZ3RoRnVuY3Rpb24ocykpIDwgdGhpcy5jaHVua1NpemUpIHtcbiAgICAgICAgICAgICAgICBnb29kU3BsaXRzLnB1c2gocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZ29vZFNwbGl0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVyZ2VkVGV4dCA9IGF3YWl0IHRoaXMubWVyZ2VTcGxpdHMoZ29vZFNwbGl0cywgX3NlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmtzLnB1c2goLi4ubWVyZ2VkVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGdvb2RTcGxpdHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFuZXdTZXBhcmF0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmtzLnB1c2gocyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckluZm8gPSBhd2FpdCB0aGlzLl9zcGxpdFRleHQocywgbmV3U2VwYXJhdG9ycyk7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmtzLnB1c2goLi4ub3RoZXJJbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdvb2RTcGxpdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRUZXh0ID0gYXdhaXQgdGhpcy5tZXJnZVNwbGl0cyhnb29kU3BsaXRzLCBfc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIGZpbmFsQ2h1bmtzLnB1c2goLi4ubWVyZ2VkVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmFsQ2h1bmtzO1xuICAgIH1cbiAgICBhc3luYyBzcGxpdFRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3BsaXRUZXh0KHRleHQsIHRoaXMuc2VwYXJhdG9ycyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTGFuZ3VhZ2UobGFuZ3VhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN1cnNpdmVDaGFyYWN0ZXJUZXh0U3BsaXR0ZXIoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHNlcGFyYXRvcnM6IFJlY3Vyc2l2ZUNoYXJhY3RlclRleHRTcGxpdHRlci5nZXRTZXBhcmF0b3JzRm9yTGFuZ3VhZ2UobGFuZ3VhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldFNlcGFyYXRvcnNGb3JMYW5ndWFnZShsYW5ndWFnZSkge1xuICAgICAgICBpZiAobGFuZ3VhZ2UgPT09IFwiY3BwXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgY2xhc3MgZGVmaW5pdGlvbnNcbiAgICAgICAgICAgICAgICBcIlxcbmNsYXNzIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIGZ1bmN0aW9uIGRlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgXCJcXG52b2lkIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuaW50IFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuZmxvYXQgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5kb3VibGUgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgY29udHJvbCBmbG93IHN0YXRlbWVudHNcbiAgICAgICAgICAgICAgICBcIlxcbmlmIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuZm9yIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxud2hpbGUgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5zd2l0Y2ggXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5jYXNlIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGJ5IHRoZSBub3JtYWwgdHlwZSBvZiBsaW5lc1xuICAgICAgICAgICAgICAgIFwiXFxuXFxuXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cIixcbiAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYW5ndWFnZSA9PT0gXCJnb1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIGZ1bmN0aW9uIGRlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgXCJcXG5mdW5jIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxudmFyIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuY29uc3QgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG50eXBlIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIGNvbnRyb2wgZmxvdyBzdGF0ZW1lbnRzXG4gICAgICAgICAgICAgICAgXCJcXG5pZiBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmZvciBcIixcbiAgICAgICAgICAgICAgICBcIlxcbnN3aXRjaCBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmNhc2UgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYnkgdGhlIG5vcm1hbCB0eXBlIG9mIGxpbmVzXG4gICAgICAgICAgICAgICAgXCJcXG5cXG5cIixcbiAgICAgICAgICAgICAgICBcIlxcblwiLFxuICAgICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhbmd1YWdlID09PSBcImphdmFcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBjbGFzcyBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxuY2xhc3MgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgbWV0aG9kIGRlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgXCJcXG5wdWJsaWMgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5wcm90ZWN0ZWQgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5wcml2YXRlIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuc3RhdGljIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIGNvbnRyb2wgZmxvdyBzdGF0ZW1lbnRzXG4gICAgICAgICAgICAgICAgXCJcXG5pZiBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmZvciBcIixcbiAgICAgICAgICAgICAgICBcIlxcbndoaWxlIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuc3dpdGNoIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuY2FzZSBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBieSB0aGUgbm9ybWFsIHR5cGUgb2YgbGluZXNcbiAgICAgICAgICAgICAgICBcIlxcblxcblwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFuZ3VhZ2UgPT09IFwianNcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBmdW5jdGlvbiBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxuZnVuY3Rpb24gXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5jb25zdCBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmxldCBcIixcbiAgICAgICAgICAgICAgICBcIlxcbnZhciBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmNsYXNzIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIGNvbnRyb2wgZmxvdyBzdGF0ZW1lbnRzXG4gICAgICAgICAgICAgICAgXCJcXG5pZiBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmZvciBcIixcbiAgICAgICAgICAgICAgICBcIlxcbndoaWxlIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuc3dpdGNoIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuY2FzZSBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmRlZmF1bHQgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYnkgdGhlIG5vcm1hbCB0eXBlIG9mIGxpbmVzXG4gICAgICAgICAgICAgICAgXCJcXG5cXG5cIixcbiAgICAgICAgICAgICAgICBcIlxcblwiLFxuICAgICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhbmd1YWdlID09PSBcInBocFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIGZ1bmN0aW9uIGRlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgXCJcXG5mdW5jdGlvbiBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBjbGFzcyBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxuY2xhc3MgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgY29udHJvbCBmbG93IHN0YXRlbWVudHNcbiAgICAgICAgICAgICAgICBcIlxcbmlmIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuZm9yZWFjaCBcIixcbiAgICAgICAgICAgICAgICBcIlxcbndoaWxlIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuZG8gXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5zd2l0Y2ggXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5jYXNlIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGJ5IHRoZSBub3JtYWwgdHlwZSBvZiBsaW5lc1xuICAgICAgICAgICAgICAgIFwiXFxuXFxuXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cIixcbiAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYW5ndWFnZSA9PT0gXCJwcm90b1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIG1lc3NhZ2UgZGVmaW5pdGlvbnNcbiAgICAgICAgICAgICAgICBcIlxcbm1lc3NhZ2UgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgc2VydmljZSBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxuc2VydmljZSBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBlbnVtIGRlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgXCJcXG5lbnVtIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIG9wdGlvbiBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxub3B0aW9uIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIGltcG9ydCBzdGF0ZW1lbnRzXG4gICAgICAgICAgICAgICAgXCJcXG5pbXBvcnQgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgc3ludGF4IGRlY2xhcmF0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxuc3ludGF4IFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGJ5IHRoZSBub3JtYWwgdHlwZSBvZiBsaW5lc1xuICAgICAgICAgICAgICAgIFwiXFxuXFxuXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cIixcbiAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYW5ndWFnZSA9PT0gXCJweXRob25cIikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCwgdHJ5IHRvIHNwbGl0IGFsb25nIGNsYXNzIGRlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgXCJcXG5jbGFzcyBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmRlZiBcIixcbiAgICAgICAgICAgICAgICBcIlxcblxcdGRlZiBcIixcbiAgICAgICAgICAgICAgICAvLyBOb3cgc3BsaXQgYnkgdGhlIG5vcm1hbCB0eXBlIG9mIGxpbmVzXG4gICAgICAgICAgICAgICAgXCJcXG5cXG5cIixcbiAgICAgICAgICAgICAgICBcIlxcblwiLFxuICAgICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhbmd1YWdlID09PSBcInJzdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIHNlY3Rpb24gdGl0bGVzXG4gICAgICAgICAgICAgICAgXCJcXG49PT1cXG5cIixcbiAgICAgICAgICAgICAgICBcIlxcbi0tLVxcblwiLFxuICAgICAgICAgICAgICAgIFwiXFxuKioqXFxuXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgZGlyZWN0aXZlIG1hcmtlcnNcbiAgICAgICAgICAgICAgICBcIlxcbi4uIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGJ5IHRoZSBub3JtYWwgdHlwZSBvZiBsaW5lc1xuICAgICAgICAgICAgICAgIFwiXFxuXFxuXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cIixcbiAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYW5ndWFnZSA9PT0gXCJydWJ5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgbWV0aG9kIGRlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgXCJcXG5kZWYgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5jbGFzcyBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBjb250cm9sIGZsb3cgc3RhdGVtZW50c1xuICAgICAgICAgICAgICAgIFwiXFxuaWYgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG51bmxlc3MgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG53aGlsZSBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmZvciBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmRvIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuYmVnaW4gXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5yZXNjdWUgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYnkgdGhlIG5vcm1hbCB0eXBlIG9mIGxpbmVzXG4gICAgICAgICAgICAgICAgXCJcXG5cXG5cIixcbiAgICAgICAgICAgICAgICBcIlxcblwiLFxuICAgICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhbmd1YWdlID09PSBcInJ1c3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBmdW5jdGlvbiBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxuZm4gXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5jb25zdCBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmxldCBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBjb250cm9sIGZsb3cgc3RhdGVtZW50c1xuICAgICAgICAgICAgICAgIFwiXFxuaWYgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG53aGlsZSBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmZvciBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmxvb3AgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5tYXRjaCBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmNvbnN0IFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGJ5IHRoZSBub3JtYWwgdHlwZSBvZiBsaW5lc1xuICAgICAgICAgICAgICAgIFwiXFxuXFxuXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cIixcbiAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYW5ndWFnZSA9PT0gXCJzY2FsYVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIGNsYXNzIGRlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgXCJcXG5jbGFzcyBcIixcbiAgICAgICAgICAgICAgICBcIlxcbm9iamVjdCBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBtZXRob2QgZGVmaW5pdGlvbnNcbiAgICAgICAgICAgICAgICBcIlxcbmRlZiBcIixcbiAgICAgICAgICAgICAgICBcIlxcbnZhbCBcIixcbiAgICAgICAgICAgICAgICBcIlxcbnZhciBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBjb250cm9sIGZsb3cgc3RhdGVtZW50c1xuICAgICAgICAgICAgICAgIFwiXFxuaWYgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5mb3IgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG53aGlsZSBcIixcbiAgICAgICAgICAgICAgICBcIlxcbm1hdGNoIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuY2FzZSBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBieSB0aGUgbm9ybWFsIHR5cGUgb2YgbGluZXNcbiAgICAgICAgICAgICAgICBcIlxcblxcblwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFuZ3VhZ2UgPT09IFwic3dpZnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBmdW5jdGlvbiBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxuZnVuYyBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBjbGFzcyBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxuY2xhc3MgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5zdHJ1Y3QgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5lbnVtIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIGNvbnRyb2wgZmxvdyBzdGF0ZW1lbnRzXG4gICAgICAgICAgICAgICAgXCJcXG5pZiBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmZvciBcIixcbiAgICAgICAgICAgICAgICBcIlxcbndoaWxlIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuZG8gXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5zd2l0Y2ggXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5jYXNlIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGJ5IHRoZSBub3JtYWwgdHlwZSBvZiBsaW5lc1xuICAgICAgICAgICAgICAgIFwiXFxuXFxuXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cIixcbiAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYW5ndWFnZSA9PT0gXCJtYXJrZG93blwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC8vIEZpcnN0LCB0cnkgdG8gc3BsaXQgYWxvbmcgTWFya2Rvd24gaGVhZGluZ3MgKHN0YXJ0aW5nIHdpdGggbGV2ZWwgMilcbiAgICAgICAgICAgICAgICBcIlxcbiMjIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuIyMjIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuIyMjIyBcIixcbiAgICAgICAgICAgICAgICBcIlxcbiMjIyMjIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuIyMjIyMjIFwiLFxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhlIGFsdGVybmF0aXZlIHN5bnRheCBmb3IgaGVhZGluZ3MgKGJlbG93KSBpcyBub3QgaGFuZGxlZCBoZXJlXG4gICAgICAgICAgICAgICAgLy8gSGVhZGluZyBsZXZlbCAyXG4gICAgICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAgICAgLy8gRW5kIG9mIGNvZGUgYmxvY2tcbiAgICAgICAgICAgICAgICBcImBgYFxcblxcblwiLFxuICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgbGluZXNcbiAgICAgICAgICAgICAgICBcIlxcblxcbioqKlxcblxcblwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXFxuLS0tXFxuXFxuXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cXG5fX19cXG5cXG5cIixcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBzcGxpdHRlciBkb2Vzbid0IGhhbmRsZSBob3Jpem9udGFsIGxpbmVzIGRlZmluZWRcbiAgICAgICAgICAgICAgICAvLyBieSAqdGhyZWUgb3IgbW9yZSogb2YgKioqLCAtLS0sIG9yIF9fXywgYnV0IHRoaXMgaXMgbm90IGhhbmRsZWRcbiAgICAgICAgICAgICAgICBcIlxcblxcblwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFuZ3VhZ2UgPT09IFwibGF0ZXhcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCwgdHJ5IHRvIHNwbGl0IGFsb25nIExhdGV4IHNlY3Rpb25zXG4gICAgICAgICAgICAgICAgXCJcXG5cXFxcY2hhcHRlcntcIixcbiAgICAgICAgICAgICAgICBcIlxcblxcXFxzZWN0aW9ue1wiLFxuICAgICAgICAgICAgICAgIFwiXFxuXFxcXHN1YnNlY3Rpb257XCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cXFxcc3Vic3Vic2VjdGlvbntcIixcbiAgICAgICAgICAgICAgICAvLyBOb3cgc3BsaXQgYnkgZW52aXJvbm1lbnRzXG4gICAgICAgICAgICAgICAgXCJcXG5cXFxcYmVnaW57ZW51bWVyYXRlfVwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXFxcXGJlZ2lue2l0ZW1pemV9XCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cXFxcYmVnaW57ZGVzY3JpcHRpb259XCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cXFxcYmVnaW57bGlzdH1cIixcbiAgICAgICAgICAgICAgICBcIlxcblxcXFxiZWdpbntxdW90ZX1cIixcbiAgICAgICAgICAgICAgICBcIlxcblxcXFxiZWdpbntxdW90YXRpb259XCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cXFxcYmVnaW57dmVyc2V9XCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cXFxcYmVnaW57dmVyYmF0aW19XCIsXG4gICAgICAgICAgICAgICAgLy8gTm93IHNwbGl0IGJ5IG1hdGggZW52aXJvbm1lbnRzXG4gICAgICAgICAgICAgICAgXCJcXG5cXFxcYmVnaW57YWxpZ259XCIsXG4gICAgICAgICAgICAgICAgXCIkJFwiLFxuICAgICAgICAgICAgICAgIFwiJFwiLFxuICAgICAgICAgICAgICAgIC8vIE5vdyBzcGxpdCBieSB0aGUgbm9ybWFsIHR5cGUgb2YgbGluZXNcbiAgICAgICAgICAgICAgICBcIlxcblxcblwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFuZ3VhZ2UgPT09IFwiaHRtbFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC8vIEZpcnN0LCB0cnkgdG8gc3BsaXQgYWxvbmcgSFRNTCB0YWdzXG4gICAgICAgICAgICAgICAgXCI8Ym9keT5cIixcbiAgICAgICAgICAgICAgICBcIjxkaXY+XCIsXG4gICAgICAgICAgICAgICAgXCI8cD5cIixcbiAgICAgICAgICAgICAgICBcIjxicj5cIixcbiAgICAgICAgICAgICAgICBcIjxsaT5cIixcbiAgICAgICAgICAgICAgICBcIjxoMT5cIixcbiAgICAgICAgICAgICAgICBcIjxoMj5cIixcbiAgICAgICAgICAgICAgICBcIjxoMz5cIixcbiAgICAgICAgICAgICAgICBcIjxoND5cIixcbiAgICAgICAgICAgICAgICBcIjxoNT5cIixcbiAgICAgICAgICAgICAgICBcIjxoNj5cIixcbiAgICAgICAgICAgICAgICBcIjxzcGFuPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRhYmxlPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRkPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRoPlwiLFxuICAgICAgICAgICAgICAgIFwiPHVsPlwiLFxuICAgICAgICAgICAgICAgIFwiPG9sPlwiLFxuICAgICAgICAgICAgICAgIFwiPGhlYWRlcj5cIixcbiAgICAgICAgICAgICAgICBcIjxmb290ZXI+XCIsXG4gICAgICAgICAgICAgICAgXCI8bmF2PlwiLFxuICAgICAgICAgICAgICAgIC8vIEhlYWRcbiAgICAgICAgICAgICAgICBcIjxoZWFkPlwiLFxuICAgICAgICAgICAgICAgIFwiPHN0eWxlPlwiLFxuICAgICAgICAgICAgICAgIFwiPHNjcmlwdD5cIixcbiAgICAgICAgICAgICAgICBcIjxtZXRhPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRpdGxlPlwiLFxuICAgICAgICAgICAgICAgIC8vIE5vcm1hbCB0eXBlIG9mIGxpbmVzXG4gICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFuZ3VhZ2UgPT09IFwic29sXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgY29tcGlsZXIgaW5mb3JtYXRpb25zIGRlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgXCJcXG5wcmFnbWEgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG51c2luZyBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBjb250cmFjdCBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxuY29udHJhY3QgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5pbnRlcmZhY2UgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5saWJyYXJ5IFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIG1ldGhvZCBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxuY29uc3RydWN0b3IgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG50eXBlIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuZnVuY3Rpb24gXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5ldmVudCBcIixcbiAgICAgICAgICAgICAgICBcIlxcbm1vZGlmaWVyIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuZXJyb3IgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5zdHJ1Y3QgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5lbnVtIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIGNvbnRyb2wgZmxvdyBzdGF0ZW1lbnRzXG4gICAgICAgICAgICAgICAgXCJcXG5pZiBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmZvciBcIixcbiAgICAgICAgICAgICAgICBcIlxcbndoaWxlIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuZG8gd2hpbGUgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5hc3NlbWJseSBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBieSB0aGUgbm9ybWFsIHR5cGUgb2YgbGluZXNcbiAgICAgICAgICAgICAgICBcIlxcblxcblwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExhbmd1YWdlICR7bGFuZ3VhZ2V9IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHNwbGl0dGVyIHdoaWNoIGxvb2tzIGF0IHRva2Vucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRva2VuVGV4dFNwbGl0dGVyIGV4dGVuZHMgVGV4dFNwbGl0dGVyIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiVG9rZW5UZXh0U3BsaXR0ZXJcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuY29kaW5nTmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhbGxvd2VkU3BlY2lhbFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkaXNhbGxvd2VkU3BlY2lhbFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b2tlbml6ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbmNvZGluZ05hbWUgPSBmaWVsZHM/LmVuY29kaW5nTmFtZSA/PyBcImdwdDJcIjtcbiAgICAgICAgdGhpcy5hbGxvd2VkU3BlY2lhbCA9IGZpZWxkcz8uYWxsb3dlZFNwZWNpYWwgPz8gW107XG4gICAgICAgIHRoaXMuZGlzYWxsb3dlZFNwZWNpYWwgPSBmaWVsZHM/LmRpc2FsbG93ZWRTcGVjaWFsID8/IFwiYWxsXCI7XG4gICAgfVxuICAgIGFzeW5jIHNwbGl0VGV4dCh0ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy50b2tlbml6ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW5pemVyID0gYXdhaXQgZ2V0RW5jb2RpbmcodGhpcy5lbmNvZGluZ05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwbGl0cyA9IFtdO1xuICAgICAgICBjb25zdCBpbnB1dF9pZHMgPSB0aGlzLnRva2VuaXplci5lbmNvZGUodGV4dCwgdGhpcy5hbGxvd2VkU3BlY2lhbCwgdGhpcy5kaXNhbGxvd2VkU3BlY2lhbCk7XG4gICAgICAgIGxldCBzdGFydF9pZHggPSAwO1xuICAgICAgICB3aGlsZSAoc3RhcnRfaWR4IDwgaW5wdXRfaWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0X2lkeCA+IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydF9pZHggLT0gdGhpcy5jaHVua092ZXJsYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbmRfaWR4ID0gTWF0aC5taW4oc3RhcnRfaWR4ICsgdGhpcy5jaHVua1NpemUsIGlucHV0X2lkcy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgY2h1bmtfaWRzID0gaW5wdXRfaWRzLnNsaWNlKHN0YXJ0X2lkeCwgZW5kX2lkeCk7XG4gICAgICAgICAgICBzcGxpdHMucHVzaCh0aGlzLnRva2VuaXplci5kZWNvZGUoY2h1bmtfaWRzKSk7XG4gICAgICAgICAgICBzdGFydF9pZHggPSBlbmRfaWR4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdHM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE1hcmtkb3duVGV4dFNwbGl0dGVyIGV4dGVuZHMgUmVjdXJzaXZlQ2hhcmFjdGVyVGV4dFNwbGl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgc2VwYXJhdG9yczogUmVjdXJzaXZlQ2hhcmFjdGVyVGV4dFNwbGl0dGVyLmdldFNlcGFyYXRvcnNGb3JMYW5ndWFnZShcIm1hcmtkb3duXCIpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTGF0ZXhUZXh0U3BsaXR0ZXIgZXh0ZW5kcyBSZWN1cnNpdmVDaGFyYWN0ZXJUZXh0U3BsaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICBzZXBhcmF0b3JzOiBSZWN1cnNpdmVDaGFyYWN0ZXJUZXh0U3BsaXR0ZXIuZ2V0U2VwYXJhdG9yc0Zvckxhbmd1YWdlKFwibGF0ZXhcIiksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/dist/text_splitter.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CharacterTextSplitter: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.CharacterTextSplitter),
/* harmony export */   LatexTextSplitter: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.LatexTextSplitter),
/* harmony export */   MarkdownTextSplitter: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.MarkdownTextSplitter),
/* harmony export */   RecursiveCharacterTextSplitter: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.RecursiveCharacterTextSplitter),
/* harmony export */   SupportedTextSplitterLanguages: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.SupportedTextSplitterLanguages),
/* harmony export */   TextSplitter: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.TextSplitter),
/* harmony export */   TokenTextSplitter: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.TokenTextSplitter)
/* harmony export */ });
/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ "(action-browser)/./node_modules/@langchain/textsplitters/dist/index.js");


/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/callbacks/base.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/callbacks/base.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseCallbackHandler: () => (/* binding */ BaseCallbackHandler)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(action-browser)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../load/serializable.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/load/serializable.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/env.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/env.js\");\n\n\n\n/**\n * Abstract class that provides a set of optional methods that can be\n * overridden in derived classes to handle various events during the\n * execution of a LangChain application.\n */\nclass BaseCallbackHandlerMethodsClass {\n}\n/**\n * Abstract base class for creating callback handlers in the LangChain\n * framework. It provides a set of optional methods that can be overridden\n * in derived classes to handle various events during the execution of a\n * LangChain application.\n */\nclass BaseCallbackHandler extends BaseCallbackHandlerMethodsClass {\n    get lc_namespace() {\n        return [\"langchain_core\", \"callbacks\", this.name];\n    }\n    get lc_secrets() {\n        return undefined;\n    }\n    get lc_attributes() {\n        return undefined;\n    }\n    get lc_aliases() {\n        return undefined;\n    }\n    /**\n     * The name of the serializable. Override to provide an alias or\n     * to preserve the serialized module name in minified environments.\n     *\n     * Implemented as a static method to support loading logic.\n     */\n    static lc_name() {\n        return this.name;\n    }\n    /**\n     * The final serialized identifier for the module.\n     */\n    get lc_id() {\n        return [\n            ...this.lc_namespace,\n            (0,_load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.get_lc_unique_name)(this.constructor),\n        ];\n    }\n    constructor(input) {\n        super();\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ignoreLLM\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreAgent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreRetriever\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreCustomEvent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"raiseError\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"awaitHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_1__.getEnvironmentVariable)(\"LANGCHAIN_CALLBACKS_BACKGROUND\") !== \"true\"\n        });\n        this.lc_kwargs = input || {};\n        if (input) {\n            this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;\n            this.ignoreChain = input.ignoreChain ?? this.ignoreChain;\n            this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;\n            this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;\n            this.ignoreCustomEvent =\n                input.ignoreCustomEvent ?? this.ignoreCustomEvent;\n            this.raiseError = input.raiseError ?? this.raiseError;\n            this.awaitHandlers =\n                this.raiseError || (input._awaitHandler ?? this.awaitHandlers);\n        }\n    }\n    copy() {\n        return new this.constructor(this);\n    }\n    toJSON() {\n        return _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.Serializable.prototype.toJSON.call(this);\n    }\n    toJSONNotImplemented() {\n        return _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.Serializable.prototype.toJSONNotImplemented.call(this);\n    }\n    static fromMethods(methods) {\n        class Handler extends BaseCallbackHandler {\n            constructor() {\n                super();\n                Object.defineProperty(this, \"name\", {\n                    enumerable: true,\n                    configurable: true,\n                    writable: true,\n                    value: uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"]()\n                });\n                Object.assign(this, methods);\n            }\n        }\n        return new Handler();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2NhbGxiYWNrcy9iYXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkI7QUFDK0M7QUFDbkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUVBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFFQUFzQjtBQUN6QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQVk7QUFDM0I7QUFDQTtBQUNBLGVBQWUsK0RBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDRDQUFPO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFx0ZXh0c3BsaXR0ZXJzXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXGNhbGxiYWNrc1xcYmFzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dWlkIGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBTZXJpYWxpemFibGUsIGdldF9sY191bmlxdWVfbmFtZSwgfSBmcm9tIFwiLi4vbG9hZC9zZXJpYWxpemFibGUuanNcIjtcbmltcG9ydCB7IGdldEVudmlyb25tZW50VmFyaWFibGUgfSBmcm9tIFwiLi4vdXRpbHMvZW52LmpzXCI7XG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHRoYXQgcHJvdmlkZXMgYSBzZXQgb2Ygb3B0aW9uYWwgbWV0aG9kcyB0aGF0IGNhbiBiZVxuICogb3ZlcnJpZGRlbiBpbiBkZXJpdmVkIGNsYXNzZXMgdG8gaGFuZGxlIHZhcmlvdXMgZXZlbnRzIGR1cmluZyB0aGVcbiAqIGV4ZWN1dGlvbiBvZiBhIExhbmdDaGFpbiBhcHBsaWNhdGlvbi5cbiAqL1xuY2xhc3MgQmFzZUNhbGxiYWNrSGFuZGxlck1ldGhvZHNDbGFzcyB7XG59XG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGNyZWF0aW5nIGNhbGxiYWNrIGhhbmRsZXJzIGluIHRoZSBMYW5nQ2hhaW5cbiAqIGZyYW1ld29yay4gSXQgcHJvdmlkZXMgYSBzZXQgb2Ygb3B0aW9uYWwgbWV0aG9kcyB0aGF0IGNhbiBiZSBvdmVycmlkZGVuXG4gKiBpbiBkZXJpdmVkIGNsYXNzZXMgdG8gaGFuZGxlIHZhcmlvdXMgZXZlbnRzIGR1cmluZyB0aGUgZXhlY3V0aW9uIG9mIGFcbiAqIExhbmdDaGFpbiBhcHBsaWNhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VDYWxsYmFja0hhbmRsZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tIYW5kbGVyTWV0aG9kc0NsYXNzIHtcbiAgICBnZXQgbGNfbmFtZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJjYWxsYmFja3NcIiwgdGhpcy5uYW1lXTtcbiAgICB9XG4gICAgZ2V0IGxjX3NlY3JldHMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBsY19hdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6YWJsZS4gT3ZlcnJpZGUgdG8gcHJvdmlkZSBhbiBhbGlhcyBvclxuICAgICAqIHRvIHByZXNlcnZlIHRoZSBzZXJpYWxpemVkIG1vZHVsZSBuYW1lIGluIG1pbmlmaWVkIGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIEltcGxlbWVudGVkIGFzIGEgc3RhdGljIG1ldGhvZCB0byBzdXBwb3J0IGxvYWRpbmcgbG9naWMuXG4gICAgICovXG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaW5hbCBzZXJpYWxpemVkIGlkZW50aWZpZXIgZm9yIHRoZSBtb2R1bGUuXG4gICAgICovXG4gICAgZ2V0IGxjX2lkKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4udGhpcy5sY19uYW1lc3BhY2UsXG4gICAgICAgICAgICBnZXRfbGNfdW5pcXVlX25hbWUodGhpcy5jb25zdHJ1Y3RvciksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX2t3YXJnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZ25vcmVMTE1cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZ25vcmVDaGFpblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlnbm9yZUFnZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWdub3JlUmV0cmlldmVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWdub3JlQ3VzdG9tRXZlbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyYWlzZUVycm9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXdhaXRIYW5kbGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9DQUxMQkFDS1NfQkFDS0dST1VORFwiKSAhPT0gXCJ0cnVlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGNfa3dhcmdzID0gaW5wdXQgfHwge307XG4gICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVMTE0gPSBpbnB1dC5pZ25vcmVMTE0gPz8gdGhpcy5pZ25vcmVMTE07XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUNoYWluID0gaW5wdXQuaWdub3JlQ2hhaW4gPz8gdGhpcy5pZ25vcmVDaGFpbjtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlQWdlbnQgPSBpbnB1dC5pZ25vcmVBZ2VudCA/PyB0aGlzLmlnbm9yZUFnZW50O1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVSZXRyaWV2ZXIgPSBpbnB1dC5pZ25vcmVSZXRyaWV2ZXIgPz8gdGhpcy5pZ25vcmVSZXRyaWV2ZXI7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUN1c3RvbUV2ZW50ID1cbiAgICAgICAgICAgICAgICBpbnB1dC5pZ25vcmVDdXN0b21FdmVudCA/PyB0aGlzLmlnbm9yZUN1c3RvbUV2ZW50O1xuICAgICAgICAgICAgdGhpcy5yYWlzZUVycm9yID0gaW5wdXQucmFpc2VFcnJvciA/PyB0aGlzLnJhaXNlRXJyb3I7XG4gICAgICAgICAgICB0aGlzLmF3YWl0SGFuZGxlcnMgPVxuICAgICAgICAgICAgICAgIHRoaXMucmFpc2VFcnJvciB8fCAoaW5wdXQuX2F3YWl0SGFuZGxlciA/PyB0aGlzLmF3YWl0SGFuZGxlcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gU2VyaWFsaXphYmxlLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgdG9KU09OTm90SW1wbGVtZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiBTZXJpYWxpemFibGUucHJvdG90eXBlLnRvSlNPTk5vdEltcGxlbWVudGVkLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTWV0aG9kcyhtZXRob2RzKSB7XG4gICAgICAgIGNsYXNzIEhhbmRsZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tIYW5kbGVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1dWlkLnY0KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG1ldGhvZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGFuZGxlcigpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/callbacks/base.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/callbacks/manager.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/callbacks/manager.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseCallbackManager: () => (/* binding */ BaseCallbackManager),\n/* harmony export */   BaseRunManager: () => (/* binding */ BaseRunManager),\n/* harmony export */   CallbackManager: () => (/* binding */ CallbackManager),\n/* harmony export */   CallbackManagerForChainRun: () => (/* binding */ CallbackManagerForChainRun),\n/* harmony export */   CallbackManagerForLLMRun: () => (/* binding */ CallbackManagerForLLMRun),\n/* harmony export */   CallbackManagerForRetrieverRun: () => (/* binding */ CallbackManagerForRetrieverRun),\n/* harmony export */   CallbackManagerForToolRun: () => (/* binding */ CallbackManagerForToolRun),\n/* harmony export */   TraceGroup: () => (/* binding */ TraceGroup),\n/* harmony export */   ensureHandler: () => (/* binding */ ensureHandler),\n/* harmony export */   parseCallbackConfigArg: () => (/* binding */ parseCallbackConfigArg),\n/* harmony export */   traceAsGroup: () => (/* binding */ traceAsGroup)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! uuid */ \"(action-browser)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/callbacks/base.js\");\n/* harmony import */ var _tracers_console_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tracers/console.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/console.js\");\n/* harmony import */ var _messages_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../messages/utils.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/utils.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/env.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/env.js\");\n/* harmony import */ var _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tracers/tracer_langchain.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/tracer_langchain.js\");\n/* harmony import */ var _promises_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./promises.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/callbacks/promises.js\");\n/* harmony import */ var _utils_callbacks_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/callbacks.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/callbacks.js\");\n/* harmony import */ var _tracers_base_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tracers/base.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/base.js\");\n\n\n\n\n\n\n\n\n\nif (\n/* #__PURE__ */ (0,_utils_callbacks_js__WEBPACK_IMPORTED_MODULE_6__.isTracingEnabled)() &&\n    /* #__PURE__ */ (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_3__.getEnvironmentVariable)(\"LANGCHAIN_CALLBACKS_BACKGROUND\") !==\n        \"true\") {\n    /* #__PURE__ */ console.warn([\n        \"[WARN]: You have enabled LangSmith tracing without backgrounding callbacks.\",\n        \"[WARN]: If you are not using a serverless environment where you must wait for tracing calls to finish,\",\n        `[WARN]: we suggest setting \"process.env.LANGCHAIN_CALLBACKS_BACKGROUND=true\" to avoid additional latency.`,\n    ].join(\"\\n\"));\n}\nfunction parseCallbackConfigArg(arg) {\n    if (!arg) {\n        return {};\n    }\n    else if (Array.isArray(arg) || \"name\" in arg) {\n        return { callbacks: arg };\n    }\n    else {\n        return arg;\n    }\n}\n/**\n * Manage callbacks from different components of LangChain.\n */\nclass BaseCallbackManager {\n    setHandler(handler) {\n        return this.setHandlers([handler]);\n    }\n}\n/**\n * Base class for run manager in LangChain.\n */\nclass BaseRunManager {\n    constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {\n        Object.defineProperty(this, \"runId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: runId\n        });\n        Object.defineProperty(this, \"handlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: handlers\n        });\n        Object.defineProperty(this, \"inheritableHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableHandlers\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: tags\n        });\n        Object.defineProperty(this, \"inheritableTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableTags\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: metadata\n        });\n        Object.defineProperty(this, \"inheritableMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableMetadata\n        });\n        Object.defineProperty(this, \"_parentRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _parentRunId\n        });\n    }\n    get parentRunId() {\n        return this._parentRunId;\n    }\n    async handleText(text) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            try {\n                await handler.handleText?.(text, this.runId, this._parentRunId, this.tags);\n            }\n            catch (err) {\n                const logFunction = handler.raiseError\n                    ? console.error\n                    : console.warn;\n                logFunction(`Error in handler ${handler.constructor.name}, handleText: ${err}`);\n                if (handler.raiseError) {\n                    throw err;\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleCustomEvent(eventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data, _runId, _tags, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            try {\n                await handler.handleCustomEvent?.(eventName, data, this.runId, this.tags, this.metadata);\n            }\n            catch (err) {\n                const logFunction = handler.raiseError\n                    ? console.error\n                    : console.warn;\n                logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);\n                if (handler.raiseError) {\n                    throw err;\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\n/**\n * Manages callbacks for retriever runs.\n */\nclass CallbackManagerForRetrieverRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleRetrieverEnd(documents) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreRetriever) {\n                try {\n                    await handler.handleRetrieverEnd?.(documents, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetriever`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleRetrieverError(err) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreRetriever) {\n                try {\n                    await handler.handleRetrieverError?.(err, this.runId, this._parentRunId, this.tags);\n                }\n                catch (error) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nclass CallbackManagerForLLMRun extends BaseRunManager {\n    async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMNewToken?.(token, idx ?? { prompt: 0, completion: 0 }, this.runId, this._parentRunId, this.tags, fields);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleLLMError(err) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMError?.(err, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleLLMEnd(output) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMEnd?.(output, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nclass CallbackManagerForChainRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreChain) {\n                try {\n                    await handler.handleChainError?.(err, this.runId, this._parentRunId, this.tags, kwargs);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreChain) {\n                try {\n                    await handler.handleChainEnd?.(output, this.runId, this._parentRunId, this.tags, kwargs);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleAgentAction(action) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleAgentAction?.(action, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleAgentEnd(action) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleAgentEnd?.(action, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nclass CallbackManagerForToolRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleToolError(err) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleToolError?.(err, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleToolEnd(output) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleToolEnd?.(output, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\n/**\n * @example\n * ```typescript\n * const prompt = PromptTemplate.fromTemplate(\"What is the answer to {question}?\");\n *\n * // Example of using LLMChain with OpenAI and a simple prompt\n * const chain = new LLMChain({\n *   llm: new ChatOpenAI({ temperature: 0.9 }),\n *   prompt,\n * });\n *\n * // Running the chain with a single question\n * const result = await chain.call({\n *   question: \"What is the airspeed velocity of an unladen swallow?\",\n * });\n * console.log(\"The answer is:\", result);\n * ```\n */\nclass CallbackManager extends BaseCallbackManager {\n    constructor(parentRunId, options) {\n        super();\n        Object.defineProperty(this, \"handlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"inheritableHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"inheritableTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"inheritableMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"callback_manager\"\n        });\n        Object.defineProperty(this, \"_parentRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.handlers = options?.handlers ?? this.handlers;\n        this.inheritableHandlers =\n            options?.inheritableHandlers ?? this.inheritableHandlers;\n        this.tags = options?.tags ?? this.tags;\n        this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;\n        this.metadata = options?.metadata ?? this.metadata;\n        this.inheritableMetadata =\n            options?.inheritableMetadata ?? this.inheritableMetadata;\n        this._parentRunId = parentRunId;\n    }\n    /**\n     * Gets the parent run ID, if any.\n     *\n     * @returns The parent run ID.\n     */\n    getParentRunId() {\n        return this._parentRunId;\n    }\n    async handleLLMStart(llm, prompts, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        return Promise.all(prompts.map(async (prompt, idx) => {\n            // Can't have duplicate runs with the same run ID (if provided)\n            const runId_ = idx === 0 && runId ? runId : (0,uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n            await Promise.all(this.handlers.map((handler) => {\n                if (handler.ignoreLLM) {\n                    return;\n                }\n                if ((0,_tracers_base_js__WEBPACK_IMPORTED_MODULE_7__.isBaseTracer)(handler)) {\n                    // Create and add run to the run map.\n                    // We do this synchronously to avoid race conditions\n                    // when callbacks are backgrounded.\n                    handler._createRunForLLMStart(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                }\n                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n                    try {\n                        await handler.handleLLMStart?.(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                    }\n                    catch (err) {\n                        const logFunction = handler.raiseError\n                            ? console.error\n                            : console.warn;\n                        logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n                        if (handler.raiseError) {\n                            throw err;\n                        }\n                    }\n                }, handler.awaitHandlers);\n            }));\n            return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n        }));\n    }\n    async handleChatModelStart(llm, messages, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        return Promise.all(messages.map(async (messageGroup, idx) => {\n            // Can't have duplicate runs with the same run ID (if provided)\n            const runId_ = idx === 0 && runId ? runId : (0,uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n            await Promise.all(this.handlers.map((handler) => {\n                if (handler.ignoreLLM) {\n                    return;\n                }\n                if ((0,_tracers_base_js__WEBPACK_IMPORTED_MODULE_7__.isBaseTracer)(handler)) {\n                    // Create and add run to the run map.\n                    // We do this synchronously to avoid race conditions\n                    // when callbacks are backgrounded.\n                    handler._createRunForChatModelStart(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                }\n                return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n                    try {\n                        if (handler.handleChatModelStart) {\n                            await handler.handleChatModelStart?.(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                        }\n                        else if (handler.handleLLMStart) {\n                            const messageString = (0,_messages_utils_js__WEBPACK_IMPORTED_MODULE_2__.getBufferString)(messageGroup);\n                            await handler.handleLLMStart?.(llm, [messageString], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                        }\n                    }\n                    catch (err) {\n                        const logFunction = handler.raiseError\n                            ? console.error\n                            : console.warn;\n                        logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n                        if (handler.raiseError) {\n                            throw err;\n                        }\n                    }\n                }, handler.awaitHandlers);\n            }));\n            return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n        }));\n    }\n    async handleChainStart(chain, inputs, runId = (0,uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(), runType = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreChain) {\n                return;\n            }\n            if ((0,_tracers_base_js__WEBPACK_IMPORTED_MODULE_7__.isBaseTracer)(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForChainStart(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);\n            }\n            return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n                try {\n                    await handler.handleChainStart?.(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleToolStart(tool, input, runId = (0,uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreAgent) {\n                return;\n            }\n            if ((0,_tracers_base_js__WEBPACK_IMPORTED_MODULE_7__.isBaseTracer)(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForToolStart(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);\n            }\n            return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n                try {\n                    await handler.handleToolStart?.(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleRetrieverStart(retriever, query, runId = (0,uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreRetriever) {\n                return;\n            }\n            if ((0,_tracers_base_js__WEBPACK_IMPORTED_MODULE_7__.isBaseTracer)(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForRetrieverStart(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);\n            }\n            return (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n                try {\n                    await handler.handleRetrieverStart?.(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleCustomEvent(eventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data, runId, _tags, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata) {\n        await Promise.all(this.handlers.map((handler) => (0,_promises_js__WEBPACK_IMPORTED_MODULE_5__.consumeCallback)(async () => {\n            if (!handler.ignoreCustomEvent) {\n                try {\n                    await handler.handleCustomEvent?.(eventName, data, runId, this.tags, this.metadata);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    addHandler(handler, inherit = true) {\n        this.handlers.push(handler);\n        if (inherit) {\n            this.inheritableHandlers.push(handler);\n        }\n    }\n    removeHandler(handler) {\n        this.handlers = this.handlers.filter((_handler) => _handler !== handler);\n        this.inheritableHandlers = this.inheritableHandlers.filter((_handler) => _handler !== handler);\n    }\n    setHandlers(handlers, inherit = true) {\n        this.handlers = [];\n        this.inheritableHandlers = [];\n        for (const handler of handlers) {\n            this.addHandler(handler, inherit);\n        }\n    }\n    addTags(tags, inherit = true) {\n        this.removeTags(tags); // Remove duplicates\n        this.tags.push(...tags);\n        if (inherit) {\n            this.inheritableTags.push(...tags);\n        }\n    }\n    removeTags(tags) {\n        this.tags = this.tags.filter((tag) => !tags.includes(tag));\n        this.inheritableTags = this.inheritableTags.filter((tag) => !tags.includes(tag));\n    }\n    addMetadata(metadata, inherit = true) {\n        this.metadata = { ...this.metadata, ...metadata };\n        if (inherit) {\n            this.inheritableMetadata = { ...this.inheritableMetadata, ...metadata };\n        }\n    }\n    removeMetadata(metadata) {\n        for (const key of Object.keys(metadata)) {\n            delete this.metadata[key];\n            delete this.inheritableMetadata[key];\n        }\n    }\n    copy(additionalHandlers = [], inherit = true) {\n        const manager = new CallbackManager(this._parentRunId);\n        for (const handler of this.handlers) {\n            const inheritable = this.inheritableHandlers.includes(handler);\n            manager.addHandler(handler, inheritable);\n        }\n        for (const tag of this.tags) {\n            const inheritable = this.inheritableTags.includes(tag);\n            manager.addTags([tag], inheritable);\n        }\n        for (const key of Object.keys(this.metadata)) {\n            const inheritable = Object.keys(this.inheritableMetadata).includes(key);\n            manager.addMetadata({ [key]: this.metadata[key] }, inheritable);\n        }\n        for (const handler of additionalHandlers) {\n            if (\n            // Prevent multiple copies of console_callback_handler\n            manager.handlers\n                .filter((h) => h.name === \"console_callback_handler\")\n                .some((h) => h.name === handler.name)) {\n                continue;\n            }\n            manager.addHandler(handler, inherit);\n        }\n        return manager;\n    }\n    static fromHandlers(handlers) {\n        class Handler extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseCallbackHandler {\n            constructor() {\n                super();\n                Object.defineProperty(this, \"name\", {\n                    enumerable: true,\n                    configurable: true,\n                    writable: true,\n                    value: (0,uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"])()\n                });\n                Object.assign(this, handlers);\n            }\n        }\n        const manager = new this();\n        manager.addHandler(new Handler());\n        return manager;\n    }\n    static async configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {\n        return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options);\n    }\n    // TODO: Deprecate async method in favor of this one.\n    static _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {\n        let callbackManager;\n        if (inheritableHandlers || localHandlers) {\n            if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {\n                callbackManager = new CallbackManager();\n                callbackManager.setHandlers(inheritableHandlers?.map(ensureHandler) ?? [], true);\n            }\n            else {\n                callbackManager = inheritableHandlers;\n            }\n            callbackManager = callbackManager.copy(Array.isArray(localHandlers)\n                ? localHandlers.map(ensureHandler)\n                : localHandlers?.handlers, false);\n        }\n        const verboseEnabled = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_3__.getEnvironmentVariable)(\"LANGCHAIN_VERBOSE\") === \"true\" ||\n            options?.verbose;\n        const tracingV2Enabled = _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_4__.LangChainTracer.getTraceableRunTree()?.tracingEnabled ||\n            (0,_utils_callbacks_js__WEBPACK_IMPORTED_MODULE_6__.isTracingEnabled)();\n        const tracingEnabled = tracingV2Enabled ||\n            ((0,_utils_env_js__WEBPACK_IMPORTED_MODULE_3__.getEnvironmentVariable)(\"LANGCHAIN_TRACING\") ?? false);\n        if (verboseEnabled || tracingEnabled) {\n            if (!callbackManager) {\n                callbackManager = new CallbackManager();\n            }\n            if (verboseEnabled &&\n                !callbackManager.handlers.some((handler) => handler.name === _tracers_console_js__WEBPACK_IMPORTED_MODULE_1__.ConsoleCallbackHandler.prototype.name)) {\n                const consoleHandler = new _tracers_console_js__WEBPACK_IMPORTED_MODULE_1__.ConsoleCallbackHandler();\n                callbackManager.addHandler(consoleHandler, true);\n            }\n            if (tracingEnabled &&\n                !callbackManager.handlers.some((handler) => handler.name === \"langchain_tracer\")) {\n                if (tracingV2Enabled) {\n                    const tracerV2 = new _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_4__.LangChainTracer();\n                    callbackManager.addHandler(tracerV2, true);\n                    // handoff between langchain and langsmith/traceable\n                    // override the parent run ID\n                    callbackManager._parentRunId =\n                        _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_4__.LangChainTracer.getTraceableRunTree()?.id ??\n                            callbackManager._parentRunId;\n                }\n            }\n        }\n        if (inheritableTags || localTags) {\n            if (callbackManager) {\n                callbackManager.addTags(inheritableTags ?? []);\n                callbackManager.addTags(localTags ?? [], false);\n            }\n        }\n        if (inheritableMetadata || localMetadata) {\n            if (callbackManager) {\n                callbackManager.addMetadata(inheritableMetadata ?? {});\n                callbackManager.addMetadata(localMetadata ?? {}, false);\n            }\n        }\n        return callbackManager;\n    }\n}\nfunction ensureHandler(handler) {\n    if (\"name\" in handler) {\n        return handler;\n    }\n    return _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseCallbackHandler.fromMethods(handler);\n}\n/**\n * @example\n * ```typescript\n * const prompt = PromptTemplate.fromTemplate(`What is the answer to {question}?`);\n *\n * // Example of using LLMChain to process a series of questions\n * const chain = new LLMChain({\n *   llm: new ChatOpenAI({ temperature: 0.9 }),\n *   prompt,\n * });\n *\n * // Process questions using the chain\n * const processQuestions = async (questions) => {\n *   for (const question of questions) {\n *     const result = await chain.call({ question });\n *     console.log(result);\n *   }\n * };\n *\n * // Example questions\n * const questions = [\n *   \"What is your name?\",\n *   \"What is your quest?\",\n *   \"What is your favorite color?\",\n * ];\n *\n * // Run the example\nconst logFunction = handler.raiseError ? console.error : console.warn;\n* processQuestions(questions).catch(consolelogFunction;\n *\n * ```\n */\nclass TraceGroup {\n    constructor(groupName, options) {\n        Object.defineProperty(this, \"groupName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: groupName\n        });\n        Object.defineProperty(this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: options\n        });\n        Object.defineProperty(this, \"runManager\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    async getTraceGroupCallbackManager(group_name, inputs, options) {\n        const cb = new _tracers_tracer_langchain_js__WEBPACK_IMPORTED_MODULE_4__.LangChainTracer(options);\n        const cm = await CallbackManager.configure([cb]);\n        const runManager = await cm?.handleChainStart({\n            lc: 1,\n            type: \"not_implemented\",\n            id: [\"langchain\", \"callbacks\", \"groups\", group_name],\n        }, inputs ?? {});\n        if (!runManager) {\n            throw new Error(\"Failed to create run group callback manager.\");\n        }\n        return runManager;\n    }\n    async start(inputs) {\n        if (!this.runManager) {\n            this.runManager = await this.getTraceGroupCallbackManager(this.groupName, inputs, this.options);\n        }\n        return this.runManager.getChild();\n    }\n    async error(err) {\n        if (this.runManager) {\n            await this.runManager.handleChainError(err);\n            this.runManager = undefined;\n        }\n    }\n    async end(output) {\n        if (this.runManager) {\n            await this.runManager.handleChainEnd(output ?? {});\n            this.runManager = undefined;\n        }\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function traceAsGroup(groupOptions, enclosedCode, ...args) {\n    const traceGroup = new TraceGroup(groupOptions.name, groupOptions);\n    const callbackManager = await traceGroup.start({ ...args });\n    try {\n        const result = await enclosedCode(callbackManager, ...args);\n        await traceGroup.end(_coerceToDict(result, \"output\"));\n        return result;\n    }\n    catch (err) {\n        await traceGroup.error(err);\n        throw err;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2NhbGxiYWNrcy9tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ2E7QUFDYztBQUNSO0FBQ0U7QUFDUztBQUNsQjtBQUNTO0FBQ1A7QUFDbEQ7QUFDQSxnQkFBZ0IscUVBQWdCO0FBQ2hDLG9CQUFvQixxRUFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDZEQUFlO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHlCQUF5QixnQkFBZ0IsSUFBSTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsNkRBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCLHVCQUF1QixJQUFJO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCw2REFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5REFBeUQsNkRBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsMEJBQTBCLE1BQU07QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBLHlEQUF5RCw2REFBZTtBQUN4RTtBQUNBO0FBQ0Esc0VBQXNFLDBCQUEwQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5Qix1QkFBdUIsSUFBSTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5REFBeUQsNkRBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsb0JBQW9CLElBQUk7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseURBQXlELDZEQUFlO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLGtCQUFrQixJQUFJO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDZEQUFlO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLHNCQUFzQixJQUFJO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlEQUF5RCw2REFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QixvQkFBb0IsSUFBSTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5REFBeUQsNkRBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsdUJBQXVCLElBQUk7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseURBQXlELDZEQUFlO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLG9CQUFvQixJQUFJO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDZEQUFlO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLHFCQUFxQixJQUFJO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseURBQXlELDZEQUFlO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLG1CQUFtQixJQUFJO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxTQUFTO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnREFBTTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4REFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZEQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHlCQUF5QixvQkFBb0IsSUFBSTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0RBQU07QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOERBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2REFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG1FQUFlO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHlCQUF5QixvQkFBb0IsSUFBSTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrREFBa0QsZ0RBQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOERBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2REFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsc0JBQXNCLElBQUk7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSwrQ0FBK0MsZ0RBQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOERBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2REFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIscUJBQXFCLElBQUk7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSx5REFBeUQsZ0RBQU07QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOERBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2REFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsMEJBQTBCLElBQUk7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDZEQUFlO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLHVCQUF1QixJQUFJO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyQkFBMkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5REFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFNO0FBQ2pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxRUFBc0I7QUFDckQ7QUFDQSxpQ0FBaUMseUVBQWU7QUFDaEQsWUFBWSxxRUFBZ0I7QUFDNUI7QUFDQSxhQUFhLHFFQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHVFQUFzQjtBQUNuRywyQ0FBMkMsdUVBQXNCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseUVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlEQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxTQUFTO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1QkFBdUIseUVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsY0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFx0ZXh0c3BsaXR0ZXJzXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXGNhbGxiYWNrc1xcbWFuYWdlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgQmFzZUNhbGxiYWNrSGFuZGxlciwgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBDb25zb2xlQ2FsbGJhY2tIYW5kbGVyIH0gZnJvbSBcIi4uL3RyYWNlcnMvY29uc29sZS5qc1wiO1xuaW1wb3J0IHsgZ2V0QnVmZmVyU3RyaW5nIH0gZnJvbSBcIi4uL21lc3NhZ2VzL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4uL3V0aWxzL2Vudi5qc1wiO1xuaW1wb3J0IHsgTGFuZ0NoYWluVHJhY2VyLCB9IGZyb20gXCIuLi90cmFjZXJzL3RyYWNlcl9sYW5nY2hhaW4uanNcIjtcbmltcG9ydCB7IGNvbnN1bWVDYWxsYmFjayB9IGZyb20gXCIuL3Byb21pc2VzLmpzXCI7XG5pbXBvcnQgeyBpc1RyYWNpbmdFbmFibGVkIH0gZnJvbSBcIi4uL3V0aWxzL2NhbGxiYWNrcy5qc1wiO1xuaW1wb3J0IHsgaXNCYXNlVHJhY2VyIH0gZnJvbSBcIi4uL3RyYWNlcnMvYmFzZS5qc1wiO1xuaWYgKFxuLyogI19fUFVSRV9fICovIGlzVHJhY2luZ0VuYWJsZWQoKSAmJlxuICAgIC8qICNfX1BVUkVfXyAqLyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0NBTExCQUNLU19CQUNLR1JPVU5EXCIpICE9PVxuICAgICAgICBcInRydWVcIikge1xuICAgIC8qICNfX1BVUkVfXyAqLyBjb25zb2xlLndhcm4oW1xuICAgICAgICBcIltXQVJOXTogWW91IGhhdmUgZW5hYmxlZCBMYW5nU21pdGggdHJhY2luZyB3aXRob3V0IGJhY2tncm91bmRpbmcgY2FsbGJhY2tzLlwiLFxuICAgICAgICBcIltXQVJOXTogSWYgeW91IGFyZSBub3QgdXNpbmcgYSBzZXJ2ZXJsZXNzIGVudmlyb25tZW50IHdoZXJlIHlvdSBtdXN0IHdhaXQgZm9yIHRyYWNpbmcgY2FsbHMgdG8gZmluaXNoLFwiLFxuICAgICAgICBgW1dBUk5dOiB3ZSBzdWdnZXN0IHNldHRpbmcgXCJwcm9jZXNzLmVudi5MQU5HQ0hBSU5fQ0FMTEJBQ0tTX0JBQ0tHUk9VTkQ9dHJ1ZVwiIHRvIGF2b2lkIGFkZGl0aW9uYWwgbGF0ZW5jeS5gLFxuICAgIF0uam9pbihcIlxcblwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDYWxsYmFja0NvbmZpZ0FyZyhhcmcpIHtcbiAgICBpZiAoIWFyZykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSB8fCBcIm5hbWVcIiBpbiBhcmcpIHtcbiAgICAgICAgcmV0dXJuIHsgY2FsbGJhY2tzOiBhcmcgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgfVxufVxuLyoqXG4gKiBNYW5hZ2UgY2FsbGJhY2tzIGZyb20gZGlmZmVyZW50IGNvbXBvbmVudHMgb2YgTGFuZ0NoYWluLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZUNhbGxiYWNrTWFuYWdlciB7XG4gICAgc2V0SGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldEhhbmRsZXJzKFtoYW5kbGVyXSk7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBydW4gbWFuYWdlciBpbiBMYW5nQ2hhaW4uXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlUnVuTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IocnVuSWQsIGhhbmRsZXJzLCBpbmhlcml0YWJsZUhhbmRsZXJzLCB0YWdzLCBpbmhlcml0YWJsZVRhZ3MsIG1ldGFkYXRhLCBpbmhlcml0YWJsZU1ldGFkYXRhLCBfcGFyZW50UnVuSWQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVuSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHJ1bklkXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogaGFuZGxlcnNcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlSGFuZGxlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGluaGVyaXRhYmxlSGFuZGxlcnNcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRhZ3NcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogaW5oZXJpdGFibGVUYWdzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlTWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGluaGVyaXRhYmxlTWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wYXJlbnRSdW5JZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogX3BhcmVudFJ1bklkXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgcGFyZW50UnVuSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnRSdW5JZDtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVGV4dCh0ZXh0KSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVRleHQ/Lih0ZXh0LCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVUZXh0OiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGRhdGEsIF9ydW5JZCwgX3RhZ3MsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgX21ldGFkYXRhKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUN1c3RvbUV2ZW50Py4oZXZlbnROYW1lLCBkYXRhLCB0aGlzLnJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUN1c3RvbUV2ZW50OiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG59XG4vKipcbiAqIE1hbmFnZXMgY2FsbGJhY2tzIGZvciByZXRyaWV2ZXIgcnVucy5cbiAqL1xuZXhwb3J0IGNsYXNzIENhbGxiYWNrTWFuYWdlckZvclJldHJpZXZlclJ1biBleHRlbmRzIEJhc2VSdW5NYW5hZ2VyIHtcbiAgICBnZXRDaGlsZCh0YWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBjb25zdCBtYW5hZ2VyID0gbmV3IENhbGxiYWNrTWFuYWdlcih0aGlzLnJ1bklkKTtcbiAgICAgICAgbWFuYWdlci5zZXRIYW5kbGVycyh0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMpO1xuICAgICAgICBtYW5hZ2VyLmFkZFRhZ3ModGhpcy5pbmhlcml0YWJsZVRhZ3MpO1xuICAgICAgICBtYW5hZ2VyLmFkZE1ldGFkYXRhKHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSk7XG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkVGFncyhbdGFnXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJFbmQoZG9jdW1lbnRzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZVJldHJpZXZlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlUmV0cmlldmVyRW5kPy4oZG9jdW1lbnRzLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVSZXRyaWV2ZXJgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlckVycm9yKGVycikge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVSZXRyaWV2ZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVJldHJpZXZlckVycm9yPy4oZXJyLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVJldHJpZXZlckVycm9yOiAke2Vycm9yfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuIGV4dGVuZHMgQmFzZVJ1bk1hbmFnZXIge1xuICAgIGFzeW5jIGhhbmRsZUxMTU5ld1Rva2VuKHRva2VuLCBpZHgsIF9ydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywgZmllbGRzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUxMTSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlTExNTmV3VG9rZW4/Lih0b2tlbiwgaWR4ID8/IHsgcHJvbXB0OiAwLCBjb21wbGV0aW9uOiAwIH0sIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIGZpZWxkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlTExNTmV3VG9rZW46ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNRXJyb3IoZXJyKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUxMTSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlTExNRXJyb3I/LihlcnIsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTUVycm9yOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTUVuZChvdXRwdXQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlTExNKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVMTE1FbmQ/LihvdXRwdXQsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTUVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDYWxsYmFja01hbmFnZXJGb3JDaGFpblJ1biBleHRlbmRzIEJhc2VSdW5NYW5hZ2VyIHtcbiAgICBnZXRDaGlsZCh0YWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBjb25zdCBtYW5hZ2VyID0gbmV3IENhbGxiYWNrTWFuYWdlcih0aGlzLnJ1bklkKTtcbiAgICAgICAgbWFuYWdlci5zZXRIYW5kbGVycyh0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMpO1xuICAgICAgICBtYW5hZ2VyLmFkZFRhZ3ModGhpcy5pbmhlcml0YWJsZVRhZ3MpO1xuICAgICAgICBtYW5hZ2VyLmFkZE1ldGFkYXRhKHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSk7XG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkVGFncyhbdGFnXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpbkVycm9yKGVyciwgX3J1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBrd2FyZ3MpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQ2hhaW4pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUNoYWluRXJyb3I/LihlcnIsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIGt3YXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQ2hhaW5FcnJvcjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpbkVuZChvdXRwdXQsIF9ydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywga3dhcmdzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUNoYWluKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVDaGFpbkVuZD8uKG91dHB1dCwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywga3dhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDaGFpbkVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEFjdGlvbihhY3Rpb24pIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUFnZW50QWN0aW9uPy4oYWN0aW9uLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVBZ2VudEFjdGlvbjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEVuZChhY3Rpb24pIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUFnZW50RW5kPy4oYWN0aW9uLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVBZ2VudEVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDYWxsYmFja01hbmFnZXJGb3JUb29sUnVuIGV4dGVuZHMgQmFzZVJ1bk1hbmFnZXIge1xuICAgIGdldENoaWxkKHRhZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHRoaXMucnVuSWQpO1xuICAgICAgICBtYW5hZ2VyLnNldEhhbmRsZXJzKHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycyk7XG4gICAgICAgIG1hbmFnZXIuYWRkVGFncyh0aGlzLmluaGVyaXRhYmxlVGFncyk7XG4gICAgICAgIG1hbmFnZXIuYWRkTWV0YWRhdGEodGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhKTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgbWFuYWdlci5hZGRUYWdzKFt0YWddLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFcnJvcihlcnIpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVRvb2xFcnJvcj8uKGVyciwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlVG9vbEVycm9yOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgaGFuZGxlVG9vbEVuZChvdXRwdXQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVRvb2xFbmQ/LihvdXRwdXQsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVRvb2xFbmQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBwcm9tcHQgPSBQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoXCJXaGF0IGlzIHRoZSBhbnN3ZXIgdG8ge3F1ZXN0aW9ufT9cIik7XG4gKlxuICogLy8gRXhhbXBsZSBvZiB1c2luZyBMTE1DaGFpbiB3aXRoIE9wZW5BSSBhbmQgYSBzaW1wbGUgcHJvbXB0XG4gKiBjb25zdCBjaGFpbiA9IG5ldyBMTE1DaGFpbih7XG4gKiAgIGxsbTogbmV3IENoYXRPcGVuQUkoeyB0ZW1wZXJhdHVyZTogMC45IH0pLFxuICogICBwcm9tcHQsXG4gKiB9KTtcbiAqXG4gKiAvLyBSdW5uaW5nIHRoZSBjaGFpbiB3aXRoIGEgc2luZ2xlIHF1ZXN0aW9uXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGFpbi5jYWxsKHtcbiAqICAgcXVlc3Rpb246IFwiV2hhdCBpcyB0aGUgYWlyc3BlZWQgdmVsb2NpdHkgb2YgYW4gdW5sYWRlbiBzd2FsbG93P1wiLFxuICogfSk7XG4gKiBjb25zb2xlLmxvZyhcIlRoZSBhbnN3ZXIgaXM6XCIsIHJlc3VsdCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIENhbGxiYWNrTWFuYWdlciBleHRlbmRzIEJhc2VDYWxsYmFja01hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFJ1bklkLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5oZXJpdGFibGVIYW5kbGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlTWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImNhbGxiYWNrX21hbmFnZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BhcmVudFJ1bklkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBvcHRpb25zPy5oYW5kbGVycyA/PyB0aGlzLmhhbmRsZXJzO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMgPVxuICAgICAgICAgICAgb3B0aW9ucz8uaW5oZXJpdGFibGVIYW5kbGVycyA/PyB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnM7XG4gICAgICAgIHRoaXMudGFncyA9IG9wdGlvbnM/LnRhZ3MgPz8gdGhpcy50YWdzO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlVGFncyA9IG9wdGlvbnM/LmluaGVyaXRhYmxlVGFncyA/PyB0aGlzLmluaGVyaXRhYmxlVGFncztcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG9wdGlvbnM/Lm1ldGFkYXRhID8/IHRoaXMubWV0YWRhdGE7XG4gICAgICAgIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSA9XG4gICAgICAgICAgICBvcHRpb25zPy5pbmhlcml0YWJsZU1ldGFkYXRhID8/IHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YTtcbiAgICAgICAgdGhpcy5fcGFyZW50UnVuSWQgPSBwYXJlbnRSdW5JZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHJ1biBJRCwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcmVudCBydW4gSUQuXG4gICAgICovXG4gICAgZ2V0UGFyZW50UnVuSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnRSdW5JZDtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNU3RhcnQobGxtLCBwcm9tcHRzLCBydW5JZCA9IHVuZGVmaW5lZCwgX3BhcmVudFJ1bklkID0gdW5kZWZpbmVkLCBleHRyYVBhcmFtcyA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXB0cy5tYXAoYXN5bmMgKHByb21wdCwgaWR4KSA9PiB7XG4gICAgICAgICAgICAvLyBDYW4ndCBoYXZlIGR1cGxpY2F0ZSBydW5zIHdpdGggdGhlIHNhbWUgcnVuIElEIChpZiBwcm92aWRlZClcbiAgICAgICAgICAgIGNvbnN0IHJ1bklkXyA9IGlkeCA9PT0gMCAmJiBydW5JZCA/IHJ1bklkIDogdXVpZHY0KCk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmlnbm9yZUxMTSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0Jhc2VUcmFjZXIoaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgcnVuIHRvIHRoZSBydW4gbWFwLlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQuXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX2NyZWF0ZVJ1bkZvckxMTVN0YXJ0KGxsbSwgW3Byb21wdF0sIHJ1bklkXywgdGhpcy5fcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlTExNU3RhcnQ/LihsbG0sIFtwcm9tcHRdLCBydW5JZF8sIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVMTE1TdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuKHJ1bklkXywgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGF0TW9kZWxTdGFydChsbG0sIG1lc3NhZ2VzLCBydW5JZCA9IHVuZGVmaW5lZCwgX3BhcmVudFJ1bklkID0gdW5kZWZpbmVkLCBleHRyYVBhcmFtcyA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobWVzc2FnZXMubWFwKGFzeW5jIChtZXNzYWdlR3JvdXAsIGlkeCkgPT4ge1xuICAgICAgICAgICAgLy8gQ2FuJ3QgaGF2ZSBkdXBsaWNhdGUgcnVucyB3aXRoIHRoZSBzYW1lIHJ1biBJRCAoaWYgcHJvdmlkZWQpXG4gICAgICAgICAgICBjb25zdCBydW5JZF8gPSBpZHggPT09IDAgJiYgcnVuSWQgPyBydW5JZCA6IHV1aWR2NCgpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5pZ25vcmVMTE0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNCYXNlVHJhY2VyKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHJ1biB0byB0aGUgcnVuIG1hcC5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG8gdGhpcyBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGNhbGxiYWNrcyBhcmUgYmFja2dyb3VuZGVkLlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9jcmVhdGVSdW5Gb3JDaGF0TW9kZWxTdGFydChsbG0sIFttZXNzYWdlR3JvdXBdLCBydW5JZF8sIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5oYW5kbGVDaGF0TW9kZWxTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQ2hhdE1vZGVsU3RhcnQ/LihsbG0sIFttZXNzYWdlR3JvdXBdLCBydW5JZF8sIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhbmRsZXIuaGFuZGxlTExNU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlU3RyaW5nID0gZ2V0QnVmZmVyU3RyaW5nKG1lc3NhZ2VHcm91cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVMTE1TdGFydD8uKGxsbSwgW21lc3NhZ2VTdHJpbmddLCBydW5JZF8sIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVMTE1TdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuKHJ1bklkXywgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpblN0YXJ0KGNoYWluLCBpbnB1dHMsIHJ1bklkID0gdXVpZHY0KCksIHJ1blR5cGUgPSB1bmRlZmluZWQsIF90YWdzID0gdW5kZWZpbmVkLCBfbWV0YWRhdGEgPSB1bmRlZmluZWQsIHJ1bk5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmlnbm9yZUNoYWluKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQmFzZVRyYWNlcihoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHJ1biB0byB0aGUgcnVuIG1hcC5cbiAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZC5cbiAgICAgICAgICAgICAgICBoYW5kbGVyLl9jcmVhdGVSdW5Gb3JDaGFpblN0YXJ0KGNoYWluLCBpbnB1dHMsIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5UeXBlLCBydW5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQ2hhaW5TdGFydD8uKGNoYWluLCBpbnB1dHMsIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5UeXBlLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDaGFpblN0YXJ0OiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbmV3IENhbGxiYWNrTWFuYWdlckZvckNoYWluUnVuKHJ1bklkLCB0aGlzLmhhbmRsZXJzLCB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMsIHRoaXMudGFncywgdGhpcy5pbmhlcml0YWJsZVRhZ3MsIHRoaXMubWV0YWRhdGEsIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5fcGFyZW50UnVuSWQpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUb29sU3RhcnQodG9vbCwgaW5wdXQsIHJ1bklkID0gdXVpZHY0KCksIF9wYXJlbnRSdW5JZCA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNCYXNlVHJhY2VyKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgcnVuIHRvIHRoZSBydW4gbWFwLlxuICAgICAgICAgICAgICAgIC8vIFdlIGRvIHRoaXMgc3luY2hyb25vdXNseSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGNhbGxiYWNrcyBhcmUgYmFja2dyb3VuZGVkLlxuICAgICAgICAgICAgICAgIGhhbmRsZXIuX2NyZWF0ZVJ1bkZvclRvb2xTdGFydCh0b29sLCBpbnB1dCwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVUb29sU3RhcnQ/Lih0b29sLCBpbnB1dCwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVRvb2xTdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycyk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsYmFja01hbmFnZXJGb3JUb29sUnVuKHJ1bklkLCB0aGlzLmhhbmRsZXJzLCB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMsIHRoaXMudGFncywgdGhpcy5pbmhlcml0YWJsZVRhZ3MsIHRoaXMubWV0YWRhdGEsIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5fcGFyZW50UnVuSWQpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJTdGFydChyZXRyaWV2ZXIsIHF1ZXJ5LCBydW5JZCA9IHV1aWR2NCgpLCBfcGFyZW50UnVuSWQgPSB1bmRlZmluZWQsIF90YWdzID0gdW5kZWZpbmVkLCBfbWV0YWRhdGEgPSB1bmRlZmluZWQsIHJ1bk5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmlnbm9yZVJldHJpZXZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0Jhc2VUcmFjZXIoaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCBydW4gdG8gdGhlIHJ1biBtYXAuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gdGhpcyBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQuXG4gICAgICAgICAgICAgICAgaGFuZGxlci5fY3JlYXRlUnVuRm9yUmV0cmlldmVyU3RhcnQocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVSZXRyaWV2ZXJTdGFydD8uKHJldHJpZXZlciwgcXVlcnksIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVSZXRyaWV2ZXJTdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycyk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsYmFja01hbmFnZXJGb3JSZXRyaWV2ZXJSdW4ocnVuSWQsIHRoaXMuaGFuZGxlcnMsIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycywgdGhpcy50YWdzLCB0aGlzLmluaGVyaXRhYmxlVGFncywgdGhpcy5tZXRhZGF0YSwgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhLCB0aGlzLl9wYXJlbnRSdW5JZCk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBkYXRhLCBydW5JZCwgX3RhZ3MsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgX21ldGFkYXRhKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUN1c3RvbUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVDdXN0b21FdmVudD8uKGV2ZW50TmFtZSwgZGF0YSwgcnVuSWQsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQ3VzdG9tRXZlbnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYWRkSGFuZGxlcihoYW5kbGVyLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHRoaXMuaGFuZGxlcnMuZmlsdGVyKChfaGFuZGxlcikgPT4gX2hhbmRsZXIgIT09IGhhbmRsZXIpO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMgPSB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMuZmlsdGVyKChfaGFuZGxlcikgPT4gX2hhbmRsZXIgIT09IGhhbmRsZXIpO1xuICAgIH1cbiAgICBzZXRIYW5kbGVycyhoYW5kbGVycywgaW5oZXJpdCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEhhbmRsZXIoaGFuZGxlciwgaW5oZXJpdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVGFncyh0YWdzLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlbW92ZVRhZ3ModGFncyk7IC8vIFJlbW92ZSBkdXBsaWNhdGVzXG4gICAgICAgIHRoaXMudGFncy5wdXNoKC4uLnRhZ3MpO1xuICAgICAgICBpZiAoaW5oZXJpdCkge1xuICAgICAgICAgICAgdGhpcy5pbmhlcml0YWJsZVRhZ3MucHVzaCguLi50YWdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVUYWdzKHRhZ3MpIHtcbiAgICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiAhdGFncy5pbmNsdWRlcyh0YWcpKTtcbiAgICAgICAgdGhpcy5pbmhlcml0YWJsZVRhZ3MgPSB0aGlzLmluaGVyaXRhYmxlVGFncy5maWx0ZXIoKHRhZykgPT4gIXRhZ3MuaW5jbHVkZXModGFnKSk7XG4gICAgfVxuICAgIGFkZE1ldGFkYXRhKG1ldGFkYXRhLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0geyAuLi50aGlzLm1ldGFkYXRhLCAuLi5tZXRhZGF0YSB9O1xuICAgICAgICBpZiAoaW5oZXJpdCkge1xuICAgICAgICAgICAgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhID0geyAuLi50aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIC4uLm1ldGFkYXRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobWV0YWRhdGEpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5tZXRhZGF0YVtrZXldO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvcHkoYWRkaXRpb25hbEhhbmRsZXJzID0gW10sIGluaGVyaXQgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaGVyaXRhYmxlID0gdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLmluY2x1ZGVzKGhhbmRsZXIpO1xuICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKGhhbmRsZXIsIGluaGVyaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLnRhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaGVyaXRhYmxlID0gdGhpcy5pbmhlcml0YWJsZVRhZ3MuaW5jbHVkZXModGFnKTtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkVGFncyhbdGFnXSwgaW5oZXJpdGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMubWV0YWRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBpbmhlcml0YWJsZSA9IE9iamVjdC5rZXlzKHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSkuaW5jbHVkZXMoa2V5KTtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkTWV0YWRhdGEoeyBba2V5XTogdGhpcy5tZXRhZGF0YVtrZXldIH0sIGluaGVyaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgYWRkaXRpb25hbEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBQcmV2ZW50IG11bHRpcGxlIGNvcGllcyBvZiBjb25zb2xlX2NhbGxiYWNrX2hhbmRsZXJcbiAgICAgICAgICAgIG1hbmFnZXIuaGFuZGxlcnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChoKSA9PiBoLm5hbWUgPT09IFwiY29uc29sZV9jYWxsYmFja19oYW5kbGVyXCIpXG4gICAgICAgICAgICAgICAgLnNvbWUoKGgpID0+IGgubmFtZSA9PT0gaGFuZGxlci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKGhhbmRsZXIsIGluaGVyaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhhbmRsZXJzKGhhbmRsZXJzKSB7XG4gICAgICAgIGNsYXNzIEhhbmRsZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tIYW5kbGVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1dWlkdjQoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgaGFuZGxlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgdGhpcygpO1xuICAgICAgICBtYW5hZ2VyLmFkZEhhbmRsZXIobmV3IEhhbmRsZXIoKSk7XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY29uZmlndXJlKGluaGVyaXRhYmxlSGFuZGxlcnMsIGxvY2FsSGFuZGxlcnMsIGluaGVyaXRhYmxlVGFncywgbG9jYWxUYWdzLCBpbmhlcml0YWJsZU1ldGFkYXRhLCBsb2NhbE1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWd1cmVTeW5jKGluaGVyaXRhYmxlSGFuZGxlcnMsIGxvY2FsSGFuZGxlcnMsIGluaGVyaXRhYmxlVGFncywgbG9jYWxUYWdzLCBpbmhlcml0YWJsZU1ldGFkYXRhLCBsb2NhbE1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gVE9ETzogRGVwcmVjYXRlIGFzeW5jIG1ldGhvZCBpbiBmYXZvciBvZiB0aGlzIG9uZS5cbiAgICBzdGF0aWMgX2NvbmZpZ3VyZVN5bmMoaW5oZXJpdGFibGVIYW5kbGVycywgbG9jYWxIYW5kbGVycywgaW5oZXJpdGFibGVUYWdzLCBsb2NhbFRhZ3MsIGluaGVyaXRhYmxlTWV0YWRhdGEsIGxvY2FsTWV0YWRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGNhbGxiYWNrTWFuYWdlcjtcbiAgICAgICAgaWYgKGluaGVyaXRhYmxlSGFuZGxlcnMgfHwgbG9jYWxIYW5kbGVycykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5oZXJpdGFibGVIYW5kbGVycykgfHwgIWluaGVyaXRhYmxlSGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLnNldEhhbmRsZXJzKGluaGVyaXRhYmxlSGFuZGxlcnM/Lm1hcChlbnN1cmVIYW5kbGVyKSA/PyBbXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIgPSBpbmhlcml0YWJsZUhhbmRsZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyID0gY2FsbGJhY2tNYW5hZ2VyLmNvcHkoQXJyYXkuaXNBcnJheShsb2NhbEhhbmRsZXJzKVxuICAgICAgICAgICAgICAgID8gbG9jYWxIYW5kbGVycy5tYXAoZW5zdXJlSGFuZGxlcilcbiAgICAgICAgICAgICAgICA6IGxvY2FsSGFuZGxlcnM/LmhhbmRsZXJzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyYm9zZUVuYWJsZWQgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX1ZFUkJPU0VcIikgPT09IFwidHJ1ZVwiIHx8XG4gICAgICAgICAgICBvcHRpb25zPy52ZXJib3NlO1xuICAgICAgICBjb25zdCB0cmFjaW5nVjJFbmFibGVkID0gTGFuZ0NoYWluVHJhY2VyLmdldFRyYWNlYWJsZVJ1blRyZWUoKT8udHJhY2luZ0VuYWJsZWQgfHxcbiAgICAgICAgICAgIGlzVHJhY2luZ0VuYWJsZWQoKTtcbiAgICAgICAgY29uc3QgdHJhY2luZ0VuYWJsZWQgPSB0cmFjaW5nVjJFbmFibGVkIHx8XG4gICAgICAgICAgICAoZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9UUkFDSU5HXCIpID8/IGZhbHNlKTtcbiAgICAgICAgaWYgKHZlcmJvc2VFbmFibGVkIHx8IHRyYWNpbmdFbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2ZXJib3NlRW5hYmxlZCAmJlxuICAgICAgICAgICAgICAgICFjYWxsYmFja01hbmFnZXIuaGFuZGxlcnMuc29tZSgoaGFuZGxlcikgPT4gaGFuZGxlci5uYW1lID09PSBDb25zb2xlQ2FsbGJhY2tIYW5kbGVyLnByb3RvdHlwZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnNvbGVIYW5kbGVyID0gbmV3IENvbnNvbGVDYWxsYmFja0hhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkSGFuZGxlcihjb25zb2xlSGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2luZ0VuYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAhY2FsbGJhY2tNYW5hZ2VyLmhhbmRsZXJzLnNvbWUoKGhhbmRsZXIpID0+IGhhbmRsZXIubmFtZSA9PT0gXCJsYW5nY2hhaW5fdHJhY2VyXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNpbmdWMkVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhY2VyVjIgPSBuZXcgTGFuZ0NoYWluVHJhY2VyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRIYW5kbGVyKHRyYWNlclYyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZG9mZiBiZXR3ZWVuIGxhbmdjaGFpbiBhbmQgbGFuZ3NtaXRoL3RyYWNlYWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSB0aGUgcGFyZW50IHJ1biBJRFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuX3BhcmVudFJ1bklkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIExhbmdDaGFpblRyYWNlci5nZXRUcmFjZWFibGVSdW5UcmVlKCk/LmlkID8/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLl9wYXJlbnRSdW5JZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaGVyaXRhYmxlVGFncyB8fCBsb2NhbFRhZ3MpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFja01hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkVGFncyhpbmhlcml0YWJsZVRhZ3MgPz8gW10pO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRUYWdzKGxvY2FsVGFncyA/PyBbXSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmhlcml0YWJsZU1ldGFkYXRhIHx8IGxvY2FsTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFja01hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkTWV0YWRhdGEoaW5oZXJpdGFibGVNZXRhZGF0YSA/PyB7fSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLmFkZE1ldGFkYXRhKGxvY2FsTWV0YWRhdGEgPz8ge30sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2tNYW5hZ2VyO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICBpZiAoXCJuYW1lXCIgaW4gaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICB9XG4gICAgcmV0dXJuIEJhc2VDYWxsYmFja0hhbmRsZXIuZnJvbU1ldGhvZHMoaGFuZGxlcik7XG59XG4vKipcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBwcm9tcHQgPSBQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoYFdoYXQgaXMgdGhlIGFuc3dlciB0byB7cXVlc3Rpb259P2ApO1xuICpcbiAqIC8vIEV4YW1wbGUgb2YgdXNpbmcgTExNQ2hhaW4gdG8gcHJvY2VzcyBhIHNlcmllcyBvZiBxdWVzdGlvbnNcbiAqIGNvbnN0IGNoYWluID0gbmV3IExMTUNoYWluKHtcbiAqICAgbGxtOiBuZXcgQ2hhdE9wZW5BSSh7IHRlbXBlcmF0dXJlOiAwLjkgfSksXG4gKiAgIHByb21wdCxcbiAqIH0pO1xuICpcbiAqIC8vIFByb2Nlc3MgcXVlc3Rpb25zIHVzaW5nIHRoZSBjaGFpblxuICogY29uc3QgcHJvY2Vzc1F1ZXN0aW9ucyA9IGFzeW5jIChxdWVzdGlvbnMpID0+IHtcbiAqICAgZm9yIChjb25zdCBxdWVzdGlvbiBvZiBxdWVzdGlvbnMpIHtcbiAqICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGFpbi5jYWxsKHsgcXVlc3Rpb24gfSk7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgfVxuICogfTtcbiAqXG4gKiAvLyBFeGFtcGxlIHF1ZXN0aW9uc1xuICogY29uc3QgcXVlc3Rpb25zID0gW1xuICogICBcIldoYXQgaXMgeW91ciBuYW1lP1wiLFxuICogICBcIldoYXQgaXMgeW91ciBxdWVzdD9cIixcbiAqICAgXCJXaGF0IGlzIHlvdXIgZmF2b3JpdGUgY29sb3I/XCIsXG4gKiBdO1xuICpcbiAqIC8vIFJ1biB0aGUgZXhhbXBsZVxuY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3IgPyBjb25zb2xlLmVycm9yIDogY29uc29sZS53YXJuO1xuKiBwcm9jZXNzUXVlc3Rpb25zKHF1ZXN0aW9ucykuY2F0Y2goY29uc29sZWxvZ0Z1bmN0aW9uO1xuICpcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgVHJhY2VHcm91cCB7XG4gICAgY29uc3RydWN0b3IoZ3JvdXBOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdyb3VwTmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZ3JvdXBOYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcHRpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5NYW5hZ2VyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYWNlR3JvdXBDYWxsYmFja01hbmFnZXIoZ3JvdXBfbmFtZSwgaW5wdXRzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNiID0gbmV3IExhbmdDaGFpblRyYWNlcihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY20gPSBhd2FpdCBDYWxsYmFja01hbmFnZXIuY29uZmlndXJlKFtjYl0pO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY20/LmhhbmRsZUNoYWluU3RhcnQoe1xuICAgICAgICAgICAgbGM6IDEsXG4gICAgICAgICAgICB0eXBlOiBcIm5vdF9pbXBsZW1lbnRlZFwiLFxuICAgICAgICAgICAgaWQ6IFtcImxhbmdjaGFpblwiLCBcImNhbGxiYWNrc1wiLCBcImdyb3Vwc1wiLCBncm91cF9uYW1lXSxcbiAgICAgICAgfSwgaW5wdXRzID8/IHt9KTtcbiAgICAgICAgaWYgKCFydW5NYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIHJ1biBncm91cCBjYWxsYmFjayBtYW5hZ2VyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuTWFuYWdlcjtcbiAgICB9XG4gICAgYXN5bmMgc3RhcnQoaW5wdXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5ydW5NYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bk1hbmFnZXIgPSBhd2FpdCB0aGlzLmdldFRyYWNlR3JvdXBDYWxsYmFja01hbmFnZXIodGhpcy5ncm91cE5hbWUsIGlucHV0cywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ydW5NYW5hZ2VyLmdldENoaWxkKCk7XG4gICAgfVxuICAgIGFzeW5jIGVycm9yKGVycikge1xuICAgICAgICBpZiAodGhpcy5ydW5NYW5hZ2VyKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJ1bk1hbmFnZXIuaGFuZGxlQ2hhaW5FcnJvcihlcnIpO1xuICAgICAgICAgICAgdGhpcy5ydW5NYW5hZ2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGVuZChvdXRwdXQpIHtcbiAgICAgICAgaWYgKHRoaXMucnVuTWFuYWdlcikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5NYW5hZ2VyLmhhbmRsZUNoYWluRW5kKG91dHB1dCA/PyB7fSk7XG4gICAgICAgICAgICB0aGlzLnJ1bk1hbmFnZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gX2NvZXJjZVRvRGljdCh2YWx1ZSwgZGVmYXVsdEtleSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiB7IFtkZWZhdWx0S2V5XTogdmFsdWUgfTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdHJhY2VBc0dyb3VwKGdyb3VwT3B0aW9ucywgZW5jbG9zZWRDb2RlLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgdHJhY2VHcm91cCA9IG5ldyBUcmFjZUdyb3VwKGdyb3VwT3B0aW9ucy5uYW1lLCBncm91cE9wdGlvbnMpO1xuICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlciA9IGF3YWl0IHRyYWNlR3JvdXAuc3RhcnQoeyAuLi5hcmdzIH0pO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVuY2xvc2VkQ29kZShjYWxsYmFja01hbmFnZXIsIC4uLmFyZ3MpO1xuICAgICAgICBhd2FpdCB0cmFjZUdyb3VwLmVuZChfY29lcmNlVG9EaWN0KHJlc3VsdCwgXCJvdXRwdXRcIikpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGF3YWl0IHRyYWNlR3JvdXAuZXJyb3IoZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/callbacks/manager.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/callbacks/promises.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/callbacks/promises.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   awaitAllCallbacks: () => (/* binding */ awaitAllCallbacks),\n/* harmony export */   consumeCallback: () => (/* binding */ consumeCallback)\n/* harmony export */ });\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-queue */ \"(action-browser)/./node_modules/p-queue/dist/index.js\");\n\nlet queue;\n/**\n * Creates a queue using the p-queue library. The queue is configured to\n * auto-start and has a concurrency of 1, meaning it will process tasks\n * one at a time.\n */\nfunction createQueue() {\n    const PQueue =  true ? p_queue__WEBPACK_IMPORTED_MODULE_0__[\"default\"] : p_queue__WEBPACK_IMPORTED_MODULE_0__;\n    return new PQueue({\n        autoStart: true,\n        concurrency: 1,\n    });\n}\n/**\n * Consume a promise, either adding it to the queue or waiting for it to resolve\n * @param promiseFn Promise to consume\n * @param wait Whether to wait for the promise to resolve or resolve immediately\n */\nasync function consumeCallback(promiseFn, wait) {\n    if (wait === true) {\n        await promiseFn();\n    }\n    else {\n        if (typeof queue === \"undefined\") {\n            queue = createQueue();\n        }\n        void queue.add(promiseFn);\n    }\n}\n/**\n * Waits for all promises in the queue to resolve. If the queue is\n * undefined, it immediately resolves a promise.\n */\nfunction awaitAllCallbacks() {\n    return typeof queue !== \"undefined\" ? queue.onIdle() : Promise.resolve();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2NhbGxiYWNrcy9wcm9taXNlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBc0IsR0FBRywrQ0FBaUIsR0FBRyxvQ0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcdGV4dHNwbGl0dGVyc1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxjYWxsYmFja3NcXHByb21pc2VzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQUXVldWVNb2QgZnJvbSBcInAtcXVldWVcIjtcbmxldCBxdWV1ZTtcbi8qKlxuICogQ3JlYXRlcyBhIHF1ZXVlIHVzaW5nIHRoZSBwLXF1ZXVlIGxpYnJhcnkuIFRoZSBxdWV1ZSBpcyBjb25maWd1cmVkIHRvXG4gKiBhdXRvLXN0YXJ0IGFuZCBoYXMgYSBjb25jdXJyZW5jeSBvZiAxLCBtZWFuaW5nIGl0IHdpbGwgcHJvY2VzcyB0YXNrc1xuICogb25lIGF0IGEgdGltZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUXVldWUoKSB7XG4gICAgY29uc3QgUFF1ZXVlID0gXCJkZWZhdWx0XCIgaW4gUFF1ZXVlTW9kID8gUFF1ZXVlTW9kLmRlZmF1bHQgOiBQUXVldWVNb2Q7XG4gICAgcmV0dXJuIG5ldyBQUXVldWUoe1xuICAgICAgICBhdXRvU3RhcnQ6IHRydWUsXG4gICAgICAgIGNvbmN1cnJlbmN5OiAxLFxuICAgIH0pO1xufVxuLyoqXG4gKiBDb25zdW1lIGEgcHJvbWlzZSwgZWl0aGVyIGFkZGluZyBpdCB0byB0aGUgcXVldWUgb3Igd2FpdGluZyBmb3IgaXQgdG8gcmVzb2x2ZVxuICogQHBhcmFtIHByb21pc2VGbiBQcm9taXNlIHRvIGNvbnN1bWVcbiAqIEBwYXJhbSB3YWl0IFdoZXRoZXIgdG8gd2FpdCBmb3IgdGhlIHByb21pc2UgdG8gcmVzb2x2ZSBvciByZXNvbHZlIGltbWVkaWF0ZWx5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25zdW1lQ2FsbGJhY2socHJvbWlzZUZuLCB3YWl0KSB7XG4gICAgaWYgKHdhaXQgPT09IHRydWUpIHtcbiAgICAgICAgYXdhaXQgcHJvbWlzZUZuKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBxdWV1ZSA9IGNyZWF0ZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdm9pZCBxdWV1ZS5hZGQocHJvbWlzZUZuKTtcbiAgICB9XG59XG4vKipcbiAqIFdhaXRzIGZvciBhbGwgcHJvbWlzZXMgaW4gdGhlIHF1ZXVlIHRvIHJlc29sdmUuIElmIHRoZSBxdWV1ZSBpc1xuICogdW5kZWZpbmVkLCBpdCBpbW1lZGlhdGVseSByZXNvbHZlcyBhIHByb21pc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhd2FpdEFsbENhbGxiYWNrcygpIHtcbiAgICByZXR1cm4gdHlwZW9mIHF1ZXVlICE9PSBcInVuZGVmaW5lZFwiID8gcXVldWUub25JZGxlKCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/callbacks/promises.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/documents/document.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/documents/document.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Document: () => (/* binding */ Document)\n/* harmony export */ });\n/**\n * Interface for interacting with a document.\n */\nclass Document {\n    constructor(fields) {\n        Object.defineProperty(this, \"pageContent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // The ID field is optional at the moment.\n        // It will likely become required in a future major release after\n        // it has been adopted by enough vectorstore implementations.\n        /**\n         * An optional identifier for the document.\n         *\n         * Ideally this should be unique across the document collection and formatted\n         * as a UUID, but this will not be enforced.\n         */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.pageContent =\n            fields.pageContent !== undefined ? fields.pageContent.toString() : \"\";\n        this.metadata = fields.metadata ?? {};\n        this.id = fields.id;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2RvY3VtZW50cy9kb2N1bWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXHRleHRzcGxpdHRlcnNcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcZG9jdW1lbnRzXFxkb2N1bWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEludGVyZmFjZSBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhIGRvY3VtZW50LlxuICovXG5leHBvcnQgY2xhc3MgRG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYWdlQ29udGVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGUgSUQgZmllbGQgaXMgb3B0aW9uYWwgYXQgdGhlIG1vbWVudC5cbiAgICAgICAgLy8gSXQgd2lsbCBsaWtlbHkgYmVjb21lIHJlcXVpcmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UgYWZ0ZXJcbiAgICAgICAgLy8gaXQgaGFzIGJlZW4gYWRvcHRlZCBieSBlbm91Z2ggdmVjdG9yc3RvcmUgaW1wbGVtZW50YXRpb25zLlxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb3B0aW9uYWwgaWRlbnRpZmllciBmb3IgdGhlIGRvY3VtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZGVhbGx5IHRoaXMgc2hvdWxkIGJlIHVuaXF1ZSBhY3Jvc3MgdGhlIGRvY3VtZW50IGNvbGxlY3Rpb24gYW5kIGZvcm1hdHRlZFxuICAgICAgICAgKiBhcyBhIFVVSUQsIGJ1dCB0aGlzIHdpbGwgbm90IGJlIGVuZm9yY2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYWdlQ29udGVudCA9XG4gICAgICAgICAgICBmaWVsZHMucGFnZUNvbnRlbnQgIT09IHVuZGVmaW5lZCA/IGZpZWxkcy5wYWdlQ29udGVudC50b1N0cmluZygpIDogXCJcIjtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IGZpZWxkcy5tZXRhZGF0YSA/PyB7fTtcbiAgICAgICAgdGhpcy5pZCA9IGZpZWxkcy5pZDtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/documents/document.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/documents/index.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/documents/index.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseDocumentTransformer: () => (/* reexport safe */ _transformers_js__WEBPACK_IMPORTED_MODULE_1__.BaseDocumentTransformer),\n/* harmony export */   Document: () => (/* reexport safe */ _document_js__WEBPACK_IMPORTED_MODULE_0__.Document),\n/* harmony export */   MappingDocumentTransformer: () => (/* reexport safe */ _transformers_js__WEBPACK_IMPORTED_MODULE_1__.MappingDocumentTransformer)\n/* harmony export */ });\n/* harmony import */ var _document_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./document.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/documents/document.js\");\n/* harmony import */ var _transformers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transformers.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/documents/transformers.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2RvY3VtZW50cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE4QjtBQUNJIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcdGV4dHNwbGl0dGVyc1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxkb2N1bWVudHNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL2RvY3VtZW50LmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90cmFuc2Zvcm1lcnMuanNcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/documents/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/documents/transformers.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/documents/transformers.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseDocumentTransformer: () => (/* binding */ BaseDocumentTransformer),\n/* harmony export */   MappingDocumentTransformer: () => (/* binding */ MappingDocumentTransformer)\n/* harmony export */ });\n/* harmony import */ var _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runnables/base.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/base.js\");\n\n/**\n * Abstract base class for document transformation systems.\n *\n * A document transformation system takes an array of Documents and returns an\n * array of transformed Documents. These arrays do not necessarily have to have\n * the same length.\n *\n * One example of this is a text splitter that splits a large document into\n * many smaller documents.\n */\nclass BaseDocumentTransformer extends _runnables_base_js__WEBPACK_IMPORTED_MODULE_0__.Runnable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"documents\", \"transformers\"]\n        });\n    }\n    /**\n     * Method to invoke the document transformation. This method calls the\n     * transformDocuments method with the provided input.\n     * @param input The input documents to be transformed.\n     * @param _options Optional configuration object to customize the behavior of callbacks.\n     * @returns A Promise that resolves to the transformed documents.\n     */\n    invoke(input, _options) {\n        return this.transformDocuments(input);\n    }\n}\n/**\n * Class for document transformers that return exactly one transformed document\n * for each input document.\n */\nclass MappingDocumentTransformer extends BaseDocumentTransformer {\n    async transformDocuments(documents) {\n        const newDocuments = [];\n        for (const document of documents) {\n            const transformedDocument = await this._transformDocument(document);\n            newDocuments.push(transformedDocument);\n        }\n        return newDocuments;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2RvY3VtZW50cy90cmFuc2Zvcm1lcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sc0NBQXNDLHdEQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFx0ZXh0c3BsaXR0ZXJzXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXGRvY3VtZW50c1xcdHJhbnNmb3JtZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJ1bm5hYmxlIH0gZnJvbSBcIi4uL3J1bm5hYmxlcy9iYXNlLmpzXCI7XG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGRvY3VtZW50IHRyYW5zZm9ybWF0aW9uIHN5c3RlbXMuXG4gKlxuICogQSBkb2N1bWVudCB0cmFuc2Zvcm1hdGlvbiBzeXN0ZW0gdGFrZXMgYW4gYXJyYXkgb2YgRG9jdW1lbnRzIGFuZCByZXR1cm5zIGFuXG4gKiBhcnJheSBvZiB0cmFuc2Zvcm1lZCBEb2N1bWVudHMuIFRoZXNlIGFycmF5cyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBoYXZlXG4gKiB0aGUgc2FtZSBsZW5ndGguXG4gKlxuICogT25lIGV4YW1wbGUgb2YgdGhpcyBpcyBhIHRleHQgc3BsaXR0ZXIgdGhhdCBzcGxpdHMgYSBsYXJnZSBkb2N1bWVudCBpbnRvXG4gKiBtYW55IHNtYWxsZXIgZG9jdW1lbnRzLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZURvY3VtZW50VHJhbnNmb3JtZXIgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJkb2N1bWVudHNcIiwgXCJ0cmFuc2Zvcm1lcnNcIl1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBpbnZva2UgdGhlIGRvY3VtZW50IHRyYW5zZm9ybWF0aW9uLiBUaGlzIG1ldGhvZCBjYWxscyB0aGVcbiAgICAgKiB0cmFuc2Zvcm1Eb2N1bWVudHMgbWV0aG9kIHdpdGggdGhlIHByb3ZpZGVkIGlucHV0LlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgZG9jdW1lbnRzIHRvIGJlIHRyYW5zZm9ybWVkLlxuICAgICAqIEBwYXJhbSBfb3B0aW9ucyBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdCB0byBjdXN0b21pemUgdGhlIGJlaGF2aW9yIG9mIGNhbGxiYWNrcy5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdHJhbnNmb3JtZWQgZG9jdW1lbnRzLlxuICAgICAqL1xuICAgIGludm9rZShpbnB1dCwgX29wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRG9jdW1lbnRzKGlucHV0KTtcbiAgICB9XG59XG4vKipcbiAqIENsYXNzIGZvciBkb2N1bWVudCB0cmFuc2Zvcm1lcnMgdGhhdCByZXR1cm4gZXhhY3RseSBvbmUgdHJhbnNmb3JtZWQgZG9jdW1lbnRcbiAqIGZvciBlYWNoIGlucHV0IGRvY3VtZW50LlxuICovXG5leHBvcnQgY2xhc3MgTWFwcGluZ0RvY3VtZW50VHJhbnNmb3JtZXIgZXh0ZW5kcyBCYXNlRG9jdW1lbnRUcmFuc2Zvcm1lciB7XG4gICAgYXN5bmMgdHJhbnNmb3JtRG9jdW1lbnRzKGRvY3VtZW50cykge1xuICAgICAgICBjb25zdCBuZXdEb2N1bWVudHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBkb2N1bWVudCBvZiBkb2N1bWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkRG9jdW1lbnQgPSBhd2FpdCB0aGlzLl90cmFuc2Zvcm1Eb2N1bWVudChkb2N1bWVudCk7XG4gICAgICAgICAgICBuZXdEb2N1bWVudHMucHVzaCh0cmFuc2Zvcm1lZERvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RG9jdW1lbnRzO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/documents/transformers.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/load/map_keys.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/load/map_keys.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keyFromJson: () => (/* binding */ keyFromJson),\n/* harmony export */   keyToJson: () => (/* binding */ keyToJson),\n/* harmony export */   mapKeys: () => (/* binding */ mapKeys)\n/* harmony export */ });\n/* harmony import */ var decamelize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! decamelize */ \"(action-browser)/./node_modules/decamelize/index.js\");\n/* harmony import */ var camelcase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! camelcase */ \"(action-browser)/./node_modules/camelcase/index.js\");\n\n\nfunction keyToJson(key, map) {\n    return map?.[key] || decamelize__WEBPACK_IMPORTED_MODULE_0__(key);\n}\nfunction keyFromJson(key, map) {\n    return map?.[key] || camelcase__WEBPACK_IMPORTED_MODULE_1__(key);\n}\nfunction mapKeys(fields, mapper, map) {\n    const mapped = {};\n    for (const key in fields) {\n        if (Object.hasOwn(fields, key)) {\n            mapped[mapper(key, map)] = fields[key];\n        }\n    }\n    return mapped;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2xvYWQvbWFwX2tleXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUM7QUFDRDtBQUMzQjtBQUNQLHlCQUF5Qix1Q0FBUztBQUNsQztBQUNPO0FBQ1AseUJBQXlCLHNDQUFTO0FBQ2xDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcdGV4dHNwbGl0dGVyc1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxsb2FkXFxtYXBfa2V5cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc25ha2VDYXNlIGZyb20gXCJkZWNhbWVsaXplXCI7XG5pbXBvcnQgY2FtZWxDYXNlIGZyb20gXCJjYW1lbGNhc2VcIjtcbmV4cG9ydCBmdW5jdGlvbiBrZXlUb0pzb24oa2V5LCBtYXApIHtcbiAgICByZXR1cm4gbWFwPy5ba2V5XSB8fCBzbmFrZUNhc2Uoa2V5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBrZXlGcm9tSnNvbihrZXksIG1hcCkge1xuICAgIHJldHVybiBtYXA/LltrZXldIHx8IGNhbWVsQ2FzZShrZXkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1hcEtleXMoZmllbGRzLCBtYXBwZXIsIG1hcCkge1xuICAgIGNvbnN0IG1hcHBlZCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGZpZWxkcykge1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihmaWVsZHMsIGtleSkpIHtcbiAgICAgICAgICAgIG1hcHBlZFttYXBwZXIoa2V5LCBtYXApXSA9IGZpZWxkc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXBwZWQ7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/load/map_keys.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/load/serializable.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/load/serializable.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Serializable: () => (/* binding */ Serializable),\n/* harmony export */   get_lc_unique_name: () => (/* binding */ get_lc_unique_name)\n/* harmony export */ });\n/* harmony import */ var _map_keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map_keys.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/load/map_keys.js\");\n\nfunction shallowCopy(obj) {\n    return Array.isArray(obj) ? [...obj] : { ...obj };\n}\nfunction replaceSecrets(root, secretsMap) {\n    const result = shallowCopy(root);\n    for (const [path, secretId] of Object.entries(secretsMap)) {\n        const [last, ...partsReverse] = path.split(\".\").reverse();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let current = result;\n        for (const part of partsReverse.reverse()) {\n            if (current[part] === undefined) {\n                break;\n            }\n            current[part] = shallowCopy(current[part]);\n            current = current[part];\n        }\n        if (current[last] !== undefined) {\n            current[last] = {\n                lc: 1,\n                type: \"secret\",\n                id: [secretId],\n            };\n        }\n    }\n    return result;\n}\n/**\n * Get a unique name for the module, rather than parent class implementations.\n * Should not be subclassed, subclass lc_name above instead.\n */\nfunction get_lc_unique_name(\n// eslint-disable-next-line @typescript-eslint/no-use-before-define\nserializableClass) {\n    // \"super\" here would refer to the parent class of Serializable,\n    // when we want the parent class of the module actually calling this method.\n    const parentClass = Object.getPrototypeOf(serializableClass);\n    const lcNameIsSubclassed = typeof serializableClass.lc_name === \"function\" &&\n        (typeof parentClass.lc_name !== \"function\" ||\n            serializableClass.lc_name() !== parentClass.lc_name());\n    if (lcNameIsSubclassed) {\n        return serializableClass.lc_name();\n    }\n    else {\n        return serializableClass.name;\n    }\n}\nclass Serializable {\n    /**\n     * The name of the serializable. Override to provide an alias or\n     * to preserve the serialized module name in minified environments.\n     *\n     * Implemented as a static method to support loading logic.\n     */\n    static lc_name() {\n        return this.name;\n    }\n    /**\n     * The final serialized identifier for the module.\n     */\n    get lc_id() {\n        return [\n            ...this.lc_namespace,\n            get_lc_unique_name(this.constructor),\n        ];\n    }\n    /**\n     * A map of secrets, which will be omitted from serialization.\n     * Keys are paths to the secret in constructor args, e.g. \"foo.bar.baz\".\n     * Values are the secret ids, which will be used when deserializing.\n     */\n    get lc_secrets() {\n        return undefined;\n    }\n    /**\n     * A map of additional attributes to merge with constructor args.\n     * Keys are the attribute names, e.g. \"foo\".\n     * Values are the attribute values, which will be serialized.\n     * These attributes need to be accepted by the constructor as arguments.\n     */\n    get lc_attributes() {\n        return undefined;\n    }\n    /**\n     * A map of aliases for constructor args.\n     * Keys are the attribute names, e.g. \"foo\".\n     * Values are the alias that will replace the key in serialization.\n     * This is used to eg. make argument names match Python.\n     */\n    get lc_aliases() {\n        return undefined;\n    }\n    constructor(kwargs, ..._args) {\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.lc_kwargs = kwargs || {};\n    }\n    toJSON() {\n        if (!this.lc_serializable) {\n            return this.toJSONNotImplemented();\n        }\n        if (\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        this.lc_kwargs instanceof Serializable ||\n            typeof this.lc_kwargs !== \"object\" ||\n            Array.isArray(this.lc_kwargs)) {\n            // We do not support serialization of classes with arg not a POJO\n            // I'm aware the check above isn't as strict as it could be\n            return this.toJSONNotImplemented();\n        }\n        const aliases = {};\n        const secrets = {};\n        const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {\n            acc[key] = key in this ? this[key] : this.lc_kwargs[key];\n            return acc;\n        }, {});\n        // get secrets, attributes and aliases from all superclasses\n        for (\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)) {\n            Object.assign(aliases, Reflect.get(current, \"lc_aliases\", this));\n            Object.assign(secrets, Reflect.get(current, \"lc_secrets\", this));\n            Object.assign(kwargs, Reflect.get(current, \"lc_attributes\", this));\n        }\n        // include all secrets used, even if not in kwargs,\n        // will be replaced with sentinel value in replaceSecrets\n        Object.keys(secrets).forEach((keyPath) => {\n            // eslint-disable-next-line @typescript-eslint/no-this-alias, @typescript-eslint/no-explicit-any\n            let read = this;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            let write = kwargs;\n            const [last, ...partsReverse] = keyPath.split(\".\").reverse();\n            for (const key of partsReverse.reverse()) {\n                if (!(key in read) || read[key] === undefined)\n                    return;\n                if (!(key in write) || write[key] === undefined) {\n                    if (typeof read[key] === \"object\" && read[key] != null) {\n                        write[key] = {};\n                    }\n                    else if (Array.isArray(read[key])) {\n                        write[key] = [];\n                    }\n                }\n                read = read[key];\n                write = write[key];\n            }\n            if (last in read && read[last] !== undefined) {\n                write[last] = write[last] || read[last];\n            }\n        });\n        return {\n            lc: 1,\n            type: \"constructor\",\n            id: this.lc_id,\n            kwargs: (0,_map_keys_js__WEBPACK_IMPORTED_MODULE_0__.mapKeys)(Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs, _map_keys_js__WEBPACK_IMPORTED_MODULE_0__.keyToJson, aliases),\n        };\n    }\n    toJSONNotImplemented() {\n        return {\n            lc: 1,\n            type: \"not_implemented\",\n            id: this.lc_id,\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2xvYWQvc2VyaWFsaXphYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFtRDtBQUNuRDtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQU8seUVBQXlFLG1EQUFTO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcdGV4dHNwbGl0dGVyc1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxsb2FkXFxzZXJpYWxpemFibGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2V5VG9Kc29uLCBtYXBLZXlzIH0gZnJvbSBcIi4vbWFwX2tleXMuanNcIjtcbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgPyBbLi4ub2JqXSA6IHsgLi4ub2JqIH07XG59XG5mdW5jdGlvbiByZXBsYWNlU2VjcmV0cyhyb290LCBzZWNyZXRzTWFwKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc2hhbGxvd0NvcHkocm9vdCk7XG4gICAgZm9yIChjb25zdCBbcGF0aCwgc2VjcmV0SWRdIG9mIE9iamVjdC5lbnRyaWVzKHNlY3JldHNNYXApKSB7XG4gICAgICAgIGNvbnN0IFtsYXN0LCAuLi5wYXJ0c1JldmVyc2VdID0gcGF0aC5zcGxpdChcIi5cIikucmV2ZXJzZSgpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgY3VycmVudCA9IHJlc3VsdDtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzUmV2ZXJzZS5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50W3BhcnRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRbcGFydF0gPSBzaGFsbG93Q29weShjdXJyZW50W3BhcnRdKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhcnRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50W2xhc3RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRbbGFzdF0gPSB7XG4gICAgICAgICAgICAgICAgbGM6IDEsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZWNyZXRcIixcbiAgICAgICAgICAgICAgICBpZDogW3NlY3JldElkXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogR2V0IGEgdW5pcXVlIG5hbWUgZm9yIHRoZSBtb2R1bGUsIHJhdGhlciB0aGFuIHBhcmVudCBjbGFzcyBpbXBsZW1lbnRhdGlvbnMuXG4gKiBTaG91bGQgbm90IGJlIHN1YmNsYXNzZWQsIHN1YmNsYXNzIGxjX25hbWUgYWJvdmUgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9sY191bmlxdWVfbmFtZShcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbnNlcmlhbGl6YWJsZUNsYXNzKSB7XG4gICAgLy8gXCJzdXBlclwiIGhlcmUgd291bGQgcmVmZXIgdG8gdGhlIHBhcmVudCBjbGFzcyBvZiBTZXJpYWxpemFibGUsXG4gICAgLy8gd2hlbiB3ZSB3YW50IHRoZSBwYXJlbnQgY2xhc3Mgb2YgdGhlIG1vZHVsZSBhY3R1YWxseSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICAgIGNvbnN0IHBhcmVudENsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHNlcmlhbGl6YWJsZUNsYXNzKTtcbiAgICBjb25zdCBsY05hbWVJc1N1YmNsYXNzZWQgPSB0eXBlb2Ygc2VyaWFsaXphYmxlQ2xhc3MubGNfbmFtZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICh0eXBlb2YgcGFyZW50Q2xhc3MubGNfbmFtZSAhPT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICAgICBzZXJpYWxpemFibGVDbGFzcy5sY19uYW1lKCkgIT09IHBhcmVudENsYXNzLmxjX25hbWUoKSk7XG4gICAgaWYgKGxjTmFtZUlzU3ViY2xhc3NlZCkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXphYmxlQ2xhc3MubGNfbmFtZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6YWJsZUNsYXNzLm5hbWU7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNlcmlhbGl6YWJsZSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6YWJsZS4gT3ZlcnJpZGUgdG8gcHJvdmlkZSBhbiBhbGlhcyBvclxuICAgICAqIHRvIHByZXNlcnZlIHRoZSBzZXJpYWxpemVkIG1vZHVsZSBuYW1lIGluIG1pbmlmaWVkIGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIEltcGxlbWVudGVkIGFzIGEgc3RhdGljIG1ldGhvZCB0byBzdXBwb3J0IGxvYWRpbmcgbG9naWMuXG4gICAgICovXG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaW5hbCBzZXJpYWxpemVkIGlkZW50aWZpZXIgZm9yIHRoZSBtb2R1bGUuXG4gICAgICovXG4gICAgZ2V0IGxjX2lkKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4udGhpcy5sY19uYW1lc3BhY2UsXG4gICAgICAgICAgICBnZXRfbGNfdW5pcXVlX25hbWUodGhpcy5jb25zdHJ1Y3RvciksXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIHNlY3JldHMsIHdoaWNoIHdpbGwgYmUgb21pdHRlZCBmcm9tIHNlcmlhbGl6YXRpb24uXG4gICAgICogS2V5cyBhcmUgcGF0aHMgdG8gdGhlIHNlY3JldCBpbiBjb25zdHJ1Y3RvciBhcmdzLCBlLmcuIFwiZm9vLmJhci5iYXpcIi5cbiAgICAgKiBWYWx1ZXMgYXJlIHRoZSBzZWNyZXQgaWRzLCB3aGljaCB3aWxsIGJlIHVzZWQgd2hlbiBkZXNlcmlhbGl6aW5nLlxuICAgICAqL1xuICAgIGdldCBsY19zZWNyZXRzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIG1hcCBvZiBhZGRpdGlvbmFsIGF0dHJpYnV0ZXMgdG8gbWVyZ2Ugd2l0aCBjb25zdHJ1Y3RvciBhcmdzLlxuICAgICAqIEtleXMgYXJlIHRoZSBhdHRyaWJ1dGUgbmFtZXMsIGUuZy4gXCJmb29cIi5cbiAgICAgKiBWYWx1ZXMgYXJlIHRoZSBhdHRyaWJ1dGUgdmFsdWVzLCB3aGljaCB3aWxsIGJlIHNlcmlhbGl6ZWQuXG4gICAgICogVGhlc2UgYXR0cmlidXRlcyBuZWVkIHRvIGJlIGFjY2VwdGVkIGJ5IHRoZSBjb25zdHJ1Y3RvciBhcyBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZ2V0IGxjX2F0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIGFsaWFzZXMgZm9yIGNvbnN0cnVjdG9yIGFyZ3MuXG4gICAgICogS2V5cyBhcmUgdGhlIGF0dHJpYnV0ZSBuYW1lcywgZS5nLiBcImZvb1wiLlxuICAgICAqIFZhbHVlcyBhcmUgdGhlIGFsaWFzIHRoYXQgd2lsbCByZXBsYWNlIHRoZSBrZXkgaW4gc2VyaWFsaXphdGlvbi5cbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gZWcuIG1ha2UgYXJndW1lbnQgbmFtZXMgbWF0Y2ggUHl0aG9uLlxuICAgICAqL1xuICAgIGdldCBsY19hbGlhc2VzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihrd2FyZ3MsIC4uLl9hcmdzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX2t3YXJnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxjX2t3YXJncyA9IGt3YXJncyB8fCB7fTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIXRoaXMubGNfc2VyaWFsaXphYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0pTT05Ob3RJbXBsZW1lbnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICB0aGlzLmxjX2t3YXJncyBpbnN0YW5jZW9mIFNlcmlhbGl6YWJsZSB8fFxuICAgICAgICAgICAgdHlwZW9mIHRoaXMubGNfa3dhcmdzICE9PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMubGNfa3dhcmdzKSkge1xuICAgICAgICAgICAgLy8gV2UgZG8gbm90IHN1cHBvcnQgc2VyaWFsaXphdGlvbiBvZiBjbGFzc2VzIHdpdGggYXJnIG5vdCBhIFBPSk9cbiAgICAgICAgICAgIC8vIEknbSBhd2FyZSB0aGUgY2hlY2sgYWJvdmUgaXNuJ3QgYXMgc3RyaWN0IGFzIGl0IGNvdWxkIGJlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0pTT05Ob3RJbXBsZW1lbnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsaWFzZXMgPSB7fTtcbiAgICAgICAgY29uc3Qgc2VjcmV0cyA9IHt9O1xuICAgICAgICBjb25zdCBrd2FyZ3MgPSBPYmplY3Qua2V5cyh0aGlzLmxjX2t3YXJncykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICAgICAgYWNjW2tleV0gPSBrZXkgaW4gdGhpcyA/IHRoaXNba2V5XSA6IHRoaXMubGNfa3dhcmdzW2tleV07XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIC8vIGdldCBzZWNyZXRzLCBhdHRyaWJ1dGVzIGFuZCBhbGlhc2VzIGZyb20gYWxsIHN1cGVyY2xhc3Nlc1xuICAgICAgICBmb3IgKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7IGN1cnJlbnQ7IGN1cnJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VycmVudCkpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYWxpYXNlcywgUmVmbGVjdC5nZXQoY3VycmVudCwgXCJsY19hbGlhc2VzXCIsIHRoaXMpKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VjcmV0cywgUmVmbGVjdC5nZXQoY3VycmVudCwgXCJsY19zZWNyZXRzXCIsIHRoaXMpKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oa3dhcmdzLCBSZWZsZWN0LmdldChjdXJyZW50LCBcImxjX2F0dHJpYnV0ZXNcIiwgdGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluY2x1ZGUgYWxsIHNlY3JldHMgdXNlZCwgZXZlbiBpZiBub3QgaW4ga3dhcmdzLFxuICAgICAgICAvLyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggc2VudGluZWwgdmFsdWUgaW4gcmVwbGFjZVNlY3JldHNcbiAgICAgICAgT2JqZWN0LmtleXMoc2VjcmV0cykuZm9yRWFjaCgoa2V5UGF0aCkgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBsZXQgcmVhZCA9IHRoaXM7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgbGV0IHdyaXRlID0ga3dhcmdzO1xuICAgICAgICAgICAgY29uc3QgW2xhc3QsIC4uLnBhcnRzUmV2ZXJzZV0gPSBrZXlQYXRoLnNwbGl0KFwiLlwiKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBwYXJ0c1JldmVyc2UucmV2ZXJzZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIHJlYWQpIHx8IHJlYWRba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIHdyaXRlKSB8fCB3cml0ZVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWFkW2tleV0gPT09IFwib2JqZWN0XCIgJiYgcmVhZFtrZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlW2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlYWRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlW2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWFkID0gcmVhZFtrZXldO1xuICAgICAgICAgICAgICAgIHdyaXRlID0gd3JpdGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0IGluIHJlYWQgJiYgcmVhZFtsYXN0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVbbGFzdF0gPSB3cml0ZVtsYXN0XSB8fCByZWFkW2xhc3RdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxjOiAxLFxuICAgICAgICAgICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgaWQ6IHRoaXMubGNfaWQsXG4gICAgICAgICAgICBrd2FyZ3M6IG1hcEtleXMoT2JqZWN0LmtleXMoc2VjcmV0cykubGVuZ3RoID8gcmVwbGFjZVNlY3JldHMoa3dhcmdzLCBzZWNyZXRzKSA6IGt3YXJncywga2V5VG9Kc29uLCBhbGlhc2VzKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9KU09OTm90SW1wbGVtZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYzogMSxcbiAgICAgICAgICAgIHR5cGU6IFwibm90X2ltcGxlbWVudGVkXCIsXG4gICAgICAgICAgICBpZDogdGhpcy5sY19pZCxcbiAgICAgICAgfTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/load/serializable.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/ai.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/ai.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIMessage: () => (/* binding */ AIMessage),\n/* harmony export */   AIMessageChunk: () => (/* binding */ AIMessageChunk),\n/* harmony export */   isAIMessage: () => (/* binding */ isAIMessage),\n/* harmony export */   isAIMessageChunk: () => (/* binding */ isAIMessageChunk)\n/* harmony export */ });\n/* harmony import */ var _utils_json_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/json.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/json.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/base.js\");\n/* harmony import */ var _tool_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tool.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/tool.js\");\n\n\n\n/**\n * Represents an AI message in a conversation.\n */\nclass AIMessage extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseMessage {\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            ...super.lc_aliases,\n            tool_calls: \"tool_calls\",\n            invalid_tool_calls: \"invalid_tool_calls\",\n        };\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        let initParams;\n        if (typeof fields === \"string\") {\n            initParams = {\n                content: fields,\n                tool_calls: [],\n                invalid_tool_calls: [],\n                additional_kwargs: kwargs ?? {},\n            };\n        }\n        else {\n            initParams = fields;\n            const rawToolCalls = initParams.additional_kwargs?.tool_calls;\n            const toolCalls = initParams.tool_calls;\n            if (!(rawToolCalls == null) &&\n                rawToolCalls.length > 0 &&\n                (toolCalls === undefined || toolCalls.length === 0)) {\n                console.warn([\n                    \"New LangChain packages are available that more efficiently handle\",\n                    \"tool calling.\\n\\nPlease upgrade your packages to versions that set\",\n                    \"message tool calls. e.g., `yarn add @langchain/anthropic`,\",\n                    \"yarn add @langchain/openai`, etc.\",\n                ].join(\" \"));\n            }\n            try {\n                if (!(rawToolCalls == null) && toolCalls === undefined) {\n                    const [toolCalls, invalidToolCalls] = (0,_tool_js__WEBPACK_IMPORTED_MODULE_2__.defaultToolCallParser)(rawToolCalls);\n                    initParams.tool_calls = toolCalls ?? [];\n                    initParams.invalid_tool_calls = invalidToolCalls ?? [];\n                }\n                else {\n                    initParams.tool_calls = initParams.tool_calls ?? [];\n                    initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];\n                }\n            }\n            catch (e) {\n                // Do nothing if parsing fails\n                initParams.tool_calls = [];\n                initParams.invalid_tool_calls = [];\n            }\n        }\n        // Sadly, TypeScript only allows super() calls at root if the class has\n        // properties with initializers, so we have to check types twice.\n        super(initParams);\n        // These are typed as optional to avoid breaking changes and allow for casting\n        // from BaseMessage.\n        Object.defineProperty(this, \"tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"invalid_tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        /**\n         * If provided, token usage information associated with the message.\n         */\n        Object.defineProperty(this, \"usage_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (typeof initParams !== \"string\") {\n            this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n            this.invalid_tool_calls =\n                initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n        }\n        this.usage_metadata = initParams.usage_metadata;\n    }\n    static lc_name() {\n        return \"AIMessage\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_calls: this.tool_calls,\n            invalid_tool_calls: this.invalid_tool_calls,\n            usage_metadata: this.usage_metadata,\n        };\n    }\n}\nfunction isAIMessage(x) {\n    return x._getType() === \"ai\";\n}\nfunction isAIMessageChunk(x) {\n    return x._getType() === \"ai\";\n}\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nclass AIMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseMessageChunk {\n    constructor(fields) {\n        let initParams;\n        if (typeof fields === \"string\") {\n            initParams = {\n                content: fields,\n                tool_calls: [],\n                invalid_tool_calls: [],\n                tool_call_chunks: [],\n            };\n        }\n        else if (fields.tool_call_chunks === undefined) {\n            initParams = {\n                ...fields,\n                tool_calls: fields.tool_calls ?? [],\n                invalid_tool_calls: [],\n                tool_call_chunks: [],\n            };\n        }\n        else {\n            const toolCalls = [];\n            const invalidToolCalls = [];\n            for (const toolCallChunk of fields.tool_call_chunks) {\n                let parsedArgs = {};\n                try {\n                    parsedArgs = (0,_utils_json_js__WEBPACK_IMPORTED_MODULE_0__.parsePartialJson)(toolCallChunk.args || \"{}\");\n                    if (parsedArgs === null ||\n                        typeof parsedArgs !== \"object\" ||\n                        Array.isArray(parsedArgs)) {\n                        throw new Error(\"Malformed tool call chunk args.\");\n                    }\n                    toolCalls.push({\n                        name: toolCallChunk.name ?? \"\",\n                        args: parsedArgs,\n                        id: toolCallChunk.id,\n                        type: \"tool_call\",\n                    });\n                }\n                catch (e) {\n                    invalidToolCalls.push({\n                        name: toolCallChunk.name,\n                        args: toolCallChunk.args,\n                        id: toolCallChunk.id,\n                        error: \"Malformed args.\",\n                        type: \"invalid_tool_call\",\n                    });\n                }\n            }\n            initParams = {\n                ...fields,\n                tool_calls: toolCalls,\n                invalid_tool_calls: invalidToolCalls,\n            };\n        }\n        // Sadly, TypeScript only allows super() calls at root if the class has\n        // properties with initializers, so we have to check types twice.\n        super(initParams);\n        // Must redeclare tool call fields since there is no multiple inheritance in JS.\n        // These are typed as optional to avoid breaking changes and allow for casting\n        // from BaseMessage.\n        Object.defineProperty(this, \"tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"invalid_tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"tool_call_chunks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        /**\n         * If provided, token usage information associated with the message.\n         */\n        Object.defineProperty(this, \"usage_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_chunks =\n            initParams.tool_call_chunks ?? this.tool_call_chunks;\n        this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n        this.invalid_tool_calls =\n            initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n        this.usage_metadata = initParams.usage_metadata;\n    }\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            ...super.lc_aliases,\n            tool_calls: \"tool_calls\",\n            invalid_tool_calls: \"invalid_tool_calls\",\n            tool_call_chunks: \"tool_call_chunks\",\n        };\n    }\n    static lc_name() {\n        return \"AIMessageChunk\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_calls: this.tool_calls,\n            tool_call_chunks: this.tool_call_chunks,\n            invalid_tool_calls: this.invalid_tool_calls,\n            usage_metadata: this.usage_metadata,\n        };\n    }\n    concat(chunk) {\n        const combinedFields = {\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_1__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_1__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_1__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            tool_call_chunks: [],\n            id: this.id ?? chunk.id,\n        };\n        if (this.tool_call_chunks !== undefined ||\n            chunk.tool_call_chunks !== undefined) {\n            const rawToolCalls = (0,_base_js__WEBPACK_IMPORTED_MODULE_1__._mergeLists)(this.tool_call_chunks, chunk.tool_call_chunks);\n            if (rawToolCalls !== undefined && rawToolCalls.length > 0) {\n                combinedFields.tool_call_chunks = rawToolCalls;\n            }\n        }\n        if (this.usage_metadata !== undefined ||\n            chunk.usage_metadata !== undefined) {\n            const left = this.usage_metadata ?? {\n                input_tokens: 0,\n                output_tokens: 0,\n                total_tokens: 0,\n            };\n            const right = chunk.usage_metadata ?? {\n                input_tokens: 0,\n                output_tokens: 0,\n                total_tokens: 0,\n            };\n            const usage_metadata = {\n                input_tokens: left.input_tokens + right.input_tokens,\n                output_tokens: left.output_tokens + right.output_tokens,\n                total_tokens: left.total_tokens + right.total_tokens,\n            };\n            combinedFields.usage_metadata = usage_metadata;\n        }\n        return new AIMessageChunk(combinedFields);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL2FpLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBb0Q7QUFDK0M7QUFDaEQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ08sd0JBQXdCLGlEQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELCtEQUFxQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2QkFBNkIsc0RBQWdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnRUFBZ0IsMEJBQTBCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNEQUFZO0FBQ2pDLCtCQUErQixxREFBVztBQUMxQywrQkFBK0IscURBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcdGV4dHNwbGl0dGVyc1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxtZXNzYWdlc1xcYWkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VQYXJ0aWFsSnNvbiB9IGZyb20gXCIuLi91dGlscy9qc29uLmpzXCI7XG5pbXBvcnQgeyBCYXNlTWVzc2FnZSwgQmFzZU1lc3NhZ2VDaHVuaywgbWVyZ2VDb250ZW50LCBfbWVyZ2VEaWN0cywgX21lcmdlTGlzdHMsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgZGVmYXVsdFRvb2xDYWxsUGFyc2VyLCB9IGZyb20gXCIuL3Rvb2wuanNcIjtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBBSSBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgQUlNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIGdldCBsY19hbGlhc2VzKCkge1xuICAgICAgICAvLyBleGNsdWRlIHNuYWtlIGNhc2UgY29udmVyc2lvbiB0byBwYXNjYWwgY2FzZVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIubGNfYWxpYXNlcyxcbiAgICAgICAgICAgIHRvb2xfY2FsbHM6IFwidG9vbF9jYWxsc1wiLFxuICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiBcImludmFsaWRfdG9vbF9jYWxsc1wiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIGt3YXJncykge1xuICAgICAgICBsZXQgaW5pdFBhcmFtcztcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGluaXRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY29udGVudDogZmllbGRzLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IFtdLFxuICAgICAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogW10sXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IGt3YXJncyA/PyB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbml0UGFyYW1zID0gZmllbGRzO1xuICAgICAgICAgICAgY29uc3QgcmF3VG9vbENhbGxzID0gaW5pdFBhcmFtcy5hZGRpdGlvbmFsX2t3YXJncz8udG9vbF9jYWxscztcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IGluaXRQYXJhbXMudG9vbF9jYWxscztcbiAgICAgICAgICAgIGlmICghKHJhd1Rvb2xDYWxscyA9PSBudWxsKSAmJlxuICAgICAgICAgICAgICAgIHJhd1Rvb2xDYWxscy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgKHRvb2xDYWxscyA9PT0gdW5kZWZpbmVkIHx8IHRvb2xDYWxscy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFtcbiAgICAgICAgICAgICAgICAgICAgXCJOZXcgTGFuZ0NoYWluIHBhY2thZ2VzIGFyZSBhdmFpbGFibGUgdGhhdCBtb3JlIGVmZmljaWVudGx5IGhhbmRsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInRvb2wgY2FsbGluZy5cXG5cXG5QbGVhc2UgdXBncmFkZSB5b3VyIHBhY2thZ2VzIHRvIHZlcnNpb25zIHRoYXQgc2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWVzc2FnZSB0b29sIGNhbGxzLiBlLmcuLCBgeWFybiBhZGQgQGxhbmdjaGFpbi9hbnRocm9waWNgLFwiLFxuICAgICAgICAgICAgICAgICAgICBcInlhcm4gYWRkIEBsYW5nY2hhaW4vb3BlbmFpYCwgZXRjLlwiLFxuICAgICAgICAgICAgICAgIF0uam9pbihcIiBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIShyYXdUb29sQ2FsbHMgPT0gbnVsbCkgJiYgdG9vbENhbGxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3Rvb2xDYWxscywgaW52YWxpZFRvb2xDYWxsc10gPSBkZWZhdWx0VG9vbENhbGxQYXJzZXIocmF3VG9vbENhbGxzKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFBhcmFtcy50b29sX2NhbGxzID0gdG9vbENhbGxzID8/IFtdO1xuICAgICAgICAgICAgICAgICAgICBpbml0UGFyYW1zLmludmFsaWRfdG9vbF9jYWxscyA9IGludmFsaWRUb29sQ2FsbHMgPz8gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbml0UGFyYW1zLnRvb2xfY2FsbHMgPSBpbml0UGFyYW1zLnRvb2xfY2FsbHMgPz8gW107XG4gICAgICAgICAgICAgICAgICAgIGluaXRQYXJhbXMuaW52YWxpZF90b29sX2NhbGxzID0gaW5pdFBhcmFtcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPz8gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHBhcnNpbmcgZmFpbHNcbiAgICAgICAgICAgICAgICBpbml0UGFyYW1zLnRvb2xfY2FsbHMgPSBbXTtcbiAgICAgICAgICAgICAgICBpbml0UGFyYW1zLmludmFsaWRfdG9vbF9jYWxscyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNhZGx5LCBUeXBlU2NyaXB0IG9ubHkgYWxsb3dzIHN1cGVyKCkgY2FsbHMgYXQgcm9vdCBpZiB0aGUgY2xhc3MgaGFzXG4gICAgICAgIC8vIHByb3BlcnRpZXMgd2l0aCBpbml0aWFsaXplcnMsIHNvIHdlIGhhdmUgdG8gY2hlY2sgdHlwZXMgdHdpY2UuXG4gICAgICAgIHN1cGVyKGluaXRQYXJhbXMpO1xuICAgICAgICAvLyBUaGVzZSBhcmUgdHlwZWQgYXMgb3B0aW9uYWwgdG8gYXZvaWQgYnJlYWtpbmcgY2hhbmdlcyBhbmQgYWxsb3cgZm9yIGNhc3RpbmdcbiAgICAgICAgLy8gZnJvbSBCYXNlTWVzc2FnZS5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9vbF9jYWxsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImludmFsaWRfdG9vbF9jYWxsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBwcm92aWRlZCwgdG9rZW4gdXNhZ2UgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXNhZ2VfbWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0UGFyYW1zICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLnRvb2xfY2FsbHMgPSBpbml0UGFyYW1zLnRvb2xfY2FsbHMgPz8gdGhpcy50b29sX2NhbGxzO1xuICAgICAgICAgICAgdGhpcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPVxuICAgICAgICAgICAgICAgIGluaXRQYXJhbXMuaW52YWxpZF90b29sX2NhbGxzID8/IHRoaXMuaW52YWxpZF90b29sX2NhbGxzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNhZ2VfbWV0YWRhdGEgPSBpbml0UGFyYW1zLnVzYWdlX21ldGFkYXRhO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQUlNZXNzYWdlXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJhaVwiO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICB0b29sX2NhbGxzOiB0aGlzLnRvb2xfY2FsbHMsXG4gICAgICAgICAgICBpbnZhbGlkX3Rvb2xfY2FsbHM6IHRoaXMuaW52YWxpZF90b29sX2NhbGxzLFxuICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IHRoaXMudXNhZ2VfbWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQUlNZXNzYWdlKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcImFpXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBSU1lc3NhZ2VDaHVuayh4KSB7XG4gICAgcmV0dXJuIHguX2dldFR5cGUoKSA9PT0gXCJhaVwiO1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYW4gQUkgbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoXG4gKiBvdGhlciBBSSBtZXNzYWdlIGNodW5rcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFJTWVzc2FnZUNodW5rIGV4dGVuZHMgQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGxldCBpbml0UGFyYW1zO1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaW5pdFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBmaWVsZHMsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsczogW10sXG4gICAgICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiBbXSxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGRzLnRvb2xfY2FsbF9jaHVua3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5pdFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsczogZmllbGRzLnRvb2xfY2FsbHMgPz8gW10sXG4gICAgICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiBbXSxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGludmFsaWRUb29sQ2FsbHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGxDaHVuayBvZiBmaWVsZHMudG9vbF9jYWxsX2NodW5rcykge1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWRBcmdzID0ge307XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXJncyA9IHBhcnNlUGFydGlhbEpzb24odG9vbENhbGxDaHVuay5hcmdzIHx8IFwie31cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWRBcmdzID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcGFyc2VkQXJncyAhPT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShwYXJzZWRBcmdzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHRvb2wgY2FsbCBjaHVuayBhcmdzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sQ2FsbENodW5rLm5hbWUgPz8gXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHBhcnNlZEFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGxDaHVuay5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkVG9vbENhbGxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbENhbGxDaHVuay5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogdG9vbENhbGxDaHVuay5hcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsQ2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogXCJNYWxmb3JtZWQgYXJncy5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZF90b29sX2NhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5pdFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsczogdG9vbENhbGxzLFxuICAgICAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogaW52YWxpZFRvb2xDYWxscyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2FkbHksIFR5cGVTY3JpcHQgb25seSBhbGxvd3Mgc3VwZXIoKSBjYWxscyBhdCByb290IGlmIHRoZSBjbGFzcyBoYXNcbiAgICAgICAgLy8gcHJvcGVydGllcyB3aXRoIGluaXRpYWxpemVycywgc28gd2UgaGF2ZSB0byBjaGVjayB0eXBlcyB0d2ljZS5cbiAgICAgICAgc3VwZXIoaW5pdFBhcmFtcyk7XG4gICAgICAgIC8vIE11c3QgcmVkZWNsYXJlIHRvb2wgY2FsbCBmaWVsZHMgc2luY2UgdGhlcmUgaXMgbm8gbXVsdGlwbGUgaW5oZXJpdGFuY2UgaW4gSlMuXG4gICAgICAgIC8vIFRoZXNlIGFyZSB0eXBlZCBhcyBvcHRpb25hbCB0byBhdm9pZCBicmVha2luZyBjaGFuZ2VzIGFuZCBhbGxvdyBmb3IgY2FzdGluZ1xuICAgICAgICAvLyBmcm9tIEJhc2VNZXNzYWdlLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b29sX2NhbGxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW52YWxpZF90b29sX2NhbGxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9vbF9jYWxsX2NodW5rc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBwcm92aWRlZCwgdG9rZW4gdXNhZ2UgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXNhZ2VfbWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b29sX2NhbGxfY2h1bmtzID1cbiAgICAgICAgICAgIGluaXRQYXJhbXMudG9vbF9jYWxsX2NodW5rcyA/PyB0aGlzLnRvb2xfY2FsbF9jaHVua3M7XG4gICAgICAgIHRoaXMudG9vbF9jYWxscyA9IGluaXRQYXJhbXMudG9vbF9jYWxscyA/PyB0aGlzLnRvb2xfY2FsbHM7XG4gICAgICAgIHRoaXMuaW52YWxpZF90b29sX2NhbGxzID1cbiAgICAgICAgICAgIGluaXRQYXJhbXMuaW52YWxpZF90b29sX2NhbGxzID8/IHRoaXMuaW52YWxpZF90b29sX2NhbGxzO1xuICAgICAgICB0aGlzLnVzYWdlX21ldGFkYXRhID0gaW5pdFBhcmFtcy51c2FnZV9tZXRhZGF0YTtcbiAgICB9XG4gICAgZ2V0IGxjX2FsaWFzZXMoKSB7XG4gICAgICAgIC8vIGV4Y2x1ZGUgc25ha2UgY2FzZSBjb252ZXJzaW9uIHRvIHBhc2NhbCBjYXNlXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci5sY19hbGlhc2VzLFxuICAgICAgICAgICAgdG9vbF9jYWxsczogXCJ0b29sX2NhbGxzXCIsXG4gICAgICAgICAgICBpbnZhbGlkX3Rvb2xfY2FsbHM6IFwiaW52YWxpZF90b29sX2NhbGxzXCIsXG4gICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBcInRvb2xfY2FsbF9jaHVua3NcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkFJTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJhaVwiO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICB0b29sX2NhbGxzOiB0aGlzLnRvb2xfY2FsbHMsXG4gICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiB0aGlzLnRvb2xfY2FsbF9jaHVua3MsXG4gICAgICAgICAgICBpbnZhbGlkX3Rvb2xfY2FsbHM6IHRoaXMuaW52YWxpZF90b29sX2NhbGxzLFxuICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IHRoaXMudXNhZ2VfbWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICBjb25zdCBjb21iaW5lZEZpZWxkcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1lcmdlQ29udGVudCh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IF9tZXJnZURpY3RzKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiBfbWVyZ2VEaWN0cyh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBbXSxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkID8/IGNodW5rLmlkLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy50b29sX2NhbGxfY2h1bmtzICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGNodW5rLnRvb2xfY2FsbF9jaHVua3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcmF3VG9vbENhbGxzID0gX21lcmdlTGlzdHModGhpcy50b29sX2NhbGxfY2h1bmtzLCBjaHVuay50b29sX2NhbGxfY2h1bmtzKTtcbiAgICAgICAgICAgIGlmIChyYXdUb29sQ2FsbHMgIT09IHVuZGVmaW5lZCAmJiByYXdUb29sQ2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbWJpbmVkRmllbGRzLnRvb2xfY2FsbF9jaHVua3MgPSByYXdUb29sQ2FsbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXNhZ2VfbWV0YWRhdGEgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgY2h1bmsudXNhZ2VfbWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHRoaXMudXNhZ2VfbWV0YWRhdGEgPz8ge1xuICAgICAgICAgICAgICAgIGlucHV0X3Rva2VuczogMCxcbiAgICAgICAgICAgICAgICBvdXRwdXRfdG9rZW5zOiAwLFxuICAgICAgICAgICAgICAgIHRvdGFsX3Rva2VuczogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGNodW5rLnVzYWdlX21ldGFkYXRhID8/IHtcbiAgICAgICAgICAgICAgICBpbnB1dF90b2tlbnM6IDAsXG4gICAgICAgICAgICAgICAgb3V0cHV0X3Rva2VuczogMCxcbiAgICAgICAgICAgICAgICB0b3RhbF90b2tlbnM6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdXNhZ2VfbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgaW5wdXRfdG9rZW5zOiBsZWZ0LmlucHV0X3Rva2VucyArIHJpZ2h0LmlucHV0X3Rva2VucyxcbiAgICAgICAgICAgICAgICBvdXRwdXRfdG9rZW5zOiBsZWZ0Lm91dHB1dF90b2tlbnMgKyByaWdodC5vdXRwdXRfdG9rZW5zLFxuICAgICAgICAgICAgICAgIHRvdGFsX3Rva2VuczogbGVmdC50b3RhbF90b2tlbnMgKyByaWdodC50b3RhbF90b2tlbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29tYmluZWRGaWVsZHMudXNhZ2VfbWV0YWRhdGEgPSB1c2FnZV9tZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFJTWVzc2FnZUNodW5rKGNvbWJpbmVkRmllbGRzKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/ai.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/base.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/base.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseMessage: () => (/* binding */ BaseMessage),\n/* harmony export */   BaseMessageChunk: () => (/* binding */ BaseMessageChunk),\n/* harmony export */   _isMessageFieldWithRole: () => (/* binding */ _isMessageFieldWithRole),\n/* harmony export */   _mergeDicts: () => (/* binding */ _mergeDicts),\n/* harmony export */   _mergeLists: () => (/* binding */ _mergeLists),\n/* harmony export */   _mergeObj: () => (/* binding */ _mergeObj),\n/* harmony export */   _mergeStatus: () => (/* binding */ _mergeStatus),\n/* harmony export */   isBaseMessage: () => (/* binding */ isBaseMessage),\n/* harmony export */   isBaseMessageChunk: () => (/* binding */ isBaseMessageChunk),\n/* harmony export */   isOpenAIToolCallArray: () => (/* binding */ isOpenAIToolCallArray),\n/* harmony export */   mergeContent: () => (/* binding */ mergeContent)\n/* harmony export */ });\n/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../load/serializable.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/load/serializable.js\");\n\nfunction mergeContent(firstContent, secondContent) {\n    // If first content is a string\n    if (typeof firstContent === \"string\") {\n        if (typeof secondContent === \"string\") {\n            return firstContent + secondContent;\n        }\n        else {\n            return [{ type: \"text\", text: firstContent }, ...secondContent];\n        }\n        // If both are arrays\n    }\n    else if (Array.isArray(secondContent)) {\n        return (_mergeLists(firstContent, secondContent) ?? [\n            ...firstContent,\n            ...secondContent,\n        ]);\n    }\n    else {\n        // Otherwise, add the second content as a new element of the list\n        return [...firstContent, { type: \"text\", text: secondContent }];\n    }\n}\n/**\n * 'Merge' two statuses. If either value passed is 'error', it will return 'error'. Else\n * it will return 'success'.\n *\n * @param {\"success\" | \"error\" | undefined} left The existing value to 'merge' with the new value.\n * @param {\"success\" | \"error\" | undefined} right The new value to 'merge' with the existing value\n * @returns {\"success\" | \"error\"} The 'merged' value.\n */\nfunction _mergeStatus(left, right) {\n    if (left === \"error\" || right === \"error\") {\n        return \"error\";\n    }\n    return \"success\";\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction stringifyWithDepthLimit(obj, depthLimit) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function helper(obj, currentDepth) {\n        if (typeof obj !== \"object\" || obj === null || obj === undefined) {\n            return obj;\n        }\n        if (currentDepth >= depthLimit) {\n            if (Array.isArray(obj)) {\n                return \"[Array]\";\n            }\n            return \"[Object]\";\n        }\n        if (Array.isArray(obj)) {\n            return obj.map((item) => helper(item, currentDepth + 1));\n        }\n        const result = {};\n        for (const key of Object.keys(obj)) {\n            result[key] = helper(obj[key], currentDepth + 1);\n        }\n        return result;\n    }\n    return JSON.stringify(helper(obj, 0), null, 2);\n}\n/**\n * Base class for all types of messages in a conversation. It includes\n * properties like `content`, `name`, and `additional_kwargs`. It also\n * includes methods like `toDict()` and `_getType()`.\n */\nclass BaseMessage extends _load_serializable_js__WEBPACK_IMPORTED_MODULE_0__.Serializable {\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            additional_kwargs: \"additional_kwargs\",\n            response_metadata: \"response_metadata\",\n        };\n    }\n    /**\n     * @deprecated\n     * Use {@link BaseMessage.content} instead.\n     */\n    get text() {\n        return typeof this.content === \"string\" ? this.content : \"\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            fields = {\n                content: fields,\n                additional_kwargs: kwargs,\n                response_metadata: {},\n            };\n        }\n        // Make sure the default value for additional_kwargs is passed into super() for serialization\n        if (!fields.additional_kwargs) {\n            // eslint-disable-next-line no-param-reassign\n            fields.additional_kwargs = {};\n        }\n        if (!fields.response_metadata) {\n            // eslint-disable-next-line no-param-reassign\n            fields.response_metadata = {};\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"messages\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /** The content of the message. */\n        Object.defineProperty(this, \"content\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** The name of the message sender in a multi-user chat. */\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Additional keyword arguments */\n        Object.defineProperty(this, \"additional_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Response metadata. For example: response headers, logprobs, token counts. */\n        Object.defineProperty(this, \"response_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * An optional unique identifier for the message. This should ideally be\n         * provided by the provider/model which created the message.\n         */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.content = fields.content;\n        this.additional_kwargs = fields.additional_kwargs;\n        this.response_metadata = fields.response_metadata;\n        this.id = fields.id;\n    }\n    toDict() {\n        return {\n            type: this._getType(),\n            data: this.toJSON()\n                .kwargs,\n        };\n    }\n    static lc_name() {\n        return \"BaseMessage\";\n    }\n    // Can't be protected for silly reasons\n    get _printableFields() {\n        return {\n            id: this.id,\n            content: this.content,\n            name: this.name,\n            additional_kwargs: this.additional_kwargs,\n            response_metadata: this.response_metadata,\n        };\n    }\n    // this private method is used to update the ID for the runtime\n    // value as well as in lc_kwargs for serialisation\n    _updateId(value) {\n        this.id = value;\n        // lc_attributes wouldn't work here, because jest compares the\n        // whole object\n        this.lc_kwargs.id = value;\n    }\n    get [Symbol.toStringTag]() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return this.constructor.lc_name();\n    }\n    // Override the default behavior of console.log\n    [Symbol.for(\"nodejs.util.inspect.custom\")](depth) {\n        if (depth === null) {\n            return this;\n        }\n        const printable = stringifyWithDepthLimit(this._printableFields, Math.max(4, depth));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return `${this.constructor.lc_name()} ${printable}`;\n    }\n}\nfunction isOpenAIToolCallArray(value) {\n    return (Array.isArray(value) &&\n        value.every((v) => typeof v.index === \"number\"));\n}\nfunction _mergeDicts(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nleft, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nright\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    const merged = { ...left };\n    for (const [key, value] of Object.entries(right)) {\n        if (merged[key] == null) {\n            merged[key] = value;\n        }\n        else if (value == null) {\n            continue;\n        }\n        else if (typeof merged[key] !== typeof value ||\n            Array.isArray(merged[key]) !== Array.isArray(value)) {\n            throw new Error(`field[${key}] already exists in the message chunk, but with a different type.`);\n        }\n        else if (typeof merged[key] === \"string\") {\n            if (key === \"type\") {\n                // Do not merge 'type' fields\n                continue;\n            }\n            merged[key] += value;\n        }\n        else if (typeof merged[key] === \"object\" && !Array.isArray(merged[key])) {\n            merged[key] = _mergeDicts(merged[key], value);\n        }\n        else if (Array.isArray(merged[key])) {\n            merged[key] = _mergeLists(merged[key], value);\n        }\n        else if (merged[key] === value) {\n            continue;\n        }\n        else {\n            console.warn(`field[${key}] already exists in this message chunk and value has unsupported type.`);\n        }\n    }\n    return merged;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _mergeLists(left, right) {\n    if (left === undefined && right === undefined) {\n        return undefined;\n    }\n    else if (left === undefined || right === undefined) {\n        return left || right;\n    }\n    else {\n        const merged = [...left];\n        for (const item of right) {\n            if (typeof item === \"object\" &&\n                \"index\" in item &&\n                typeof item.index === \"number\") {\n                const toMerge = merged.findIndex((leftItem) => leftItem.index === item.index);\n                if (toMerge !== -1) {\n                    merged[toMerge] = _mergeDicts(merged[toMerge], item);\n                }\n                else {\n                    merged.push(item);\n                }\n            }\n            else if (typeof item === \"object\" &&\n                \"text\" in item &&\n                item.text === \"\") {\n                // No-op - skip empty text blocks\n                continue;\n            }\n            else {\n                merged.push(item);\n            }\n        }\n        return merged;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _mergeObj(left, right) {\n    if (!left && !right) {\n        throw new Error(\"Cannot merge two undefined objects.\");\n    }\n    if (!left || !right) {\n        return left || right;\n    }\n    else if (typeof left !== typeof right) {\n        throw new Error(`Cannot merge objects of different types.\\nLeft ${typeof left}\\nRight ${typeof right}`);\n    }\n    else if (typeof left === \"string\" && typeof right === \"string\") {\n        return (left + right);\n    }\n    else if (Array.isArray(left) && Array.isArray(right)) {\n        return _mergeLists(left, right);\n    }\n    else if (typeof left === \"object\" && typeof right === \"object\") {\n        return _mergeDicts(left, right);\n    }\n    else if (left === right) {\n        return left;\n    }\n    else {\n        throw new Error(`Can not merge objects of different types.\\nLeft ${left}\\nRight ${right}`);\n    }\n}\n/**\n * Represents a chunk of a message, which can be concatenated with other\n * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n * additional keyword arguments from another `BaseMessageChunk` into this\n * one. It also overrides the `__add__()` method to support concatenation\n * of `BaseMessageChunk` instances.\n */\nclass BaseMessageChunk extends BaseMessage {\n}\nfunction _isMessageFieldWithRole(x) {\n    return typeof x.role === \"string\";\n}\nfunction isBaseMessage(messageLike) {\n    return typeof messageLike?._getType === \"function\";\n}\nfunction isBaseMessageChunk(messageLike) {\n    return (isBaseMessage(messageLike) &&\n        typeof messageLike.concat === \"function\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXVEO0FBQ2hEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtDQUFrQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1DQUFtQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxXQUFXLGlDQUFpQztBQUM1QyxhQUFhLHFCQUFxQjtBQUNsQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQkFBMEIsK0RBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0QkFBNEIsRUFBRSxVQUFVO0FBQzFEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxJQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxZQUFZLFVBQVUsYUFBYTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLEtBQUssVUFBVSxNQUFNO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXHRleHRzcGxpdHRlcnNcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcbWVzc2FnZXNcXGJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2VyaWFsaXphYmxlIH0gZnJvbSBcIi4uL2xvYWQvc2VyaWFsaXphYmxlLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VDb250ZW50KGZpcnN0Q29udGVudCwgc2Vjb25kQ29udGVudCkge1xuICAgIC8vIElmIGZpcnN0IGNvbnRlbnQgaXMgYSBzdHJpbmdcbiAgICBpZiAodHlwZW9mIGZpcnN0Q29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIHNlY29uZENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdENvbnRlbnQgKyBzZWNvbmRDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBmaXJzdENvbnRlbnQgfSwgLi4uc2Vjb25kQ29udGVudF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYm90aCBhcmUgYXJyYXlzXG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2Vjb25kQ29udGVudCkpIHtcbiAgICAgICAgcmV0dXJuIChfbWVyZ2VMaXN0cyhmaXJzdENvbnRlbnQsIHNlY29uZENvbnRlbnQpID8/IFtcbiAgICAgICAgICAgIC4uLmZpcnN0Q29udGVudCxcbiAgICAgICAgICAgIC4uLnNlY29uZENvbnRlbnQsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBhZGQgdGhlIHNlY29uZCBjb250ZW50IGFzIGEgbmV3IGVsZW1lbnQgb2YgdGhlIGxpc3RcbiAgICAgICAgcmV0dXJuIFsuLi5maXJzdENvbnRlbnQsIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHNlY29uZENvbnRlbnQgfV07XG4gICAgfVxufVxuLyoqXG4gKiAnTWVyZ2UnIHR3byBzdGF0dXNlcy4gSWYgZWl0aGVyIHZhbHVlIHBhc3NlZCBpcyAnZXJyb3InLCBpdCB3aWxsIHJldHVybiAnZXJyb3InLiBFbHNlXG4gKiBpdCB3aWxsIHJldHVybiAnc3VjY2VzcycuXG4gKlxuICogQHBhcmFtIHtcInN1Y2Nlc3NcIiB8IFwiZXJyb3JcIiB8IHVuZGVmaW5lZH0gbGVmdCBUaGUgZXhpc3RpbmcgdmFsdWUgdG8gJ21lcmdlJyB3aXRoIHRoZSBuZXcgdmFsdWUuXG4gKiBAcGFyYW0ge1wic3VjY2Vzc1wiIHwgXCJlcnJvclwiIHwgdW5kZWZpbmVkfSByaWdodCBUaGUgbmV3IHZhbHVlIHRvICdtZXJnZScgd2l0aCB0aGUgZXhpc3RpbmcgdmFsdWVcbiAqIEByZXR1cm5zIHtcInN1Y2Nlc3NcIiB8IFwiZXJyb3JcIn0gVGhlICdtZXJnZWQnIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gX21lcmdlU3RhdHVzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPT09IFwiZXJyb3JcIiB8fCByaWdodCA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIHJldHVybiBcImVycm9yXCI7XG4gICAgfVxuICAgIHJldHVybiBcInN1Y2Nlc3NcIjtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBzdHJpbmdpZnlXaXRoRGVwdGhMaW1pdChvYmosIGRlcHRoTGltaXQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGZ1bmN0aW9uIGhlbHBlcihvYmosIGN1cnJlbnREZXB0aCkge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnREZXB0aCA+PSBkZXB0aExpbWl0KSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW0FycmF5XVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiW09iamVjdF1cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLm1hcCgoaXRlbSkgPT4gaGVscGVyKGl0ZW0sIGN1cnJlbnREZXB0aCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBoZWxwZXIob2JqW2tleV0sIGN1cnJlbnREZXB0aCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShoZWxwZXIob2JqLCAwKSwgbnVsbCwgMik7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCB0eXBlcyBvZiBtZXNzYWdlcyBpbiBhIGNvbnZlcnNhdGlvbi4gSXQgaW5jbHVkZXNcbiAqIHByb3BlcnRpZXMgbGlrZSBgY29udGVudGAsIGBuYW1lYCwgYW5kIGBhZGRpdGlvbmFsX2t3YXJnc2AuIEl0IGFsc29cbiAqIGluY2x1ZGVzIG1ldGhvZHMgbGlrZSBgdG9EaWN0KClgIGFuZCBgX2dldFR5cGUoKWAuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlTWVzc2FnZSBleHRlbmRzIFNlcmlhbGl6YWJsZSB7XG4gICAgZ2V0IGxjX2FsaWFzZXMoKSB7XG4gICAgICAgIC8vIGV4Y2x1ZGUgc25ha2UgY2FzZSBjb252ZXJzaW9uIHRvIHBhc2NhbCBjYXNlXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogXCJhZGRpdGlvbmFsX2t3YXJnc1wiLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6IFwicmVzcG9uc2VfbWV0YWRhdGFcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBVc2Uge0BsaW5rIEJhc2VNZXNzYWdlLmNvbnRlbnR9IGluc3RlYWQuXG4gICAgICovXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5jb250ZW50ID09PSBcInN0cmluZ1wiID8gdGhpcy5jb250ZW50IDogXCJcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBrd2FyZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzID0ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGZpZWxkcyxcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczoga3dhcmdzLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBkZWZhdWx0IHZhbHVlIGZvciBhZGRpdGlvbmFsX2t3YXJncyBpcyBwYXNzZWQgaW50byBzdXBlcigpIGZvciBzZXJpYWxpemF0aW9uXG4gICAgICAgIGlmICghZmllbGRzLmFkZGl0aW9uYWxfa3dhcmdzKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGZpZWxkcy5hZGRpdGlvbmFsX2t3YXJncyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmllbGRzLnJlc3BvbnNlX21ldGFkYXRhKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGZpZWxkcy5yZXNwb25zZV9tZXRhZGF0YSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJtZXNzYWdlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogVGhlIGNvbnRlbnQgb2YgdGhlIG1lc3NhZ2UuICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRlbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBtZXNzYWdlIHNlbmRlciBpbiBhIG11bHRpLXVzZXIgY2hhdC4gKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQWRkaXRpb25hbCBrZXl3b3JkIGFyZ3VtZW50cyAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhZGRpdGlvbmFsX2t3YXJnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogUmVzcG9uc2UgbWV0YWRhdGEuIEZvciBleGFtcGxlOiByZXNwb25zZSBoZWFkZXJzLCBsb2dwcm9icywgdG9rZW4gY291bnRzLiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNwb25zZV9tZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb3B0aW9uYWwgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBtZXNzYWdlLiBUaGlzIHNob3VsZCBpZGVhbGx5IGJlXG4gICAgICAgICAqIHByb3ZpZGVkIGJ5IHRoZSBwcm92aWRlci9tb2RlbCB3aGljaCBjcmVhdGVkIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gZmllbGRzLm5hbWU7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGZpZWxkcy5jb250ZW50O1xuICAgICAgICB0aGlzLmFkZGl0aW9uYWxfa3dhcmdzID0gZmllbGRzLmFkZGl0aW9uYWxfa3dhcmdzO1xuICAgICAgICB0aGlzLnJlc3BvbnNlX21ldGFkYXRhID0gZmllbGRzLnJlc3BvbnNlX21ldGFkYXRhO1xuICAgICAgICB0aGlzLmlkID0gZmllbGRzLmlkO1xuICAgIH1cbiAgICB0b0RpY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLl9nZXRUeXBlKCksXG4gICAgICAgICAgICBkYXRhOiB0aGlzLnRvSlNPTigpXG4gICAgICAgICAgICAgICAgLmt3YXJncyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkJhc2VNZXNzYWdlXCI7XG4gICAgfVxuICAgIC8vIENhbid0IGJlIHByb3RlY3RlZCBmb3Igc2lsbHkgcmVhc29uc1xuICAgIGdldCBfcHJpbnRhYmxlRmllbGRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBjb250ZW50OiB0aGlzLmNvbnRlbnQsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogdGhpcy5hZGRpdGlvbmFsX2t3YXJncyxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiB0aGlzLnJlc3BvbnNlX21ldGFkYXRhLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyB0aGlzIHByaXZhdGUgbWV0aG9kIGlzIHVzZWQgdG8gdXBkYXRlIHRoZSBJRCBmb3IgdGhlIHJ1bnRpbWVcbiAgICAvLyB2YWx1ZSBhcyB3ZWxsIGFzIGluIGxjX2t3YXJncyBmb3Igc2VyaWFsaXNhdGlvblxuICAgIF91cGRhdGVJZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmlkID0gdmFsdWU7XG4gICAgICAgIC8vIGxjX2F0dHJpYnV0ZXMgd291bGRuJ3Qgd29yayBoZXJlLCBiZWNhdXNlIGplc3QgY29tcGFyZXMgdGhlXG4gICAgICAgIC8vIHdob2xlIG9iamVjdFxuICAgICAgICB0aGlzLmxjX2t3YXJncy5pZCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmxjX25hbWUoKTtcbiAgICB9XG4gICAgLy8gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgY29uc29sZS5sb2dcbiAgICBbU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpXShkZXB0aCkge1xuICAgICAgICBpZiAoZGVwdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaW50YWJsZSA9IHN0cmluZ2lmeVdpdGhEZXB0aExpbWl0KHRoaXMuX3ByaW50YWJsZUZpZWxkcywgTWF0aC5tYXgoNCwgZGVwdGgpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubGNfbmFtZSgpfSAke3ByaW50YWJsZX1gO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc09wZW5BSVRvb2xDYWxsQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodmFsdWUpICYmXG4gICAgICAgIHZhbHVlLmV2ZXJ5KCh2KSA9PiB0eXBlb2Ygdi5pbmRleCA9PT0gXCJudW1iZXJcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9tZXJnZURpY3RzKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmxlZnQsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnJpZ2h0XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuKSB7XG4gICAgY29uc3QgbWVyZ2VkID0geyAuLi5sZWZ0IH07XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmlnaHQpKSB7XG4gICAgICAgIGlmIChtZXJnZWRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXJnZWRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXJnZWRba2V5XSAhPT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KG1lcmdlZFtrZXldKSAhPT0gQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZmllbGRbJHtrZXl9XSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgbWVzc2FnZSBjaHVuaywgYnV0IHdpdGggYSBkaWZmZXJlbnQgdHlwZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVyZ2VkW2tleV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwidHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IG1lcmdlICd0eXBlJyBmaWVsZHNcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lcmdlZFtrZXldICs9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXJnZWRba2V5XSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShtZXJnZWRba2V5XSkpIHtcbiAgICAgICAgICAgIG1lcmdlZFtrZXldID0gX21lcmdlRGljdHMobWVyZ2VkW2tleV0sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1lcmdlZFtrZXldKSkge1xuICAgICAgICAgICAgbWVyZ2VkW2tleV0gPSBfbWVyZ2VMaXN0cyhtZXJnZWRba2V5XSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lcmdlZFtrZXldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYGZpZWxkWyR7a2V5fV0gYWxyZWFkeSBleGlzdHMgaW4gdGhpcyBtZXNzYWdlIGNodW5rIGFuZCB2YWx1ZSBoYXMgdW5zdXBwb3J0ZWQgdHlwZS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBmdW5jdGlvbiBfbWVyZ2VMaXN0cyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0ID09PSB1bmRlZmluZWQgJiYgcmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZWZ0ID09PSB1bmRlZmluZWQgfHwgcmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVmdCB8fCByaWdodDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IFsuLi5sZWZ0XTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHJpZ2h0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBcImluZGV4XCIgaW4gaXRlbSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVtLmluZGV4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9NZXJnZSA9IG1lcmdlZC5maW5kSW5kZXgoKGxlZnRJdGVtKSA9PiBsZWZ0SXRlbS5pbmRleCA9PT0gaXRlbS5pbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHRvTWVyZ2UgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFt0b01lcmdlXSA9IF9tZXJnZURpY3RzKG1lcmdlZFt0b01lcmdlXSwgaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIFwidGV4dFwiIGluIGl0ZW0gJiZcbiAgICAgICAgICAgICAgICBpdGVtLnRleHQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBOby1vcCAtIHNraXAgZW1wdHkgdGV4dCBibG9ja3NcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlZC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfVxufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBmdW5jdGlvbiBfbWVyZ2VPYmoobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAoIWxlZnQgJiYgIXJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtZXJnZSB0d28gdW5kZWZpbmVkIG9iamVjdHMuXCIpO1xuICAgIH1cbiAgICBpZiAoIWxlZnQgfHwgIXJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsZWZ0IHx8IHJpZ2h0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGVmdCAhPT0gdHlwZW9mIHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG1lcmdlIG9iamVjdHMgb2YgZGlmZmVyZW50IHR5cGVzLlxcbkxlZnQgJHt0eXBlb2YgbGVmdH1cXG5SaWdodCAke3R5cGVvZiByaWdodH1gKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGxlZnQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJpZ2h0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiAobGVmdCArIHJpZ2h0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShsZWZ0KSAmJiBBcnJheS5pc0FycmF5KHJpZ2h0KSkge1xuICAgICAgICByZXR1cm4gX21lcmdlTGlzdHMobGVmdCwgcmlnaHQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGVmdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmlnaHQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIF9tZXJnZURpY3RzKGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVmdCA9PT0gcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgbWVyZ2Ugb2JqZWN0cyBvZiBkaWZmZXJlbnQgdHlwZXMuXFxuTGVmdCAke2xlZnR9XFxuUmlnaHQgJHtyaWdodH1gKTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaHVuayBvZiBhIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuICogbWVzc2FnZSBjaHVua3MuIEl0IGluY2x1ZGVzIGEgbWV0aG9kIGBfbWVyZ2Vfa3dhcmdzX2RpY3QoKWAgZm9yIG1lcmdpbmdcbiAqIGFkZGl0aW9uYWwga2V5d29yZCBhcmd1bWVudHMgZnJvbSBhbm90aGVyIGBCYXNlTWVzc2FnZUNodW5rYCBpbnRvIHRoaXNcbiAqIG9uZS4gSXQgYWxzbyBvdmVycmlkZXMgdGhlIGBfX2FkZF9fKClgIG1ldGhvZCB0byBzdXBwb3J0IGNvbmNhdGVuYXRpb25cbiAqIG9mIGBCYXNlTWVzc2FnZUNodW5rYCBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlTWVzc2FnZUNodW5rIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9pc01lc3NhZ2VGaWVsZFdpdGhSb2xlKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHgucm9sZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Jhc2VNZXNzYWdlKG1lc3NhZ2VMaWtlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlTGlrZT8uX2dldFR5cGUgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Jhc2VNZXNzYWdlQ2h1bmsobWVzc2FnZUxpa2UpIHtcbiAgICByZXR1cm4gKGlzQmFzZU1lc3NhZ2UobWVzc2FnZUxpa2UpICYmXG4gICAgICAgIHR5cGVvZiBtZXNzYWdlTGlrZS5jb25jYXQgPT09IFwiZnVuY3Rpb25cIik7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/base.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/chat.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/chat.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatMessage: () => (/* binding */ ChatMessage),\n/* harmony export */   ChatMessageChunk: () => (/* binding */ ChatMessageChunk)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/base.js\");\n\n/**\n * Represents a chat message in a conversation.\n */\nclass ChatMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage {\n    static lc_name() {\n        return \"ChatMessage\";\n    }\n    static _chatMessageClass() {\n        return ChatMessage;\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"generic\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            role: this.role,\n        };\n    }\n}\n/**\n * Represents a chunk of a chat message, which can be concatenated with\n * other chat message chunks.\n */\nclass ChatMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk {\n    static lc_name() {\n        return \"ChatMessageChunk\";\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    concat(chunk) {\n        return new ChatMessageChunk({\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            role: this.role,\n            id: this.id ?? chunk.id,\n        });\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            role: this.role,\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL2NoYXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNPLDBCQUEwQixpREFBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0Isc0RBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBWTtBQUNqQywrQkFBK0IscURBQVc7QUFDMUMsK0JBQStCLHFEQUFXO0FBQzFDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXHRleHRzcGxpdHRlcnNcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcbWVzc2FnZXNcXGNoYXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZU1lc3NhZ2UsIEJhc2VNZXNzYWdlQ2h1bmssIG1lcmdlQ29udGVudCwgX21lcmdlRGljdHMsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2hhdCBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgQ2hhdE1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkNoYXRNZXNzYWdlXCI7XG4gICAgfVxuICAgIHN0YXRpYyBfY2hhdE1lc3NhZ2VDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIENoYXRNZXNzYWdlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHJvbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZmllbGRzID0geyBjb250ZW50OiBmaWVsZHMsIHJvbGU6IHJvbGUgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb2xlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucm9sZSA9IGZpZWxkcy5yb2xlO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2VuZXJpY1wiO1xuICAgIH1cbiAgICBzdGF0aWMgaXNJbnN0YW5jZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLl9nZXRUeXBlKCkgPT09IFwiZ2VuZXJpY1wiO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICByb2xlOiB0aGlzLnJvbGUsXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSBjaGF0IG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aFxuICogb3RoZXIgY2hhdCBtZXNzYWdlIGNodW5rcy5cbiAqL1xuZXhwb3J0IGNsYXNzIENoYXRNZXNzYWdlQ2h1bmsgZXh0ZW5kcyBCYXNlTWVzc2FnZUNodW5rIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2hhdE1lc3NhZ2VDaHVua1wiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHJvbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZmllbGRzID0geyBjb250ZW50OiBmaWVsZHMsIHJvbGU6IHJvbGUgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb2xlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucm9sZSA9IGZpZWxkcy5yb2xlO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2VuZXJpY1wiO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0TWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1lcmdlQ29udGVudCh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IF9tZXJnZURpY3RzKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiBfbWVyZ2VEaWN0cyh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICByb2xlOiB0aGlzLnJvbGUsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBfcHJpbnRhYmxlRmllbGRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIuX3ByaW50YWJsZUZpZWxkcyxcbiAgICAgICAgICAgIHJvbGU6IHRoaXMucm9sZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/chat.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/function.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/function.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionMessage: () => (/* binding */ FunctionMessage),\n/* harmony export */   FunctionMessageChunk: () => (/* binding */ FunctionMessageChunk)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/base.js\");\n\n/**\n * Represents a function message in a conversation.\n */\nclass FunctionMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage {\n    static lc_name() {\n        return \"FunctionMessage\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name: name };\n        }\n        super(fields);\n    }\n    _getType() {\n        return \"function\";\n    }\n}\n/**\n * Represents a chunk of a function message, which can be concatenated\n * with other function message chunks.\n */\nclass FunctionMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk {\n    static lc_name() {\n        return \"FunctionMessageChunk\";\n    }\n    _getType() {\n        return \"function\";\n    }\n    concat(chunk) {\n        return new FunctionMessageChunk({\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            name: this.name ?? \"\",\n            id: this.id ?? chunk.id,\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL2Z1bmN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDTyw4QkFBOEIsaURBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUNBQW1DLHNEQUFnQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNEQUFZO0FBQ2pDLCtCQUErQixxREFBVztBQUMxQywrQkFBK0IscURBQVc7QUFDMUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcdGV4dHNwbGl0dGVyc1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxtZXNzYWdlc1xcZnVuY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZU1lc3NhZ2UsIEJhc2VNZXNzYWdlQ2h1bmssIG1lcmdlQ29udGVudCwgX21lcmdlRGljdHMsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgZnVuY3Rpb24gbWVzc2FnZSBpbiBhIGNvbnZlcnNhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiRnVuY3Rpb25NZXNzYWdlXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgbmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBmaWVsZHMgPSB7IGNvbnRlbnQ6IGZpZWxkcywgbmFtZTogbmFtZSB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGEgZnVuY3Rpb24gbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZFxuICogd2l0aCBvdGhlciBmdW5jdGlvbiBtZXNzYWdlIGNodW5rcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uTWVzc2FnZUNodW5rIGV4dGVuZHMgQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkZ1bmN0aW9uTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbk1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICBjb250ZW50OiBtZXJnZUNvbnRlbnQodGhpcy5jb250ZW50LCBjaHVuay5jb250ZW50KSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiBfbWVyZ2VEaWN0cyh0aGlzLmFkZGl0aW9uYWxfa3dhcmdzLCBjaHVuay5hZGRpdGlvbmFsX2t3YXJncyksXG4gICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogX21lcmdlRGljdHModGhpcy5yZXNwb25zZV9tZXRhZGF0YSwgY2h1bmsucmVzcG9uc2VfbWV0YWRhdGEpLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lID8/IFwiXCIsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/function.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/human.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/human.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HumanMessage: () => (/* binding */ HumanMessage),\n/* harmony export */   HumanMessageChunk: () => (/* binding */ HumanMessageChunk)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/base.js\");\n\n/**\n * Represents a human message in a conversation.\n */\nclass HumanMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage {\n    static lc_name() {\n        return \"HumanMessage\";\n    }\n    _getType() {\n        return \"human\";\n    }\n}\n/**\n * Represents a chunk of a human message, which can be concatenated with\n * other human message chunks.\n */\nclass HumanMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk {\n    static lc_name() {\n        return \"HumanMessageChunk\";\n    }\n    _getType() {\n        return \"human\";\n    }\n    concat(chunk) {\n        return new HumanMessageChunk({\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            id: this.id ?? chunk.id,\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL2h1bWFuLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDTywyQkFBMkIsaURBQVc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQyxzREFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBWTtBQUNqQywrQkFBK0IscURBQVc7QUFDMUMsK0JBQStCLHFEQUFXO0FBQzFDO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFx0ZXh0c3BsaXR0ZXJzXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXG1lc3NhZ2VzXFxodW1hbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlTWVzc2FnZSwgQmFzZU1lc3NhZ2VDaHVuaywgbWVyZ2VDb250ZW50LCBfbWVyZ2VEaWN0cywgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBodW1hbiBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgSHVtYW5NZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJIdW1hbk1lc3NhZ2VcIjtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImh1bWFuXCI7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSBodW1hbiBtZXNzYWdlLCB3aGljaCBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGhcbiAqIG90aGVyIGh1bWFuIG1lc3NhZ2UgY2h1bmtzLlxuICovXG5leHBvcnQgY2xhc3MgSHVtYW5NZXNzYWdlQ2h1bmsgZXh0ZW5kcyBCYXNlTWVzc2FnZUNodW5rIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSHVtYW5NZXNzYWdlQ2h1bmtcIjtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImh1bWFuXCI7XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IEh1bWFuTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1lcmdlQ29udGVudCh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IF9tZXJnZURpY3RzKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiBfbWVyZ2VEaWN0cyh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/human.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/system.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/system.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SystemMessage: () => (/* binding */ SystemMessage),\n/* harmony export */   SystemMessageChunk: () => (/* binding */ SystemMessageChunk)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/base.js\");\n\n/**\n * Represents a system message in a conversation.\n */\nclass SystemMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage {\n    static lc_name() {\n        return \"SystemMessage\";\n    }\n    _getType() {\n        return \"system\";\n    }\n}\n/**\n * Represents a chunk of a system message, which can be concatenated with\n * other system message chunks.\n */\nclass SystemMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk {\n    static lc_name() {\n        return \"SystemMessageChunk\";\n    }\n    _getType() {\n        return \"system\";\n    }\n    concat(chunk) {\n        return new SystemMessageChunk({\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            id: this.id ?? chunk.id,\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL3N5c3RlbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ08sNEJBQTRCLGlEQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMsc0RBQWdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQVk7QUFDakMsK0JBQStCLHFEQUFXO0FBQzFDLCtCQUErQixxREFBVztBQUMxQztBQUNBLFNBQVM7QUFDVDtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcdGV4dHNwbGl0dGVyc1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxtZXNzYWdlc1xcc3lzdGVtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VNZXNzYWdlLCBCYXNlTWVzc2FnZUNodW5rLCBtZXJnZUNvbnRlbnQsIF9tZXJnZURpY3RzLCB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbi8qKlxuICogUmVwcmVzZW50cyBhIHN5c3RlbSBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgU3lzdGVtTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3lzdGVtTWVzc2FnZVwiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwic3lzdGVtXCI7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSBzeXN0ZW0gbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoXG4gKiBvdGhlciBzeXN0ZW0gbWVzc2FnZSBjaHVua3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBTeXN0ZW1NZXNzYWdlQ2h1bmsgZXh0ZW5kcyBCYXNlTWVzc2FnZUNodW5rIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3lzdGVtTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJzeXN0ZW1cIjtcbiAgICB9XG4gICAgY29uY2F0KGNodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3lzdGVtTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1lcmdlQ29udGVudCh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IF9tZXJnZURpY3RzKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiBfbWVyZ2VEaWN0cyh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/system.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/tool.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/tool.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ToolMessage: () => (/* binding */ ToolMessage),\n/* harmony export */   ToolMessageChunk: () => (/* binding */ ToolMessageChunk),\n/* harmony export */   defaultToolCallParser: () => (/* binding */ defaultToolCallParser)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/base.js\");\n\n/**\n * Represents a tool message in a conversation.\n */\nclass ToolMessage extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessage {\n    static lc_name() {\n        return \"ToolMessage\";\n    }\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return { tool_call_id: \"tool_call_id\" };\n    }\n    constructor(fields, tool_call_id, name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name, tool_call_id: tool_call_id };\n        }\n        super(fields);\n        /**\n         * Status of the tool invocation.\n         * @version 0.2.19\n         */\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Artifact of the Tool execution which is not meant to be sent to the model.\n         *\n         * Should only be specified if it is different from the message content, e.g. if only\n         * a subset of the full tool output is being passed as message content but the full\n         * output is needed in other parts of the code.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"artifact\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n        this.artifact = fields.artifact;\n        this.status = fields.status;\n    }\n    _getType() {\n        return \"tool\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"tool\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_call_id: this.tool_call_id,\n            artifact: this.artifact,\n        };\n    }\n}\n/**\n * Represents a chunk of a tool message, which can be concatenated\n * with other tool message chunks.\n */\nclass ToolMessageChunk extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseMessageChunk {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Status of the tool invocation.\n         * @version 0.2.19\n         */\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Artifact of the Tool execution which is not meant to be sent to the model.\n         *\n         * Should only be specified if it is different from the message content, e.g. if only\n         * a subset of the full tool output is being passed as message content but the full\n         * output is needed in other parts of the code.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"artifact\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n        this.artifact = fields.artifact;\n        this.status = fields.status;\n    }\n    static lc_name() {\n        return \"ToolMessageChunk\";\n    }\n    _getType() {\n        return \"tool\";\n    }\n    concat(chunk) {\n        return new ToolMessageChunk({\n            content: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            artifact: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeObj)(this.artifact, chunk.artifact),\n            tool_call_id: this.tool_call_id,\n            id: this.id ?? chunk.id,\n            status: (0,_base_js__WEBPACK_IMPORTED_MODULE_0__._mergeStatus)(this.status, chunk.status),\n        });\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_call_id: this.tool_call_id,\n            artifact: this.artifact,\n        };\n    }\n}\nfunction defaultToolCallParser(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrawToolCalls) {\n    const toolCalls = [];\n    const invalidToolCalls = [];\n    for (const toolCall of rawToolCalls) {\n        if (!toolCall.function) {\n            continue;\n        }\n        else {\n            const functionName = toolCall.function.name;\n            try {\n                const functionArgs = JSON.parse(toolCall.function.arguments);\n                const parsed = {\n                    name: functionName || \"\",\n                    args: functionArgs || {},\n                    id: toolCall.id,\n                };\n                toolCalls.push(parsed);\n            }\n            catch (error) {\n                invalidToolCalls.push({\n                    name: functionName,\n                    args: toolCall.function.arguments,\n                    id: toolCall.id,\n                    error: \"Malformed args.\",\n                });\n            }\n        }\n    }\n    return [toolCalls, invalidToolCalls];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL3Rvb2wuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErRztBQUMvRztBQUNBO0FBQ0E7QUFDTywwQkFBMEIsaURBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0Isc0RBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQVk7QUFDakMsK0JBQStCLHFEQUFXO0FBQzFDLCtCQUErQixxREFBVztBQUMxQyxzQkFBc0IsbURBQVM7QUFDL0I7QUFDQTtBQUNBLG9CQUFvQixzREFBWTtBQUNoQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFx0ZXh0c3BsaXR0ZXJzXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXG1lc3NhZ2VzXFx0b29sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VNZXNzYWdlLCBCYXNlTWVzc2FnZUNodW5rLCBtZXJnZUNvbnRlbnQsIF9tZXJnZURpY3RzLCBfbWVyZ2VPYmosIF9tZXJnZVN0YXR1cywgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG4vKipcbiAqIFJlcHJlc2VudHMgYSB0b29sIG1lc3NhZ2UgaW4gYSBjb252ZXJzYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBUb29sTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiVG9vbE1lc3NhZ2VcIjtcbiAgICB9XG4gICAgZ2V0IGxjX2FsaWFzZXMoKSB7XG4gICAgICAgIC8vIGV4Y2x1ZGUgc25ha2UgY2FzZSBjb252ZXJzaW9uIHRvIHBhc2NhbCBjYXNlXG4gICAgICAgIHJldHVybiB7IHRvb2xfY2FsbF9pZDogXCJ0b29sX2NhbGxfaWRcIiB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHRvb2xfY2FsbF9pZCwgbmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBmaWVsZHMgPSB7IGNvbnRlbnQ6IGZpZWxkcywgbmFtZSwgdG9vbF9jYWxsX2lkOiB0b29sX2NhbGxfaWQgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhdHVzIG9mIHRoZSB0b29sIGludm9jYXRpb24uXG4gICAgICAgICAqIEB2ZXJzaW9uIDAuMi4xOVxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdHVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvb2xfY2FsbF9pZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXJ0aWZhY3Qgb2YgdGhlIFRvb2wgZXhlY3V0aW9uIHdoaWNoIGlzIG5vdCBtZWFudCB0byBiZSBzZW50IHRvIHRoZSBtb2RlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2hvdWxkIG9ubHkgYmUgc3BlY2lmaWVkIGlmIGl0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBtZXNzYWdlIGNvbnRlbnQsIGUuZy4gaWYgb25seVxuICAgICAgICAgKiBhIHN1YnNldCBvZiB0aGUgZnVsbCB0b29sIG91dHB1dCBpcyBiZWluZyBwYXNzZWQgYXMgbWVzc2FnZSBjb250ZW50IGJ1dCB0aGUgZnVsbFxuICAgICAgICAgKiBvdXRwdXQgaXMgbmVlZGVkIGluIG90aGVyIHBhcnRzIG9mIHRoZSBjb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJ0aWZhY3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b29sX2NhbGxfaWQgPSBmaWVsZHMudG9vbF9jYWxsX2lkO1xuICAgICAgICB0aGlzLmFydGlmYWN0ID0gZmllbGRzLmFydGlmYWN0O1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGZpZWxkcy5zdGF0dXM7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJ0b29sXCI7XG4gICAgfVxuICAgIHN0YXRpYyBpc0luc3RhbmNlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UuX2dldFR5cGUoKSA9PT0gXCJ0b29sXCI7XG4gICAgfVxuICAgIGdldCBfcHJpbnRhYmxlRmllbGRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIuX3ByaW50YWJsZUZpZWxkcyxcbiAgICAgICAgICAgIHRvb2xfY2FsbF9pZDogdGhpcy50b29sX2NhbGxfaWQsXG4gICAgICAgICAgICBhcnRpZmFjdDogdGhpcy5hcnRpZmFjdCxcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaHVuayBvZiBhIHRvb2wgbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZFxuICogd2l0aCBvdGhlciB0b29sIG1lc3NhZ2UgY2h1bmtzLlxuICovXG5leHBvcnQgY2xhc3MgVG9vbE1lc3NhZ2VDaHVuayBleHRlbmRzIEJhc2VNZXNzYWdlQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b29sX2NhbGxfaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXR1cyBvZiB0aGUgdG9vbCBpbnZvY2F0aW9uLlxuICAgICAgICAgKiBAdmVyc2lvbiAwLjIuMTlcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXR1c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXJ0aWZhY3Qgb2YgdGhlIFRvb2wgZXhlY3V0aW9uIHdoaWNoIGlzIG5vdCBtZWFudCB0byBiZSBzZW50IHRvIHRoZSBtb2RlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2hvdWxkIG9ubHkgYmUgc3BlY2lmaWVkIGlmIGl0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBtZXNzYWdlIGNvbnRlbnQsIGUuZy4gaWYgb25seVxuICAgICAgICAgKiBhIHN1YnNldCBvZiB0aGUgZnVsbCB0b29sIG91dHB1dCBpcyBiZWluZyBwYXNzZWQgYXMgbWVzc2FnZSBjb250ZW50IGJ1dCB0aGUgZnVsbFxuICAgICAgICAgKiBvdXRwdXQgaXMgbmVlZGVkIGluIG90aGVyIHBhcnRzIG9mIHRoZSBjb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJ0aWZhY3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b29sX2NhbGxfaWQgPSBmaWVsZHMudG9vbF9jYWxsX2lkO1xuICAgICAgICB0aGlzLmFydGlmYWN0ID0gZmllbGRzLmFydGlmYWN0O1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGZpZWxkcy5zdGF0dXM7XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJUb29sTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJ0b29sXCI7XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IFRvb2xNZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgY29udGVudDogbWVyZ2VDb250ZW50KHRoaXMuY29udGVudCwgY2h1bmsuY29udGVudCksXG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogX21lcmdlRGljdHModGhpcy5hZGRpdGlvbmFsX2t3YXJncywgY2h1bmsuYWRkaXRpb25hbF9rd2FyZ3MpLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6IF9tZXJnZURpY3RzKHRoaXMucmVzcG9uc2VfbWV0YWRhdGEsIGNodW5rLnJlc3BvbnNlX21ldGFkYXRhKSxcbiAgICAgICAgICAgIGFydGlmYWN0OiBfbWVyZ2VPYmoodGhpcy5hcnRpZmFjdCwgY2h1bmsuYXJ0aWZhY3QpLFxuICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiB0aGlzLnRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkID8/IGNodW5rLmlkLFxuICAgICAgICAgICAgc3RhdHVzOiBfbWVyZ2VTdGF0dXModGhpcy5zdGF0dXMsIGNodW5rLnN0YXR1cyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHRoaXMudG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgYXJ0aWZhY3Q6IHRoaXMuYXJ0aWZhY3QsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRUb29sQ2FsbFBhcnNlcihcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5yYXdUb29sQ2FsbHMpIHtcbiAgICBjb25zdCB0b29sQ2FsbHMgPSBbXTtcbiAgICBjb25zdCBpbnZhbGlkVG9vbENhbGxzID0gW107XG4gICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiByYXdUb29sQ2FsbHMpIHtcbiAgICAgICAgaWYgKCF0b29sQ2FsbC5mdW5jdGlvbikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvbkFyZ3MgPSBKU09OLnBhcnNlKHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbk5hbWUgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogZnVuY3Rpb25BcmdzIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbHMucHVzaChwYXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaW52YWxpZFRvb2xDYWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFwiTWFsZm9ybWVkIGFyZ3MuXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFt0b29sQ2FsbHMsIGludmFsaWRUb29sQ2FsbHNdO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/tool.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/utils.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/utils.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   coerceMessageLikeToMessage: () => (/* binding */ coerceMessageLikeToMessage),\n/* harmony export */   convertToChunk: () => (/* binding */ convertToChunk),\n/* harmony export */   getBufferString: () => (/* binding */ getBufferString),\n/* harmony export */   mapChatMessagesToStoredMessages: () => (/* binding */ mapChatMessagesToStoredMessages),\n/* harmony export */   mapStoredMessageToChatMessage: () => (/* binding */ mapStoredMessageToChatMessage),\n/* harmony export */   mapStoredMessagesToChatMessages: () => (/* binding */ mapStoredMessagesToChatMessages)\n/* harmony export */ });\n/* harmony import */ var _tools_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/utils.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tools/utils.js\");\n/* harmony import */ var _ai_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ai.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/ai.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/base.js\");\n/* harmony import */ var _chat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chat.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/chat.js\");\n/* harmony import */ var _function_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./function.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/function.js\");\n/* harmony import */ var _human_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./human.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/human.js\");\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./system.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/system.js\");\n/* harmony import */ var _tool_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tool.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/tool.js\");\n\n\n\n\n\n\n\n\nfunction _coerceToolCall(toolCall) {\n    if ((0,_tools_utils_js__WEBPACK_IMPORTED_MODULE_0__._isToolCall)(toolCall)) {\n        return toolCall;\n    }\n    else if (typeof toolCall.id === \"string\" &&\n        toolCall.type === \"function\" &&\n        typeof toolCall.function === \"object\" &&\n        toolCall.function !== null &&\n        \"arguments\" in toolCall.function &&\n        typeof toolCall.function.arguments === \"string\" &&\n        \"name\" in toolCall.function &&\n        typeof toolCall.function.name === \"string\") {\n        // Handle OpenAI tool call format\n        return {\n            id: toolCall.id,\n            args: JSON.parse(toolCall.function.arguments),\n            name: toolCall.function.name,\n            type: \"tool_call\",\n        };\n    }\n    else {\n        // TODO: Throw an error?\n        return toolCall;\n    }\n}\nfunction _constructMessageFromParams(params) {\n    const { type, ...rest } = params;\n    if (type === \"human\" || type === \"user\") {\n        return new _human_js__WEBPACK_IMPORTED_MODULE_5__.HumanMessage(rest);\n    }\n    else if (type === \"ai\" || type === \"assistant\") {\n        const { tool_calls: rawToolCalls, ...other } = rest;\n        if (!Array.isArray(rawToolCalls)) {\n            return new _ai_js__WEBPACK_IMPORTED_MODULE_1__.AIMessage(rest);\n        }\n        const tool_calls = rawToolCalls.map(_coerceToolCall);\n        return new _ai_js__WEBPACK_IMPORTED_MODULE_1__.AIMessage({ ...other, tool_calls });\n    }\n    else if (type === \"system\") {\n        return new _system_js__WEBPACK_IMPORTED_MODULE_6__.SystemMessage(rest);\n    }\n    else if (type === \"tool\" && \"tool_call_id\" in rest) {\n        return new _tool_js__WEBPACK_IMPORTED_MODULE_7__.ToolMessage({\n            ...rest,\n            content: rest.content,\n            tool_call_id: rest.tool_call_id,\n            name: rest.name,\n        });\n    }\n    else {\n        throw new Error(`Unable to coerce message from array: only human, AI, or system message coercion is currently supported.`);\n    }\n}\nfunction coerceMessageLikeToMessage(messageLike) {\n    if (typeof messageLike === \"string\") {\n        return new _human_js__WEBPACK_IMPORTED_MODULE_5__.HumanMessage(messageLike);\n    }\n    else if ((0,_base_js__WEBPACK_IMPORTED_MODULE_2__.isBaseMessage)(messageLike)) {\n        return messageLike;\n    }\n    if (Array.isArray(messageLike)) {\n        const [type, content] = messageLike;\n        return _constructMessageFromParams({ type, content });\n    }\n    else if ((0,_base_js__WEBPACK_IMPORTED_MODULE_2__._isMessageFieldWithRole)(messageLike)) {\n        const { role: type, ...rest } = messageLike;\n        return _constructMessageFromParams({ ...rest, type });\n    }\n    else {\n        return _constructMessageFromParams(messageLike);\n    }\n}\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nfunction getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n    const string_messages = [];\n    for (const m of messages) {\n        let role;\n        if (m._getType() === \"human\") {\n            role = humanPrefix;\n        }\n        else if (m._getType() === \"ai\") {\n            role = aiPrefix;\n        }\n        else if (m._getType() === \"system\") {\n            role = \"System\";\n        }\n        else if (m._getType() === \"function\") {\n            role = \"Function\";\n        }\n        else if (m._getType() === \"tool\") {\n            role = \"Tool\";\n        }\n        else if (m._getType() === \"generic\") {\n            role = m.role;\n        }\n        else {\n            throw new Error(`Got unsupported message type: ${m._getType()}`);\n        }\n        const nameStr = m.name ? `${m.name}, ` : \"\";\n        const readableContent = typeof m.content === \"string\"\n            ? m.content\n            : JSON.stringify(m.content, null, 2);\n        string_messages.push(`${role}: ${nameStr}${readableContent}`);\n    }\n    return string_messages.join(\"\\n\");\n}\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(message) {\n    // TODO: Remove this mapper when we deprecate the old message format.\n    if (message.data !== undefined) {\n        return message;\n    }\n    else {\n        const v1Message = message;\n        return {\n            type: v1Message.type,\n            data: {\n                content: v1Message.text,\n                role: v1Message.role,\n                name: undefined,\n                tool_call_id: undefined,\n            },\n        };\n    }\n}\nfunction mapStoredMessageToChatMessage(message) {\n    const storedMessage = mapV1MessageToStoredMessage(message);\n    switch (storedMessage.type) {\n        case \"human\":\n            return new _human_js__WEBPACK_IMPORTED_MODULE_5__.HumanMessage(storedMessage.data);\n        case \"ai\":\n            return new _ai_js__WEBPACK_IMPORTED_MODULE_1__.AIMessage(storedMessage.data);\n        case \"system\":\n            return new _system_js__WEBPACK_IMPORTED_MODULE_6__.SystemMessage(storedMessage.data);\n        case \"function\":\n            if (storedMessage.data.name === undefined) {\n                throw new Error(\"Name must be defined for function messages\");\n            }\n            return new _function_js__WEBPACK_IMPORTED_MODULE_4__.FunctionMessage(storedMessage.data);\n        case \"tool\":\n            if (storedMessage.data.tool_call_id === undefined) {\n                throw new Error(\"Tool call ID must be defined for tool messages\");\n            }\n            return new _tool_js__WEBPACK_IMPORTED_MODULE_7__.ToolMessage(storedMessage.data);\n        case \"generic\": {\n            if (storedMessage.data.role === undefined) {\n                throw new Error(\"Role must be defined for chat messages\");\n            }\n            return new _chat_js__WEBPACK_IMPORTED_MODULE_3__.ChatMessage(storedMessage.data);\n        }\n        default:\n            throw new Error(`Got unexpected type: ${storedMessage.type}`);\n    }\n}\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nfunction mapStoredMessagesToChatMessages(messages) {\n    return messages.map(mapStoredMessageToChatMessage);\n}\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nfunction mapChatMessagesToStoredMessages(messages) {\n    return messages.map((message) => message.toDict());\n}\nfunction convertToChunk(message) {\n    const type = message._getType();\n    if (type === \"human\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new _human_js__WEBPACK_IMPORTED_MODULE_5__.HumanMessageChunk({ ...message });\n    }\n    else if (type === \"ai\") {\n        let aiChunkFields = {\n            ...message,\n        };\n        if (\"tool_calls\" in aiChunkFields) {\n            aiChunkFields = {\n                ...aiChunkFields,\n                tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n                    ...tc,\n                    type: \"tool_call_chunk\",\n                    index: undefined,\n                    args: JSON.stringify(tc.args),\n                })),\n            };\n        }\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new _ai_js__WEBPACK_IMPORTED_MODULE_1__.AIMessageChunk({ ...aiChunkFields });\n    }\n    else if (type === \"system\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new _system_js__WEBPACK_IMPORTED_MODULE_6__.SystemMessageChunk({ ...message });\n    }\n    else if (type === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new _function_js__WEBPACK_IMPORTED_MODULE_4__.FunctionMessageChunk({ ...message });\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    }\n    else if (_chat_js__WEBPACK_IMPORTED_MODULE_3__.ChatMessage.isInstance(message)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new _chat_js__WEBPACK_IMPORTED_MODULE_3__.ChatMessageChunk({ ...message });\n    }\n    else {\n        throw new Error(\"Unknown message type.\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ0k7QUFDZ0I7QUFDVDtBQUNZO0FBQ1Y7QUFDRztBQUN2QjtBQUN6QztBQUNBLFFBQVEsNERBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSxtQkFBbUIsbURBQVk7QUFDL0I7QUFDQTtBQUNBLGdCQUFnQixxQ0FBcUM7QUFDckQ7QUFDQSx1QkFBdUIsNkNBQVM7QUFDaEM7QUFDQTtBQUNBLG1CQUFtQiw2Q0FBUyxHQUFHLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFhO0FBQ2hDO0FBQ0E7QUFDQSxtQkFBbUIsaURBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxtQkFBbUIsbURBQVk7QUFDL0I7QUFDQSxhQUFhLHVEQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGVBQWU7QUFDNUQ7QUFDQSxhQUFhLGlFQUF1QjtBQUNwQyxnQkFBZ0Isc0JBQXNCO0FBQ3RDLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsYUFBYTtBQUMxRTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxLQUFLLElBQUksUUFBUSxFQUFFLGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbURBQVk7QUFDbkM7QUFDQSx1QkFBdUIsNkNBQVM7QUFDaEM7QUFDQSx1QkFBdUIscURBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQVc7QUFDbEM7QUFDQTtBQUNBLG9EQUFvRCxtQkFBbUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3REFBaUIsR0FBRyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBYyxHQUFHLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQWtCLEdBQUcsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOERBQW9CLEdBQUcsWUFBWTtBQUN0RDtBQUNBO0FBQ0EsYUFBYSxpREFBVztBQUN4QjtBQUNBLG1CQUFtQixzREFBZ0IsR0FBRyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFx0ZXh0c3BsaXR0ZXJzXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXG1lc3NhZ2VzXFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfaXNUb29sQ2FsbCB9IGZyb20gXCIuLi90b29scy91dGlscy5qc1wiO1xuaW1wb3J0IHsgQUlNZXNzYWdlLCBBSU1lc3NhZ2VDaHVuayB9IGZyb20gXCIuL2FpLmpzXCI7XG5pbXBvcnQgeyBpc0Jhc2VNZXNzYWdlLCBfaXNNZXNzYWdlRmllbGRXaXRoUm9sZSwgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBDaGF0TWVzc2FnZSwgQ2hhdE1lc3NhZ2VDaHVuaywgfSBmcm9tIFwiLi9jaGF0LmpzXCI7XG5pbXBvcnQgeyBGdW5jdGlvbk1lc3NhZ2UsIEZ1bmN0aW9uTWVzc2FnZUNodW5rLCB9IGZyb20gXCIuL2Z1bmN0aW9uLmpzXCI7XG5pbXBvcnQgeyBIdW1hbk1lc3NhZ2UsIEh1bWFuTWVzc2FnZUNodW5rIH0gZnJvbSBcIi4vaHVtYW4uanNcIjtcbmltcG9ydCB7IFN5c3RlbU1lc3NhZ2UsIFN5c3RlbU1lc3NhZ2VDaHVuayB9IGZyb20gXCIuL3N5c3RlbS5qc1wiO1xuaW1wb3J0IHsgVG9vbE1lc3NhZ2UsIH0gZnJvbSBcIi4vdG9vbC5qc1wiO1xuZnVuY3Rpb24gX2NvZXJjZVRvb2xDYWxsKHRvb2xDYWxsKSB7XG4gICAgaWYgKF9pc1Rvb2xDYWxsKHRvb2xDYWxsKSkge1xuICAgICAgICByZXR1cm4gdG9vbENhbGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB0b29sQ2FsbC5pZCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICB0b29sQ2FsbC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIHRvb2xDYWxsLmZ1bmN0aW9uID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uICE9PSBudWxsICYmXG4gICAgICAgIFwiYXJndW1lbnRzXCIgaW4gdG9vbENhbGwuZnVuY3Rpb24gJiZcbiAgICAgICAgdHlwZW9mIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICBcIm5hbWVcIiBpbiB0b29sQ2FsbC5mdW5jdGlvbiAmJlxuICAgICAgICB0eXBlb2YgdG9vbENhbGwuZnVuY3Rpb24ubmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBIYW5kbGUgT3BlbkFJIHRvb2wgY2FsbCBmb3JtYXRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgIGFyZ3M6IEpTT04ucGFyc2UodG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzKSxcbiAgICAgICAgICAgIG5hbWU6IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiBcInRvb2xfY2FsbFwiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogVGhyb3cgYW4gZXJyb3I/XG4gICAgICAgIHJldHVybiB0b29sQ2FsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBfY29uc3RydWN0TWVzc2FnZUZyb21QYXJhbXMocGFyYW1zKSB7XG4gICAgY29uc3QgeyB0eXBlLCAuLi5yZXN0IH0gPSBwYXJhbXM7XG4gICAgaWYgKHR5cGUgPT09IFwiaHVtYW5cIiB8fCB0eXBlID09PSBcInVzZXJcIikge1xuICAgICAgICByZXR1cm4gbmV3IEh1bWFuTWVzc2FnZShyZXN0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJhaVwiIHx8IHR5cGUgPT09IFwiYXNzaXN0YW50XCIpIHtcbiAgICAgICAgY29uc3QgeyB0b29sX2NhbGxzOiByYXdUb29sQ2FsbHMsIC4uLm90aGVyIH0gPSByZXN0O1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmF3VG9vbENhbGxzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBSU1lc3NhZ2UocmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9vbF9jYWxscyA9IHJhd1Rvb2xDYWxscy5tYXAoX2NvZXJjZVRvb2xDYWxsKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBSU1lc3NhZ2UoeyAuLi5vdGhlciwgdG9vbF9jYWxscyB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJzeXN0ZW1cIikge1xuICAgICAgICByZXR1cm4gbmV3IFN5c3RlbU1lc3NhZ2UocmVzdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwidG9vbFwiICYmIFwidG9vbF9jYWxsX2lkXCIgaW4gcmVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IFRvb2xNZXNzYWdlKHtcbiAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICBjb250ZW50OiByZXN0LmNvbnRlbnQsXG4gICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHJlc3QudG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgbmFtZTogcmVzdC5uYW1lLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNvZXJjZSBtZXNzYWdlIGZyb20gYXJyYXk6IG9ubHkgaHVtYW4sIEFJLCBvciBzeXN0ZW0gbWVzc2FnZSBjb2VyY2lvbiBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLmApO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjb2VyY2VNZXNzYWdlTGlrZVRvTWVzc2FnZShtZXNzYWdlTGlrZSkge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZUxpa2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdW1hbk1lc3NhZ2UobWVzc2FnZUxpa2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Jhc2VNZXNzYWdlKG1lc3NhZ2VMaWtlKSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZUxpa2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2VMaWtlKSkge1xuICAgICAgICBjb25zdCBbdHlwZSwgY29udGVudF0gPSBtZXNzYWdlTGlrZTtcbiAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3RNZXNzYWdlRnJvbVBhcmFtcyh7IHR5cGUsIGNvbnRlbnQgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKF9pc01lc3NhZ2VGaWVsZFdpdGhSb2xlKG1lc3NhZ2VMaWtlKSkge1xuICAgICAgICBjb25zdCB7IHJvbGU6IHR5cGUsIC4uLnJlc3QgfSA9IG1lc3NhZ2VMaWtlO1xuICAgICAgICByZXR1cm4gX2NvbnN0cnVjdE1lc3NhZ2VGcm9tUGFyYW1zKHsgLi4ucmVzdCwgdHlwZSB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBfY29uc3RydWN0TWVzc2FnZUZyb21QYXJhbXMobWVzc2FnZUxpa2UpO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IG1lbW9yeSBjbGFzc2VzIHRvIGdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvblxuICogb2YgdGhlIGNoYXQgbWVzc2FnZSBoaXN0b3J5LCBiYXNlZCBvbiB0aGUgbWVzc2FnZSBjb250ZW50IGFuZCByb2xlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnVmZmVyU3RyaW5nKG1lc3NhZ2VzLCBodW1hblByZWZpeCA9IFwiSHVtYW5cIiwgYWlQcmVmaXggPSBcIkFJXCIpIHtcbiAgICBjb25zdCBzdHJpbmdfbWVzc2FnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG0gb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgbGV0IHJvbGU7XG4gICAgICAgIGlmIChtLl9nZXRUeXBlKCkgPT09IFwiaHVtYW5cIikge1xuICAgICAgICAgICAgcm9sZSA9IGh1bWFuUHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJhaVwiKSB7XG4gICAgICAgICAgICByb2xlID0gYWlQcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobS5fZ2V0VHlwZSgpID09PSBcInN5c3RlbVwiKSB7XG4gICAgICAgICAgICByb2xlID0gXCJTeXN0ZW1cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLl9nZXRUeXBlKCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcm9sZSA9IFwiRnVuY3Rpb25cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLl9nZXRUeXBlKCkgPT09IFwidG9vbFwiKSB7XG4gICAgICAgICAgICByb2xlID0gXCJUb29sXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobS5fZ2V0VHlwZSgpID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgcm9sZSA9IG0ucm9sZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHVuc3VwcG9ydGVkIG1lc3NhZ2UgdHlwZTogJHttLl9nZXRUeXBlKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZVN0ciA9IG0ubmFtZSA/IGAke20ubmFtZX0sIGAgOiBcIlwiO1xuICAgICAgICBjb25zdCByZWFkYWJsZUNvbnRlbnQgPSB0eXBlb2YgbS5jb250ZW50ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IG0uY29udGVudFxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShtLmNvbnRlbnQsIG51bGwsIDIpO1xuICAgICAgICBzdHJpbmdfbWVzc2FnZXMucHVzaChgJHtyb2xlfTogJHtuYW1lU3RyfSR7cmVhZGFibGVDb250ZW50fWApO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nX21lc3NhZ2VzLmpvaW4oXCJcXG5cIik7XG59XG4vKipcbiAqIE1hcHMgbWVzc2FnZXMgZnJvbSBhbiBvbGRlciBmb3JtYXQgKFYxKSB0byB0aGUgY3VycmVudCBgU3RvcmVkTWVzc2FnZWBcbiAqIGZvcm1hdC4gSWYgdGhlIG1lc3NhZ2UgaXMgYWxyZWFkeSBpbiB0aGUgYFN0b3JlZE1lc3NhZ2VgIGZvcm1hdCwgaXQgaXNcbiAqIHJldHVybmVkIGFzIGlzLiBPdGhlcndpc2UsIGl0IHRyYW5zZm9ybXMgdGhlIFYxIG1lc3NhZ2UgaW50byBhXG4gKiBgU3RvcmVkTWVzc2FnZWAuIFRoaXMgZnVuY3Rpb24gaXMgaW1wb3J0YW50IGZvciBtYWludGFpbmluZ1xuICogY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIG1lc3NhZ2UgZm9ybWF0cy5cbiAqL1xuZnVuY3Rpb24gbWFwVjFNZXNzYWdlVG9TdG9yZWRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBtYXBwZXIgd2hlbiB3ZSBkZXByZWNhdGUgdGhlIG9sZCBtZXNzYWdlIGZvcm1hdC5cbiAgICBpZiAobWVzc2FnZS5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB2MU1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdjFNZXNzYWdlLnR5cGUsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogdjFNZXNzYWdlLnRleHQsXG4gICAgICAgICAgICAgICAgcm9sZTogdjFNZXNzYWdlLnJvbGUsXG4gICAgICAgICAgICAgICAgbmFtZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9pZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gbWFwU3RvcmVkTWVzc2FnZVRvQ2hhdE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IHN0b3JlZE1lc3NhZ2UgPSBtYXBWMU1lc3NhZ2VUb1N0b3JlZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgc3dpdGNoIChzdG9yZWRNZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImh1bWFuXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEh1bWFuTWVzc2FnZShzdG9yZWRNZXNzYWdlLmRhdGEpO1xuICAgICAgICBjYXNlIFwiYWlcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQUlNZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGNhc2UgXCJzeXN0ZW1cIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3lzdGVtTWVzc2FnZShzdG9yZWRNZXNzYWdlLmRhdGEpO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIGlmIChzdG9yZWRNZXNzYWdlLmRhdGEubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmFtZSBtdXN0IGJlIGRlZmluZWQgZm9yIGZ1bmN0aW9uIG1lc3NhZ2VzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbk1lc3NhZ2Uoc3RvcmVkTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgY2FzZSBcInRvb2xcIjpcbiAgICAgICAgICAgIGlmIChzdG9yZWRNZXNzYWdlLmRhdGEudG9vbF9jYWxsX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb29sIGNhbGwgSUQgbXVzdCBiZSBkZWZpbmVkIGZvciB0b29sIG1lc3NhZ2VzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUb29sTWVzc2FnZShzdG9yZWRNZXNzYWdlLmRhdGEpO1xuICAgICAgICBjYXNlIFwiZ2VuZXJpY1wiOiB7XG4gICAgICAgICAgICBpZiAoc3RvcmVkTWVzc2FnZS5kYXRhLnJvbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvbGUgbXVzdCBiZSBkZWZpbmVkIGZvciBjaGF0IG1lc3NhZ2VzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGF0TWVzc2FnZShzdG9yZWRNZXNzYWdlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmV4cGVjdGVkIHR5cGU6ICR7c3RvcmVkTWVzc2FnZS50eXBlfWApO1xuICAgIH1cbn1cbi8qKlxuICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiBgU3RvcmVkTWVzc2FnZWAgaW5zdGFuY2VzIGludG8gYW4gYXJyYXkgb2ZcbiAqIGBCYXNlTWVzc2FnZWAgaW5zdGFuY2VzLiBJdCB1c2VzIHRoZSBgbWFwVjFNZXNzYWdlVG9TdG9yZWRNZXNzYWdlYFxuICogZnVuY3Rpb24gdG8gZW5zdXJlIGFsbCBtZXNzYWdlcyBhcmUgaW4gdGhlIGBTdG9yZWRNZXNzYWdlYCBmb3JtYXQsIHRoZW5cbiAqIGNyZWF0ZXMgbmV3IGluc3RhbmNlcyBvZiB0aGUgYXBwcm9wcmlhdGUgYEJhc2VNZXNzYWdlYCBzdWJjbGFzcyBiYXNlZFxuICogb24gdGhlIHR5cGUgb2YgZWFjaCBtZXNzYWdlLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcHJlcGFyZSBzdG9yZWRcbiAqIG1lc3NhZ2VzIGZvciB1c2UgaW4gYSBjaGF0IGNvbnRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBTdG9yZWRNZXNzYWdlc1RvQ2hhdE1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2VzLm1hcChtYXBTdG9yZWRNZXNzYWdlVG9DaGF0TWVzc2FnZSk7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgYW4gYXJyYXkgb2YgYEJhc2VNZXNzYWdlYCBpbnN0YW5jZXMgaW50byBhbiBhcnJheSBvZlxuICogYFN0b3JlZE1lc3NhZ2VgIGluc3RhbmNlcy4gSXQgZG9lcyB0aGlzIGJ5IGNhbGxpbmcgdGhlIGB0b0RpY3RgIG1ldGhvZFxuICogb24gZWFjaCBgQmFzZU1lc3NhZ2VgLCB3aGljaCByZXR1cm5zIGEgYFN0b3JlZE1lc3NhZ2VgLiBUaGlzIGZ1bmN0aW9uXG4gKiBpcyB1c2VkIHRvIHByZXBhcmUgY2hhdCBtZXNzYWdlcyBmb3Igc3RvcmFnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcENoYXRNZXNzYWdlc1RvU3RvcmVkTWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICByZXR1cm4gbWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiBtZXNzYWdlLnRvRGljdCgpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9DaHVuayhtZXNzYWdlKSB7XG4gICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuX2dldFR5cGUoKTtcbiAgICBpZiAodHlwZSA9PT0gXCJodW1hblwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBIdW1hbk1lc3NhZ2VDaHVuayh7IC4uLm1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiYWlcIikge1xuICAgICAgICBsZXQgYWlDaHVua0ZpZWxkcyA9IHtcbiAgICAgICAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChcInRvb2xfY2FsbHNcIiBpbiBhaUNodW5rRmllbGRzKSB7XG4gICAgICAgICAgICBhaUNodW5rRmllbGRzID0ge1xuICAgICAgICAgICAgICAgIC4uLmFpQ2h1bmtGaWVsZHMsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsX2NodW5rczogYWlDaHVua0ZpZWxkcy50b29sX2NhbGxzPy5tYXAoKHRjKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAuLi50YyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sX2NhbGxfY2h1bmtcIixcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogSlNPTi5zdHJpbmdpZnkodGMuYXJncyksXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgQUlNZXNzYWdlQ2h1bmsoeyAuLi5haUNodW5rRmllbGRzIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcInN5c3RlbVwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBTeXN0ZW1NZXNzYWdlQ2h1bmsoeyAuLi5tZXNzYWdlIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uTWVzc2FnZUNodW5rKHsgLi4ubWVzc2FnZSB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgIH1cbiAgICBlbHNlIGlmIChDaGF0TWVzc2FnZS5pc0luc3RhbmNlKG1lc3NhZ2UpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0TWVzc2FnZUNodW5rKHsgLi4ubWVzc2FnZSB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbWVzc2FnZSB0eXBlLlwiKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/utils.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/outputs.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/outputs.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatGenerationChunk: () => (/* binding */ ChatGenerationChunk),\n/* harmony export */   GenerationChunk: () => (/* binding */ GenerationChunk),\n/* harmony export */   RUN_KEY: () => (/* binding */ RUN_KEY)\n/* harmony export */ });\nconst RUN_KEY = \"__run\";\n/**\n * Chunk of a single generation. Used for streaming.\n */\nclass GenerationChunk {\n    constructor(fields) {\n        Object.defineProperty(this, \"text\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"generationInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.text = fields.text;\n        this.generationInfo = fields.generationInfo;\n    }\n    concat(chunk) {\n        return new GenerationChunk({\n            text: this.text + chunk.text,\n            generationInfo: {\n                ...this.generationInfo,\n                ...chunk.generationInfo,\n            },\n        });\n    }\n}\nclass ChatGenerationChunk extends GenerationChunk {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"message\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.message = fields.message;\n    }\n    concat(chunk) {\n        return new ChatGenerationChunk({\n            text: this.text + chunk.text,\n            generationInfo: {\n                ...this.generationInfo,\n                ...chunk.generationInfo,\n            },\n            message: this.message.concat(chunk.message),\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L291dHB1dHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFx0ZXh0c3BsaXR0ZXJzXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXG91dHB1dHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFJVTl9LRVkgPSBcIl9fcnVuXCI7XG4vKipcbiAqIENodW5rIG9mIGEgc2luZ2xlIGdlbmVyYXRpb24uIFVzZWQgZm9yIHN0cmVhbWluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIEdlbmVyYXRpb25DaHVuayB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRleHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2VuZXJhdGlvbkluZm9cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50ZXh0ID0gZmllbGRzLnRleHQ7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGlvbkluZm8gPSBmaWVsZHMuZ2VuZXJhdGlvbkluZm87XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnRleHQgKyBjaHVuay50ZXh0LFxuICAgICAgICAgICAgZ2VuZXJhdGlvbkluZm86IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmdlbmVyYXRpb25JbmZvLFxuICAgICAgICAgICAgICAgIC4uLmNodW5rLmdlbmVyYXRpb25JbmZvLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENoYXRHZW5lcmF0aW9uQ2h1bmsgZXh0ZW5kcyBHZW5lcmF0aW9uQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGZpZWxkcy5tZXNzYWdlO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCArIGNodW5rLnRleHQsXG4gICAgICAgICAgICBnZW5lcmF0aW9uSW5mbzoge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgLi4uY2h1bmsuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLmNvbmNhdChjaHVuay5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/outputs.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/base.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/base.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Runnable: () => (/* binding */ Runnable),\n/* harmony export */   RunnableAssign: () => (/* binding */ RunnableAssign),\n/* harmony export */   RunnableBinding: () => (/* binding */ RunnableBinding),\n/* harmony export */   RunnableEach: () => (/* binding */ RunnableEach),\n/* harmony export */   RunnableLambda: () => (/* binding */ RunnableLambda),\n/* harmony export */   RunnableMap: () => (/* binding */ RunnableMap),\n/* harmony export */   RunnableParallel: () => (/* binding */ RunnableParallel),\n/* harmony export */   RunnablePick: () => (/* binding */ RunnablePick),\n/* harmony export */   RunnableRetry: () => (/* binding */ RunnableRetry),\n/* harmony export */   RunnableSequence: () => (/* binding */ RunnableSequence),\n/* harmony export */   RunnableToolLike: () => (/* binding */ RunnableToolLike),\n/* harmony export */   RunnableTraceable: () => (/* binding */ RunnableTraceable),\n/* harmony export */   RunnableWithFallbacks: () => (/* binding */ RunnableWithFallbacks),\n/* harmony export */   _coerceToDict: () => (/* binding */ _coerceToDict),\n/* harmony export */   _coerceToRunnable: () => (/* binding */ _coerceToRunnable),\n/* harmony export */   convertRunnableToTool: () => (/* binding */ convertRunnableToTool)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/lib/index.mjs\");\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(action-browser)/./node_modules/p-retry/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! uuid */ \"(action-browser)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! langsmith/singletons/traceable */ \"(action-browser)/./node_modules/langsmith/singletons/traceable.js\");\n/* harmony import */ var _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tracers/log_stream.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/log_stream.js\");\n/* harmony import */ var _tracers_event_stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tracers/event_stream.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/event_stream.js\");\n/* harmony import */ var _load_serializable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../load/serializable.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/load/serializable.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/stream.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/stream.js\");\n/* harmony import */ var _utils_signal_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/signal.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/signal.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./config.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/config.js\");\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/async_caller.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/async_caller.js\");\n/* harmony import */ var _tracers_root_listener_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../tracers/root_listener.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/root_listener.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/utils.js\");\n/* harmony import */ var _singletons_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../singletons/index.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/singletons/index.js\");\n/* harmony import */ var _graph_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./graph.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/graph.js\");\n/* harmony import */ var _wrappers_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./wrappers.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/wrappers.js\");\n/* harmony import */ var _iter_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./iter.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/iter.js\");\n/* harmony import */ var _tools_utils_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../tools/utils.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tools/utils.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value &&\n        !Array.isArray(value) &&\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        !(value instanceof Date) &&\n        typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nclass Runnable extends _load_serializable_js__WEBPACK_IMPORTED_MODULE_4__.Serializable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    getName(suffix) {\n        const name = \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.name ?? this.constructor.lc_name() ?? this.constructor.name;\n        return suffix ? `${name}${suffix}` : name;\n    }\n    /**\n     * Bind arguments to a Runnable, returning a new Runnable.\n     * @param kwargs\n     * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n     */\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({ bound: this, kwargs, config: {} });\n    }\n    /**\n     * Return a new Runnable that maps a list of inputs to a list of outputs,\n     * by calling invoke() with each input.\n     */\n    map() {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableEach({ bound: this });\n    }\n    /**\n     * Add retry logic to an existing runnable.\n     * @param kwargs\n     * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n     */\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableRetry({\n            bound: this,\n            kwargs: {},\n            config: {},\n            maxAttemptNumber: fields?.stopAfterAttempt,\n            ...fields,\n        });\n    }\n    /**\n     * Bind config to a Runnable, returning a new Runnable.\n     * @param config New configuration parameters to attach to the new runnable.\n     * @returns A new RunnableBinding with a config matching what's passed.\n     */\n    withConfig(config) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config,\n            kwargs: {},\n        });\n    }\n    /**\n     * Create a new runnable from the current one that will try invoking\n     * other passed fallback runnables if the initial invocation fails.\n     * @param fields.fallbacks Other runnables to call if the runnable errors.\n     * @returns A new RunnableWithFallbacks.\n     */\n    withFallbacks(fields) {\n        const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableWithFallbacks({\n            runnable: this,\n            fallbacks,\n        });\n    }\n    _getOptionsList(options, length = 0) {\n        if (Array.isArray(options) && options.length !== length) {\n            throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n        }\n        if (Array.isArray(options)) {\n            return options.map(_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig);\n        }\n        if (length > 1 && !Array.isArray(options) && options.runId) {\n            console.warn(\"Provided runId will be used only for the first element of the batch.\");\n            const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== \"runId\"));\n            return Array.from({ length }, (_, i) => (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(i === 0 ? options : subsequent));\n        }\n        return Array.from({ length }, () => (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options));\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_8__.AsyncCaller({\n            maxConcurrency,\n            onFailedAttempt: (e) => {\n                throw e;\n            },\n        });\n        const batchCalls = inputs.map((input, i) => caller.call(async () => {\n            try {\n                const result = await this.invoke(input, configList[i]);\n                return result;\n            }\n            catch (e) {\n                if (batchOptions?.returnExceptions) {\n                    return e;\n                }\n                throw e;\n            }\n        }));\n        return Promise.all(batchCalls);\n    }\n    /**\n     * Default streaming implementation.\n     * Subclasses should override this method if they support streaming output.\n     * @param input\n     * @param options\n     */\n    async *_streamIterator(input, options) {\n        yield this.invoke(input, options);\n    }\n    /**\n     * Stream output in chunks.\n     * @param input\n     * @param options\n     * @returns A readable stream that is also an iterable.\n     */\n    async stream(input, options) {\n        // Buffer the first streamed chunk to allow for initial errors\n        // to surface immediately.\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.AsyncGeneratorWithSetup({\n            generator: this._streamIterator(input, config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n    _separateRunnableConfigFromCallOptions(options) {\n        let runnableConfig;\n        if (options === undefined) {\n            runnableConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        }\n        else {\n            runnableConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)({\n                callbacks: options.callbacks,\n                tags: options.tags,\n                metadata: options.metadata,\n                runName: options.runName,\n                configurable: options.configurable,\n                recursionLimit: options.recursionLimit,\n                maxConcurrency: options.maxConcurrency,\n                runId: options.runId,\n                timeout: options.timeout,\n                signal: options.signal,\n            });\n        }\n        const callOptions = { ...options };\n        delete callOptions.callbacks;\n        delete callOptions.tags;\n        delete callOptions.metadata;\n        delete callOptions.runName;\n        delete callOptions.configurable;\n        delete callOptions.recursionLimit;\n        delete callOptions.maxConcurrency;\n        delete callOptions.runId;\n        delete callOptions.timeout;\n        delete callOptions.signal;\n        return [runnableConfig, callOptions];\n    }\n    async _callWithConfig(func, input, options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, config?.runType, undefined, undefined, config?.runName ?? this.getName());\n        delete config.runId;\n        let output;\n        try {\n            const promise = func.call(this, input, config, runManager);\n            output = await (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, options?.signal);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n    }\n    /**\n     * Internal method that handles batching and configuration for a runnable\n     * It takes a function, input values, and optional configuration, and\n     * returns a promise that resolves to the output values.\n     * @param func The function to be executed for each input value.\n     * @param input The input values to be processed.\n     * @param config Optional configuration for the function execution.\n     * @returns A promise that resolves to the output values.\n     */\n    async _batchWithConfig(func, inputs, options, batchOptions) {\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(optionsList.map(_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), optionsList[i].runId, optionsList[i].runType, undefined, undefined, optionsList[i].runName ?? this.getName());\n            delete optionsList[i].runId;\n            return handleStartRes;\n        }));\n        let outputs;\n        try {\n            const promise = func.call(this, inputs, optionsList, runManagers, batchOptions);\n            outputs = await (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, optionsList?.[0]?.signal);\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))));\n        return outputs;\n    }\n    /**\n     * Helper method to transform an Iterator of Input values into an Iterator of\n     * Output values, with callbacks.\n     * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n     */\n    async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n        let finalInput;\n        let finalInputSupported = true;\n        let finalOutput;\n        let finalOutputSupported = true;\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config);\n        async function* wrapInputForTracing() {\n            for await (const chunk of inputGenerator) {\n                if (finalInputSupported) {\n                    if (finalInput === undefined) {\n                        finalInput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalInput = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(finalInput, chunk);\n                        }\n                        catch {\n                            finalInput = undefined;\n                            finalInputSupported = false;\n                        }\n                    }\n                }\n                yield chunk;\n            }\n        }\n        let runManager;\n        try {\n            const pipe = await (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.pipeGeneratorWithSetup)(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), { input: \"\" }, config.runId, config.runType, undefined, undefined, config.runName ?? this.getName()), options?.signal, config);\n            delete config.runId;\n            runManager = pipe.setup;\n            const streamEventsHandler = runManager?.handlers.find(_tracers_event_stream_js__WEBPACK_IMPORTED_MODULE_3__.isStreamEventsHandler);\n            let iterator = pipe.output;\n            if (streamEventsHandler !== undefined && runManager !== undefined) {\n                iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);\n            }\n            const streamLogHandler = runManager?.handlers.find(_tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.isLogStreamHandler);\n            if (streamLogHandler !== undefined && runManager !== undefined) {\n                iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);\n            }\n            for await (const chunk of iterator) {\n                yield chunk;\n                if (finalOutputSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(finalOutput, chunk);\n                        }\n                        catch {\n                            finalOutput = undefined;\n                            finalOutputSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e, undefined, undefined, undefined, {\n                inputs: _coerceToDict(finalInput, \"input\"),\n            });\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, { inputs: _coerceToDict(finalInput, \"input\") });\n    }\n    getGraph(_) {\n        const graph = new _graph_js__WEBPACK_IMPORTED_MODULE_12__.Graph();\n        // TODO: Add input schema for runnables\n        const inputNode = graph.addNode({\n            name: `${this.getName()}Input`,\n            schema: zod__WEBPACK_IMPORTED_MODULE_16__.z.any(),\n        });\n        const runnableNode = graph.addNode(this);\n        // TODO: Add output schemas for runnables\n        const outputNode = graph.addNode({\n            name: `${this.getName()}Output`,\n            schema: zod__WEBPACK_IMPORTED_MODULE_16__.z.any(),\n        });\n        graph.addEdge(inputNode, runnableNode);\n        graph.addEdge(runnableNode, outputNode);\n        return graph;\n    }\n    /**\n     * Create a new runnable sequence that runs each individual runnable in series,\n     * piping the output of one runnable into another runnable or runnable-like.\n     * @param coerceable A runnable, function, or object whose values are functions or runnables.\n     * @returns A new runnable sequence.\n     */\n    pipe(coerceable) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableSequence({\n            first: this,\n            last: _coerceToRunnable(coerceable),\n        });\n    }\n    /**\n     * Pick keys from the dict output of this runnable. Returns a new runnable.\n     */\n    pick(keys) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return this.pipe(new RunnablePick(keys));\n    }\n    /**\n     * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n     */\n    assign(mapping) {\n        return this.pipe(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableAssign(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableMap({ steps: mapping })));\n    }\n    /**\n     * Default implementation of transform, which buffers input and then calls stream.\n     * Subclasses should override this method if they can start producing output while\n     * input is still being generated.\n     * @param generator\n     * @param options\n     */\n    async *transform(generator, options) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                // This method should throw an error if gathering fails.\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                finalChunk = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(finalChunk, chunk);\n            }\n        }\n        yield* this._streamIterator(finalChunk, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options));\n    }\n    /**\n     * Stream all output from a runnable, as reported to the callback system.\n     * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n     * Output is streamed as Log objects, which include a list of\n     * jsonpatch ops that describe how the state of the run has changed in each\n     * step, and the final state of the run.\n     * The jsonpatch ops can be applied in order to construct state.\n     * @param input\n     * @param options\n     * @param streamOptions\n     */\n    async *streamLog(input, options, streamOptions) {\n        const logStreamCallbackHandler = new _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"original\",\n        });\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        yield* this._streamLog(input, logStreamCallbackHandler, config);\n    }\n    async *_streamLog(input, logStreamCallbackHandler, config) {\n        const { callbacks } = config;\n        if (callbacks === undefined) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = [logStreamCallbackHandler];\n        }\n        else if (Array.isArray(callbacks)) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.addHandler(logStreamCallbackHandler, true);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        const runnableStreamPromise = this.stream(input, config);\n        async function consumeRunnableStream() {\n            try {\n                const runnableStream = await runnableStreamPromise;\n                for await (const chunk of runnableStream) {\n                    const patch = new _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: \"/streamed_output/-\",\n                                value: chunk,\n                            },\n                        ],\n                    });\n                    await logStreamCallbackHandler.writer.write(patch);\n                }\n            }\n            finally {\n                await logStreamCallbackHandler.writer.close();\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        try {\n            for await (const log of logStreamCallbackHandler) {\n                yield log;\n            }\n        }\n        finally {\n            await runnableStreamConsumePromise;\n        }\n    }\n    streamEvents(input, options, streamOptions) {\n        let stream;\n        if (options.version === \"v1\") {\n            stream = this._streamEventsV1(input, options, streamOptions);\n        }\n        else if (options.version === \"v2\") {\n            stream = this._streamEventsV2(input, options, streamOptions);\n        }\n        else {\n            throw new Error(`Only versions \"v1\" and \"v2\" of the schema are currently supported.`);\n        }\n        if (options.encoding === \"text/event-stream\") {\n            return (0,_wrappers_js__WEBPACK_IMPORTED_MODULE_13__.convertToHttpEventStream)(stream);\n        }\n        else {\n            return _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(stream);\n        }\n    }\n    async *_streamEventsV2(input, options, streamOptions) {\n        const eventStreamer = new _tracers_event_stream_js__WEBPACK_IMPORTED_MODULE_3__.EventStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n        });\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const runId = config.runId ?? (0,uuid__WEBPACK_IMPORTED_MODULE_17__[\"default\"])();\n        config.runId = runId;\n        const callbacks = config.callbacks;\n        if (callbacks === undefined) {\n            config.callbacks = [eventStreamer];\n        }\n        else if (Array.isArray(callbacks)) {\n            config.callbacks = callbacks.concat(eventStreamer);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.addHandler(eventStreamer, true);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        // Call the runnable in streaming mode,\n        // add each chunk to the output stream\n        const outerThis = this;\n        async function consumeRunnableStream() {\n            try {\n                const runnableStream = await outerThis.stream(input, config);\n                const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                for await (const _ of tappedStream) {\n                    // Just iterate so that the callback handler picks up events\n                }\n            }\n            finally {\n                await eventStreamer.finish();\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        let firstEventSent = false;\n        let firstEventRunId;\n        try {\n            for await (const event of eventStreamer) {\n                // This is a work-around an issue where the inputs into the\n                // chain are not available until the entire input is consumed.\n                // As a temporary solution, we'll modify the input to be the input\n                // that was passed into the chain.\n                if (!firstEventSent) {\n                    event.data.input = input;\n                    firstEventSent = true;\n                    firstEventRunId = event.run_id;\n                    yield event;\n                    continue;\n                }\n                if (event.run_id === firstEventRunId && event.event.endsWith(\"_end\")) {\n                    // If it's the end event corresponding to the root runnable\n                    // we dont include the input in the event since it's guaranteed\n                    // to be included in the first event.\n                    if (event.data?.input) {\n                        delete event.data.input;\n                    }\n                }\n                yield event;\n            }\n        }\n        finally {\n            await runnableStreamConsumePromise;\n        }\n    }\n    async *_streamEventsV1(input, options, streamOptions) {\n        let runLog;\n        let hasEncounteredStartEvent = false;\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const rootTags = config.tags ?? [];\n        const rootMetadata = config.metadata ?? {};\n        const rootName = config.runName ?? this.getName();\n        const logStreamCallbackHandler = new _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"streaming_events\",\n        });\n        const rootEventFilter = new _utils_js__WEBPACK_IMPORTED_MODULE_10__._RootEventFilter({\n            ...streamOptions,\n        });\n        const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n        for await (const log of logStream) {\n            if (!runLog) {\n                runLog = _tracers_log_stream_js__WEBPACK_IMPORTED_MODULE_2__.RunLog.fromRunLogPatch(log);\n            }\n            else {\n                runLog = runLog.concat(log);\n            }\n            if (runLog.state === undefined) {\n                throw new Error(`Internal error: \"streamEvents\" state is missing. Please open a bug report.`);\n            }\n            // Yield the start event for the root runnable if it hasn't been seen.\n            // The root run is never filtered out\n            if (!hasEncounteredStartEvent) {\n                hasEncounteredStartEvent = true;\n                const state = { ...runLog.state };\n                const event = {\n                    run_id: state.id,\n                    event: `on_${state.type}_start`,\n                    name: rootName,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    data: {\n                        input,\n                    },\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n            const paths = log.ops\n                .filter((op) => op.path.startsWith(\"/logs/\"))\n                .map((op) => op.path.split(\"/\")[2]);\n            const dedupedPaths = [...new Set(paths)];\n            for (const path of dedupedPaths) {\n                let eventType;\n                let data = {};\n                const logEntry = runLog.state.logs[path];\n                if (logEntry.end_time === undefined) {\n                    if (logEntry.streamed_output.length > 0) {\n                        eventType = \"stream\";\n                    }\n                    else {\n                        eventType = \"start\";\n                    }\n                }\n                else {\n                    eventType = \"end\";\n                }\n                if (eventType === \"start\") {\n                    // Include the inputs with the start event if they are available.\n                    // Usually they will NOT be available for components that operate\n                    // on streams, since those components stream the input and\n                    // don't know its final value until the end of the stream.\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                }\n                else if (eventType === \"end\") {\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                    data.output = logEntry.final_output;\n                }\n                else if (eventType === \"stream\") {\n                    const chunkCount = logEntry.streamed_output.length;\n                    if (chunkCount !== 1) {\n                        throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`);\n                    }\n                    data = { chunk: logEntry.streamed_output[0] };\n                    // Clean up the stream, we don't need it anymore.\n                    // And this avoids duplicates as well!\n                    logEntry.streamed_output = [];\n                }\n                yield {\n                    event: `on_${logEntry.type}_${eventType}`,\n                    name: logEntry.name,\n                    run_id: logEntry.id,\n                    tags: logEntry.tags,\n                    metadata: logEntry.metadata,\n                    data,\n                };\n            }\n            // Finally, we take care of the streaming output from the root chain\n            // if there is any.\n            const { state } = runLog;\n            if (state.streamed_output.length > 0) {\n                const chunkCount = state.streamed_output.length;\n                if (chunkCount !== 1) {\n                    throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`);\n                }\n                const data = { chunk: state.streamed_output[0] };\n                // Clean up the stream, we don't need it anymore.\n                state.streamed_output = [];\n                const event = {\n                    event: `on_${state.type}_stream`,\n                    run_id: state.id,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    name: rootName,\n                    data,\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n        }\n        const state = runLog?.state;\n        if (state !== undefined) {\n            // Finally, yield the end event for the root runnable.\n            const event = {\n                event: `on_${state.type}_end`,\n                name: rootName,\n                run_id: state.id,\n                tags: rootTags,\n                metadata: rootMetadata,\n                data: {\n                    output: state.final_output,\n                },\n            };\n            if (rootEventFilter.includeEvent(event, state.type))\n                yield event;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnable(thing) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_10__.isRunnableInterface)(thing);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config: {},\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new _tracers_root_listener_js__WEBPACK_IMPORTED_MODULE_9__.RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n    /**\n     * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`\n     * which contains the runnable, name, description and schema.\n     *\n     * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.\n     *\n     * @param fields\n     * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n     * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n     * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n     * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n     */\n    asTool(fields) {\n        return convertRunnableToTool(this, fields);\n    }\n}\n/**\n * A runnable that delegates calls to another runnable with a set of kwargs.\n */\nclass RunnableBinding extends Runnable {\n    static lc_name() {\n        return \"RunnableBinding\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"configFactories\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n        this.kwargs = fields.kwargs;\n        this.config = fields.config;\n        this.configFactories = fields.configFactories;\n    }\n    getName(suffix) {\n        return this.bound.getName(suffix);\n    }\n    async _mergeConfig(...options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.mergeConfigs)(this.config, ...options);\n        return (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.mergeConfigs)(config, ...(this.configFactories\n            ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config)))\n            : []));\n    }\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: { ...this.kwargs, ...kwargs },\n            config: this.config,\n        });\n    }\n    withConfig(config) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: { ...this.config, ...config },\n        });\n    }\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound.withRetry(fields),\n            kwargs: this.kwargs,\n            config: this.config,\n        });\n    }\n    async invoke(input, options) {\n        return this.bound.invoke(input, await this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), this.kwargs));\n    }\n    async batch(inputs, options, batchOptions) {\n        const mergedOptions = Array.isArray(options)\n            ? await Promise.all(options.map(async (individualOption) => this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(individualOption), this.kwargs)))\n            : await this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), this.kwargs);\n        return this.bound.batch(inputs, mergedOptions, batchOptions);\n    }\n    async *_streamIterator(input, options) {\n        yield* this.bound._streamIterator(input, await this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), this.kwargs));\n    }\n    async stream(input, options) {\n        return this.bound.stream(input, await this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), this.kwargs));\n    }\n    async *transform(generator, options) {\n        yield* this.bound.transform(generator, await this._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), this.kwargs));\n    }\n    streamEvents(input, options, streamOptions) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const outerThis = this;\n        const generator = async function* () {\n            yield* outerThis.bound.streamEvents(input, {\n                ...(await outerThis._mergeConfig((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options), outerThis.kwargs)),\n                version: options.version,\n            }, streamOptions);\n        };\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(generator());\n    }\n    static isRunnableBinding(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    thing\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        return thing.bound && Runnable.isRunnable(thing.bound);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableBinding({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new _tracers_root_listener_js__WEBPACK_IMPORTED_MODULE_9__.RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n}\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n */\nclass RunnableEach extends Runnable {\n    static lc_name() {\n        return \"RunnableEach\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n    }\n    /**\n     * Binds the runnable with the specified arguments.\n     * @param kwargs The arguments to bind the runnable with.\n     * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.\n     */\n    bind(kwargs) {\n        return new RunnableEach({\n            bound: this.bound.bind(kwargs),\n        });\n    }\n    /**\n     * Invokes the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(inputs, config) {\n        return this._callWithConfig(this._invoke, inputs, config);\n    }\n    /**\n     * A helper method that is used to invoke the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async _invoke(inputs, config, runManager) {\n        return this.bound.batch(inputs, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, { callbacks: runManager?.getChild() }));\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableEach({\n            bound: this.bound.withListeners({ onStart, onEnd, onError }),\n        });\n    }\n}\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n */\nclass RunnableRetry extends RunnableBinding {\n    static lc_name() {\n        return \"RunnableRetry\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"maxAttemptNumber\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 3\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"onFailedAttempt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: () => { }\n        });\n        this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n        this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n    }\n    _patchConfigForRetry(attempt, config, runManager) {\n        const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n        return (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, { callbacks: runManager?.getChild(tag) });\n    }\n    async _invoke(input, config, runManager) {\n        return p_retry__WEBPACK_IMPORTED_MODULE_0__((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onFailedAttempt: (error) => this.onFailedAttempt(error, input),\n            retries: Math.max(this.maxAttemptNumber - 1, 0),\n            randomize: true,\n        });\n    }\n    /**\n     * Method that invokes the runnable with the specified input, run manager,\n     * and config. It handles the retry logic by catching any errors and\n     * recursively invoking itself with the updated config for the next retry\n     * attempt.\n     * @param input The input for the runnable.\n     * @param runManager The run manager for the runnable.\n     * @param config The config for the runnable.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(input, config) {\n        return this._callWithConfig(this._invoke, input, config);\n    }\n    async _batch(inputs, configs, runManagers, batchOptions) {\n        const resultsMap = {};\n        try {\n            await p_retry__WEBPACK_IMPORTED_MODULE_0__(async (attemptNumber) => {\n                const remainingIndexes = inputs\n                    .map((_, i) => i)\n                    .filter((i) => resultsMap[i.toString()] === undefined ||\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    resultsMap[i.toString()] instanceof Error);\n                const remainingInputs = remainingIndexes.map((i) => inputs[i]);\n                const patchedConfigs = remainingIndexes.map((i) => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));\n                const results = await super.batch(remainingInputs, patchedConfigs, {\n                    ...batchOptions,\n                    returnExceptions: true,\n                });\n                let firstException;\n                for (let i = 0; i < results.length; i += 1) {\n                    const result = results[i];\n                    const resultMapIndex = remainingIndexes[i];\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (result instanceof Error) {\n                        if (firstException === undefined) {\n                            firstException = result;\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            firstException.input = remainingInputs[i];\n                        }\n                    }\n                    resultsMap[resultMapIndex.toString()] = result;\n                }\n                if (firstException) {\n                    throw firstException;\n                }\n                return results;\n            }, {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                onFailedAttempt: (error) => this.onFailedAttempt(error, error.input),\n                retries: Math.max(this.maxAttemptNumber - 1, 0),\n                randomize: true,\n            });\n        }\n        catch (e) {\n            if (batchOptions?.returnExceptions !== true) {\n                throw e;\n            }\n        }\n        return Object.keys(resultsMap)\n            .sort((a, b) => parseInt(a, 10) - parseInt(b, 10))\n            .map((key) => resultsMap[parseInt(key, 10)]);\n    }\n    async batch(inputs, options, batchOptions) {\n        return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n    }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({})]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nclass RunnableSequence extends Runnable {\n    static lc_name() {\n        return \"RunnableSequence\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"first\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"middle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"last\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        this.first = fields.first;\n        this.middle = fields.middle ?? this.middle;\n        this.last = fields.last;\n        this.name = fields.name;\n    }\n    get steps() {\n        return [this.first, ...this.middle, this.last];\n    }\n    async invoke(input, options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        let nextStepInput = input;\n        let finalOutput;\n        try {\n            const initialSteps = [this.first, ...this.middle];\n            for (let i = 0; i < initialSteps.length; i += 1) {\n                const step = initialSteps[i];\n                const promise = step.invoke(nextStepInput, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {\n                    callbacks: runManager?.getChild(`seq:step:${i + 1}`),\n                }));\n                nextStepInput = await (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, options?.signal);\n            }\n            // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n            if (options?.signal?.aborted) {\n                throw new Error(\"Aborted\");\n            }\n            finalOutput = await this.last.invoke(nextStepInput, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {\n                callbacks: runManager?.getChild(`seq:step:${this.steps.length}`),\n            }));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n        return finalOutput;\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map(_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let nextStepInputs = inputs;\n        try {\n            for (let i = 0; i < this.steps.length; i += 1) {\n                const step = this.steps[i];\n                const promise = step.batch(nextStepInputs, runManagers.map((runManager, j) => {\n                    const childRunManager = runManager?.getChild(`seq:step:${i + 1}`);\n                    return (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(configList[j], { callbacks: childRunManager });\n                }), batchOptions);\n                nextStepInputs = await (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, configList[0]?.signal);\n            }\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))));\n        return nextStepInputs;\n    }\n    async *_streamIterator(input, options) {\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(options);\n        const { runId, ...otherOptions } = options ?? {};\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherOptions?.runName);\n        const steps = [this.first, ...this.middle, this.last];\n        let concatSupported = true;\n        let finalOutput;\n        async function* inputGenerator() {\n            yield input;\n        }\n        try {\n            let finalGenerator = steps[0].transform(inputGenerator(), (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(otherOptions, {\n                callbacks: runManager?.getChild(`seq:step:1`),\n            }));\n            for (let i = 1; i < steps.length; i += 1) {\n                const step = steps[i];\n                finalGenerator = await step.transform(finalGenerator, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(otherOptions, {\n                    callbacks: runManager?.getChild(`seq:step:${i + 1}`),\n                }));\n            }\n            for await (const chunk of finalGenerator) {\n                options?.signal?.throwIfAborted();\n                yield chunk;\n                if (concatSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(finalOutput, chunk);\n                        }\n                        catch (e) {\n                            finalOutput = undefined;\n                            concatSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    }\n    getGraph(config) {\n        const graph = new _graph_js__WEBPACK_IMPORTED_MODULE_12__.Graph();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let currentLastNode = null;\n        this.steps.forEach((step, index) => {\n            const stepGraph = step.getGraph(config);\n            if (index !== 0) {\n                stepGraph.trimFirstNode();\n            }\n            if (index !== this.steps.length - 1) {\n                stepGraph.trimLastNode();\n            }\n            graph.extend(stepGraph);\n            const stepFirstNode = stepGraph.firstNode();\n            if (!stepFirstNode) {\n                throw new Error(`Runnable ${step} has no first node`);\n            }\n            if (currentLastNode) {\n                graph.addEdge(currentLastNode, stepFirstNode);\n            }\n            currentLastNode = stepGraph.lastNode();\n        });\n        return graph;\n    }\n    pipe(coerceable) {\n        if (RunnableSequence.isRunnableSequence(coerceable)) {\n            return new RunnableSequence({\n                first: this.first,\n                middle: this.middle.concat([\n                    this.last,\n                    coerceable.first,\n                    ...coerceable.middle,\n                ]),\n                last: coerceable.last,\n                name: this.name ?? coerceable.name,\n            });\n        }\n        else {\n            return new RunnableSequence({\n                first: this.first,\n                middle: [...this.middle, this.last],\n                last: _coerceToRunnable(coerceable),\n                name: this.name,\n            });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnableSequence(thing) {\n        return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from([first, ...runnables], name) {\n        return new RunnableSequence({\n            first: _coerceToRunnable(first),\n            middle: runnables.slice(0, -1).map(_coerceToRunnable),\n            last: _coerceToRunnable(runnables[runnables.length - 1]),\n            name,\n        });\n    }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nclass RunnableMap extends Runnable {\n    static lc_name() {\n        return \"RunnableMap\";\n    }\n    getStepsKeys() {\n        return Object.keys(this.steps);\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"steps\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.steps = {};\n        for (const [key, value] of Object.entries(fields.steps)) {\n            this.steps[key] = _coerceToRunnable(value);\n        }\n    }\n    static from(steps) {\n        return new RunnableMap({ steps });\n    }\n    async invoke(input, options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n            input,\n        }, config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const output = {};\n        try {\n            const promises = Object.entries(this.steps).map(async ([key, runnable]) => {\n                output[key] = await runnable.invoke(input, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {\n                    callbacks: runManager?.getChild(`map:key:${key}`),\n                }));\n            });\n            await (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(Promise.all(promises), options?.signal);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(output);\n        return output;\n    }\n    async *_transform(generator, runManager, options) {\n        // shallow copy steps to ignore changes while iterating\n        const steps = { ...this.steps };\n        // each step gets a copy of the input iterator\n        const inputCopies = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.atee)(generator, Object.keys(steps).length);\n        // start the first iteration of each output iterator\n        const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {\n            const gen = runnable.transform(inputCopies[i], (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(options, {\n                callbacks: runManager?.getChild(`map:key:${key}`),\n            }));\n            return [key, gen.next().then((result) => ({ key, gen, result }))];\n        }));\n        // yield chunks as they become available,\n        // starting new iterations as needed,\n        // until all iterators are done\n        while (tasks.size) {\n            const promise = Promise.race(tasks.values());\n            const { key, result, gen } = await (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, options?.signal);\n            tasks.delete(key);\n            if (!result.done) {\n                yield { [key]: result.value };\n                tasks.set(key, gen.next().then((result) => ({ key, gen, result })));\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that wraps a traced LangSmith function.\n */\nclass RunnableTraceable extends Runnable {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (!(0,langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_1__.isTraceableFunction)(fields.func)) {\n            throw new Error(\"RunnableTraceable requires a function that is wrapped in traceable higher-order function\");\n        }\n        this.func = fields.func;\n    }\n    async invoke(input, options) {\n        const [config] = this._getOptionsList(options ?? {}, 1);\n        const callbacks = await (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config);\n        const promise = this.func((0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, { callbacks }), input);\n        return (0,_utils_signal_js__WEBPACK_IMPORTED_MODULE_6__.raceWithSignal)(promise, config?.signal);\n    }\n    async *_streamIterator(input, options) {\n        const [config] = this._getOptionsList(options ?? {}, 1);\n        const result = await this.invoke(input, options);\n        if ((0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isAsyncIterable)(result)) {\n            for await (const item of result) {\n                config?.signal?.throwIfAborted();\n                yield item;\n            }\n            return;\n        }\n        if ((0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isIterator)(result)) {\n            while (true) {\n                config?.signal?.throwIfAborted();\n                const state = result.next();\n                if (state.done)\n                    break;\n                yield state.value;\n            }\n            return;\n        }\n        yield result;\n    }\n    static from(func) {\n        return new RunnableTraceable({ func });\n    }\n}\nfunction assertNonTraceableFunction(func) {\n    if ((0,langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_1__.isTraceableFunction)(func)) {\n        throw new Error(\"RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.\");\n    }\n}\n/**\n * A runnable that runs a callable.\n */\nclass RunnableLambda extends Runnable {\n    static lc_name() {\n        return \"RunnableLambda\";\n    }\n    constructor(fields) {\n        if ((0,langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_1__.isTraceableFunction)(fields.func)) {\n            // eslint-disable-next-line no-constructor-return\n            return RunnableTraceable.from(fields.func);\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        assertNonTraceableFunction(fields.func);\n        this.func = fields.func;\n    }\n    static from(func) {\n        return new RunnableLambda({\n            func,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        return new Promise((resolve, reject) => {\n            const childConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {\n                callbacks: runManager?.getChild(),\n                recursionLimit: (config?.recursionLimit ?? _config_js__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_RECURSION_LIMIT) - 1,\n            });\n            void _singletons_index_js__WEBPACK_IMPORTED_MODULE_11__.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n                try {\n                    let output = await this.func(input, {\n                        ...childConfig,\n                        config: childConfig,\n                    });\n                    if (output && Runnable.isRunnable(output)) {\n                        if (config?.recursionLimit === 0) {\n                            throw new Error(\"Recursion limit reached.\");\n                        }\n                        output = await output.invoke(input, {\n                            ...childConfig,\n                            recursionLimit: (childConfig.recursionLimit ?? _config_js__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_RECURSION_LIMIT) - 1,\n                        });\n                    }\n                    else if ((0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isAsyncIterable)(output)) {\n                        let finalOutput;\n                        for await (const chunk of (0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.consumeAsyncIterableInContext)(childConfig, output)) {\n                            config?.signal?.throwIfAborted();\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    finalOutput = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    else if ((0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isIterableIterator)(output)) {\n                        let finalOutput;\n                        for (const chunk of (0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.consumeIteratorInContext)(childConfig, output)) {\n                            config?.signal?.throwIfAborted();\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    finalOutput = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    resolve(output);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._invoke, input, options);\n    }\n    async *_transform(generator, runManager, config) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    finalChunk = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(finalChunk, chunk);\n                }\n                catch (e) {\n                    finalChunk = chunk;\n                }\n            }\n        }\n        const childConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(config, {\n            callbacks: runManager?.getChild(),\n            recursionLimit: (config?.recursionLimit ?? _config_js__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_RECURSION_LIMIT) - 1,\n        });\n        const output = await new Promise((resolve, reject) => {\n            void _singletons_index_js__WEBPACK_IMPORTED_MODULE_11__.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n                try {\n                    const res = await this.func(finalChunk, {\n                        ...childConfig,\n                        config: childConfig,\n                    });\n                    resolve(res);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n        if (output && Runnable.isRunnable(output)) {\n            if (config?.recursionLimit === 0) {\n                throw new Error(\"Recursion limit reached.\");\n            }\n            const stream = await output.stream(finalChunk, childConfig);\n            for await (const chunk of stream) {\n                yield chunk;\n            }\n        }\n        else if ((0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isAsyncIterable)(output)) {\n            for await (const chunk of (0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.consumeAsyncIterableInContext)(childConfig, output)) {\n                config?.signal?.throwIfAborted();\n                yield chunk;\n            }\n        }\n        else if ((0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.isIterableIterator)(output)) {\n            for (const chunk of (0,_iter_js__WEBPACK_IMPORTED_MODULE_14__.consumeIteratorInContext)(childConfig, output)) {\n                config?.signal?.throwIfAborted();\n                yield chunk;\n            }\n        }\n        else {\n            yield output;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nclass RunnableParallel extends RunnableMap {\n}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n * External APIs (e.g., APIs for a language model) may at times experience\n * degraded performance or even downtime.\n *\n * In these cases, it can be useful to have a fallback Runnable that can be\n * used in place of the original Runnable (e.g., fallback to another LLM provider).\n *\n * Fallbacks can be defined at the level of a single Runnable, or at the level\n * of a chain of Runnables. Fallbacks are tried in order until one succeeds or\n * all fail.\n *\n * While you can instantiate a `RunnableWithFallbacks` directly, it is usually\n * more convenient to use the `withFallbacks` method on an existing Runnable.\n *\n * When streaming, fallbacks will only be called on failures during the initial\n * stream creation. Errors that occur after a stream starts will not fallback\n * to the next Runnable.\n */\nclass RunnableWithFallbacks extends Runnable {\n    static lc_name() {\n        return \"RunnableWithFallbacks\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fallbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.fallbacks = fields.fallbacks;\n    }\n    *runnables() {\n        yield this.runnable;\n        for (const fallback of this.fallbacks) {\n            yield fallback;\n        }\n    }\n    async invoke(input, options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(options);\n        const { runId, ...otherConfigFields } = config;\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n        let firstError;\n        for (const runnable of this.runnables()) {\n            config?.signal?.throwIfAborted();\n            try {\n                const output = await runnable.invoke(input, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(otherConfigFields, { callbacks: runManager?.getChild() }));\n                await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n                return output;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (firstError === undefined) {\n            throw new Error(\"No error stored at end of fallback.\");\n        }\n        await runManager?.handleChainError(firstError);\n        throw firstError;\n    }\n    async *_streamIterator(input, options) {\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const callbackManager_ = await (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(options);\n        const { runId, ...otherConfigFields } = config;\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n        let firstError;\n        let stream;\n        for (const runnable of this.runnables()) {\n            config?.signal?.throwIfAborted();\n            const childConfig = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(otherConfigFields, {\n                callbacks: runManager?.getChild(),\n            });\n            try {\n                stream = await runnable.stream(input, childConfig);\n                break;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (stream === undefined) {\n            const error = firstError ?? new Error(\"No error stored at end of fallback.\");\n            await runManager?.handleChainError(error);\n            throw error;\n        }\n        let output;\n        try {\n            for await (const chunk of stream) {\n                yield chunk;\n                try {\n                    output = output === undefined ? output : (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.concat)(output, chunk);\n                }\n                catch (e) {\n                    output = undefined;\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    }\n    async batch(inputs, options, batchOptions) {\n        if (batchOptions?.returnExceptions) {\n            throw new Error(\"Not implemented.\");\n        }\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map((config) => (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.getCallbackManagerForConfig)(config)));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let firstError;\n        for (const runnable of this.runnables()) {\n            configList[0].signal?.throwIfAborted();\n            try {\n                const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(configList[j], {\n                    callbacks: runManager?.getChild(),\n                })), batchOptions);\n                await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n                return outputs;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (!firstError) {\n            throw new Error(\"No error stored at end of fallbacks.\");\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(firstError)));\n        throw firstError;\n    }\n}\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nfunction _coerceToRunnable(coerceable) {\n    if (typeof coerceable === \"function\") {\n        return new RunnableLambda({ func: coerceable });\n    }\n    else if (Runnable.isRunnable(coerceable)) {\n        return coerceable;\n    }\n    else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n        const runnables = {};\n        for (const [key, value] of Object.entries(coerceable)) {\n            runnables[key] = _coerceToRunnable(value);\n        }\n        return new RunnableMap({\n            steps: runnables,\n        });\n    }\n    else {\n        throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n */\nclass RunnableAssign extends Runnable {\n    static lc_name() {\n        return \"RunnableAssign\";\n    }\n    constructor(fields) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (fields instanceof RunnableMap) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { mapper: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"mapper\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.mapper = fields.mapper;\n    }\n    async invoke(input, options) {\n        const mapperResult = await this.mapper.invoke(input, options);\n        return {\n            ...input,\n            ...mapperResult,\n        };\n    }\n    async *_transform(generator, runManager, options) {\n        // collect mapper keys\n        const mapperKeys = this.mapper.getStepsKeys();\n        // create two input gens, one for the mapper, one for the input\n        const [forPassthrough, forMapper] = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.atee)(generator);\n        // create mapper output gen\n        const mapperOutput = this.mapper.transform(forMapper, (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.patchConfig)(options, { callbacks: runManager?.getChild() }));\n        // start the mapper\n        const firstMapperChunkPromise = mapperOutput.next();\n        // yield the passthrough\n        for await (const chunk of forPassthrough) {\n            if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n                throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);\n            }\n            const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));\n            if (Object.keys(filtered).length > 0) {\n                yield filtered;\n            }\n        }\n        // yield the mapper output\n        yield (await firstMapperChunkPromise).value;\n        for await (const chunk of mapperOutput) {\n            yield chunk;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n */\nclass RunnablePick extends Runnable {\n    static lc_name() {\n        return \"RunnablePick\";\n    }\n    constructor(fields) {\n        if (typeof fields === \"string\" || Array.isArray(fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { keys: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"keys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.keys = fields.keys;\n    }\n    async _pick(input) {\n        if (typeof this.keys === \"string\") {\n            return input[this.keys];\n        }\n        else {\n            const picked = this.keys\n                .map((key) => [key, input[key]])\n                .filter((v) => v[1] !== undefined);\n            return picked.length === 0 ? undefined : Object.fromEntries(picked);\n        }\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._pick.bind(this), input, options);\n    }\n    async *_transform(generator) {\n        for await (const chunk of generator) {\n            const picked = await this._pick(chunk);\n            if (picked !== undefined) {\n                yield picked;\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0,_config_js__WEBPACK_IMPORTED_MODULE_7__.ensureConfig)(options);\n        const wrappedGenerator = new _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_5__.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nclass RunnableToolLike extends RunnableBinding {\n    constructor(fields) {\n        const sequence = RunnableSequence.from([\n            RunnableLambda.from(async (input) => {\n                let toolInput;\n                if ((0,_tools_utils_js__WEBPACK_IMPORTED_MODULE_15__._isToolCall)(input)) {\n                    try {\n                        toolInput = await this.schema.parseAsync(input.args);\n                    }\n                    catch (e) {\n                        throw new _tools_utils_js__WEBPACK_IMPORTED_MODULE_15__.ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(input.args));\n                    }\n                }\n                else {\n                    toolInput = input;\n                }\n                return toolInput;\n            }).withConfig({ runName: `${fields.name}:parse_input` }),\n            fields.bound,\n        ]).withConfig({ runName: fields.name });\n        super({\n            bound: sequence,\n            config: fields.config ?? {},\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.schema = fields.schema;\n    }\n    static lc_name() {\n        return \"RunnableToolLike\";\n    }\n}\n/**\n * Given a runnable and a Zod schema, convert the runnable to a tool.\n *\n * @template RunInput The input type for the runnable.\n * @template RunOutput The output type for the runnable.\n *\n * @param {Runnable<RunInput, RunOutput>} runnable The runnable to convert to a tool.\n * @param fields\n * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n * @param {z.ZodType<RunInput>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n * @returns {RunnableToolLike<z.ZodType<RunInput>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n */\nfunction convertRunnableToTool(runnable, fields) {\n    const name = fields.name ?? runnable.getName();\n    const description = fields.description ?? fields.schema?.description;\n    if (fields.schema.constructor === zod__WEBPACK_IMPORTED_MODULE_16__.z.ZodString) {\n        return new RunnableToolLike({\n            name,\n            description,\n            schema: zod__WEBPACK_IMPORTED_MODULE_16__.z\n                .object({\n                input: zod__WEBPACK_IMPORTED_MODULE_16__.z.string(),\n            })\n                .transform((input) => input.input),\n            bound: runnable,\n        });\n    }\n    return new RunnableToolLike({\n        name,\n        description,\n        schema: fields.schema,\n        bound: runnable,\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy9iYXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0I7QUFDSztBQUNPO0FBQ2tDO0FBQ3dDO0FBQ2Q7QUFDekM7QUFDcUU7QUFDeEU7QUFDeUU7QUFDdEU7QUFDVztBQUNDO0FBQ1M7QUFDekM7QUFDc0I7QUFDNkU7QUFDM0Q7QUFDM0U7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sdUJBQXVCLCtEQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLLEVBQUUsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlDQUFpQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RyxnQkFBZ0IsY0FBYyxRQUFRO0FBQ25KO0FBQ0E7QUFDQSwrQkFBK0Isb0RBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUSxZQUFZLHdEQUFZO0FBQ2hFO0FBQ0EsNEJBQTRCLFFBQVEsUUFBUSx3REFBWTtBQUN4RDtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0EsMkJBQTJCLCtEQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFZO0FBQ25DLHFDQUFxQyxxRUFBdUI7QUFDNUQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGVBQWUsb0VBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdEQUFZO0FBQ3pDO0FBQ0E7QUFDQSw2QkFBNkIsd0RBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVk7QUFDbkMsdUNBQXVDLHVFQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdFQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCxtRUFBbUUsbUVBQTJCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnRUFBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVk7QUFDbkMsdUNBQXVDLHVFQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsd0RBQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdFQUFzQixnSEFBZ0gsV0FBVztBQUNoTDtBQUNBO0FBQ0Esa0VBQWtFLDJFQUFxQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxzRUFBa0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdEQUFNO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMERBQTBELHFDQUFxQyw0Q0FBNEM7QUFDM0k7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBSztBQUMvQjtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEMsb0JBQW9CLG1DQUFDO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQyxvQkFBb0IsbUNBQUM7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdEQUFNO0FBQ25DO0FBQ0E7QUFDQSxnREFBZ0Qsd0RBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEVBQXdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx1QkFBdUIsd0RBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsK0RBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVFQUF3QjtBQUMzQztBQUNBO0FBQ0EsbUJBQW1CLG9FQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0ZBQTBCO0FBQzVEO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCLHdEQUFZO0FBQ25DLHNDQUFzQyxpREFBTTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEVBQXdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0Msd0RBQWdCO0FBQ3BEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwREFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixZQUFZLDRCQUE0QixjQUFjO0FBQ3BKO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYyxHQUFHLFVBQVU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLFlBQVksNEJBQTRCLFdBQVc7QUFDN0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEVBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQStCO0FBQ2pEO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLGNBQWM7QUFDN0IsaUJBQWlCLDJDQUEyQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFZO0FBQ25DLGVBQWUsd0RBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnRUFBZ0Usd0RBQVk7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLHdEQUFZO0FBQ3RHLHNDQUFzQyx3REFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsd0RBQVk7QUFDckY7QUFDQTtBQUNBLGdFQUFnRSx3REFBWTtBQUM1RTtBQUNBO0FBQ0EsdUVBQXVFLHdEQUFZO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx3REFBWTtBQUM3RDtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWUsb0VBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBFQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHVEQUFXLFdBQVcsbUNBQW1DO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBLDhDQUE4Qyx5QkFBeUI7QUFDdkUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRCxlQUFlLHVEQUFXLFdBQVcsc0NBQXNDO0FBQzNFO0FBQ0E7QUFDQSxlQUFlLG9DQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0NBQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQSx5RUFBeUU7QUFDekUsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFZO0FBQ25DLHVDQUF1Qyx1RUFBMkI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBLDJEQUEyRCx1REFBVztBQUN0RSxnRUFBZ0UsTUFBTTtBQUN0RSxpQkFBaUI7QUFDakIsc0NBQXNDLGdFQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsdURBQVc7QUFDM0UsNERBQTRELGtCQUFrQjtBQUM5RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELGtFQUFrRSxtRUFBMkI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0EsNkVBQTZFLE1BQU07QUFDbkYsMkJBQTJCLHVEQUFXLGtCQUFrQiw0QkFBNEI7QUFDcEYsaUJBQWlCO0FBQ2pCLHVDQUF1QyxnRUFBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1RUFBMkI7QUFDbEUsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHVEQUFXO0FBQ2pGO0FBQ0EsYUFBYTtBQUNiLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQSxzRUFBc0UsdURBQVc7QUFDakYsZ0VBQWdFLE1BQU07QUFDdEUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0RBQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQUs7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsTUFBTTtBQUNwRSwyQkFBMkI7QUFDM0I7QUFDQSxtRUFBbUUsTUFBTTtBQUN6RSwyQkFBMkI7QUFDM0I7QUFDQSxJQUFJO0FBQ0osMENBQTBDLGVBQWU7QUFDekQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVk7QUFDbkMsdUNBQXVDLHVFQUEyQjtBQUNsRTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsdURBQVc7QUFDdEUsK0RBQStELElBQUk7QUFDbkUsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixrQkFBa0IsZ0VBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSw0QkFBNEIsc0RBQUk7QUFDaEM7QUFDQTtBQUNBLDJEQUEyRCx1REFBVztBQUN0RSwyREFBMkQsSUFBSTtBQUMvRCxhQUFhO0FBQ2Isd0RBQXdELGtCQUFrQjtBQUMxRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUIsUUFBUSxnRUFBYztBQUM3RDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLDhEQUE4RCxrQkFBa0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVk7QUFDbkMscUNBQXFDLHFFQUF1QjtBQUM1RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZSxvRUFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGFBQWEsbUZBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsZ0NBQWdDLHVFQUEyQjtBQUMzRCxrQ0FBa0MsdURBQVcsV0FBVyxXQUFXO0FBQ25FLGVBQWUsZ0VBQWM7QUFDN0I7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLFlBQVksMERBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxRQUFRLG1GQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtRkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1REFBVztBQUMzQztBQUNBLDJEQUEyRCwrREFBdUI7QUFDbEYsYUFBYTtBQUNiLGlCQUFpQixxRkFBa0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLCtEQUF1QjtBQUNsRyx5QkFBeUI7QUFDekI7QUFDQSw2QkFBNkIsMERBQWU7QUFDNUM7QUFDQSxrREFBa0Qsd0VBQTZCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsd0RBQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2REFBa0I7QUFDL0M7QUFDQSw0Q0FBNEMsbUVBQXdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsd0RBQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsd0RBQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVEQUFXO0FBQ3ZDO0FBQ0EsdURBQXVELCtEQUF1QjtBQUM5RSxTQUFTO0FBQ1Q7QUFDQSxpQkFBaUIscUZBQWtDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwREFBZTtBQUNoQyxzQ0FBc0Msd0VBQTZCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZEQUFrQjtBQUNuQyxnQ0FBZ0MsbUVBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBWTtBQUNuQyxxQ0FBcUMscUVBQXVCO0FBQzVEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxlQUFlLG9FQUFzQjtBQUNyQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBWTtBQUNuQyx1Q0FBdUMsdUVBQTJCO0FBQ2xFLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCx1REFBVyxzQkFBc0IsbUNBQW1DO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFZO0FBQ25DLHVDQUF1Qyx1RUFBMkI7QUFDbEUsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVEQUFXO0FBQzNDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsd0RBQU07QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsOEVBQThFLHVFQUEyQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLHVEQUFXO0FBQzNHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxzREFBSTtBQUNoRDtBQUNBLDhEQUE4RCx1REFBVyxZQUFZLG1DQUFtQztBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGFBQWE7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVk7QUFDbkMscUNBQXFDLHFFQUF1QjtBQUM1RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZSxvRUFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBWTtBQUNuQyxxQ0FBcUMscUVBQXVCO0FBQzVEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxlQUFlLG9FQUFzQjtBQUNyQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2REFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1RUFBeUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlLFlBQVksWUFBWSxlQUFlO0FBQ25FO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUM7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixXQUFXLG9CQUFvQjtBQUMvQixXQUFXLHFCQUFxQjtBQUNoQyxhQUFhLGtEQUFrRDtBQUMvRDtBQUNPO0FBQ1A7QUFDQTtBQUNBLHNDQUFzQyxtQ0FBQztBQUN2QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUNBQUM7QUFDckI7QUFDQSx1QkFBdUIsbUNBQUM7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcdGV4dHNwbGl0dGVyc1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxydW5uYWJsZXNcXGJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2RcIjtcbmltcG9ydCBwUmV0cnkgZnJvbSBcInAtcmV0cnlcIjtcbmltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBpc1RyYWNlYWJsZUZ1bmN0aW9uLCB9IGZyb20gXCJsYW5nc21pdGgvc2luZ2xldG9ucy90cmFjZWFibGVcIjtcbmltcG9ydCB7IExvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciwgUnVuTG9nLCBSdW5Mb2dQYXRjaCwgaXNMb2dTdHJlYW1IYW5kbGVyLCB9IGZyb20gXCIuLi90cmFjZXJzL2xvZ19zdHJlYW0uanNcIjtcbmltcG9ydCB7IEV2ZW50U3RyZWFtQ2FsbGJhY2tIYW5kbGVyLCBpc1N0cmVhbUV2ZW50c0hhbmRsZXIsIH0gZnJvbSBcIi4uL3RyYWNlcnMvZXZlbnRfc3RyZWFtLmpzXCI7XG5pbXBvcnQgeyBTZXJpYWxpemFibGUgfSBmcm9tIFwiLi4vbG9hZC9zZXJpYWxpemFibGUuanNcIjtcbmltcG9ydCB7IEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0sIGNvbmNhdCwgYXRlZSwgcGlwZUdlbmVyYXRvcldpdGhTZXR1cCwgQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAsIH0gZnJvbSBcIi4uL3V0aWxzL3N0cmVhbS5qc1wiO1xuaW1wb3J0IHsgcmFjZVdpdGhTaWduYWwgfSBmcm9tIFwiLi4vdXRpbHMvc2lnbmFsLmpzXCI7XG5pbXBvcnQgeyBERUZBVUxUX1JFQ1VSU0lPTl9MSU1JVCwgZW5zdXJlQ29uZmlnLCBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcsIG1lcmdlQ29uZmlncywgcGF0Y2hDb25maWcsIH0gZnJvbSBcIi4vY29uZmlnLmpzXCI7XG5pbXBvcnQgeyBBc3luY0NhbGxlciB9IGZyb20gXCIuLi91dGlscy9hc3luY19jYWxsZXIuanNcIjtcbmltcG9ydCB7IFJvb3RMaXN0ZW5lcnNUcmFjZXIgfSBmcm9tIFwiLi4vdHJhY2Vycy9yb290X2xpc3RlbmVyLmpzXCI7XG5pbXBvcnQgeyBfUm9vdEV2ZW50RmlsdGVyLCBpc1J1bm5hYmxlSW50ZXJmYWNlIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gfSBmcm9tIFwiLi4vc2luZ2xldG9ucy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tIFwiLi9ncmFwaC5qc1wiO1xuaW1wb3J0IHsgY29udmVydFRvSHR0cEV2ZW50U3RyZWFtIH0gZnJvbSBcIi4vd3JhcHBlcnMuanNcIjtcbmltcG9ydCB7IGNvbnN1bWVBc3luY0l0ZXJhYmxlSW5Db250ZXh0LCBjb25zdW1lSXRlcmF0b3JJbkNvbnRleHQsIGlzQXN5bmNJdGVyYWJsZSwgaXNJdGVyYWJsZUl0ZXJhdG9yLCBpc0l0ZXJhdG9yLCB9IGZyb20gXCIuL2l0ZXIuanNcIjtcbmltcG9ydCB7IF9pc1Rvb2xDYWxsLCBUb29sSW5wdXRQYXJzaW5nRXhjZXB0aW9uIH0gZnJvbSBcIi4uL3Rvb2xzL3V0aWxzLmpzXCI7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGZ1bmN0aW9uIF9jb2VyY2VUb0RpY3QodmFsdWUsIGRlZmF1bHRLZXkpIHtcbiAgICByZXR1cm4gdmFsdWUgJiZcbiAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIlxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogeyBbZGVmYXVsdEtleV06IHZhbHVlIH07XG59XG4vKipcbiAqIEEgUnVubmFibGUgaXMgYSBnZW5lcmljIHVuaXQgb2Ygd29yayB0aGF0IGNhbiBiZSBpbnZva2VkLCBiYXRjaGVkLCBzdHJlYW1lZCwgYW5kL29yXG4gKiB0cmFuc2Zvcm1lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlIGV4dGVuZHMgU2VyaWFsaXphYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfcnVubmFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TmFtZShzdWZmaXgpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0aGlzLm5hbWUgPz8gdGhpcy5jb25zdHJ1Y3Rvci5sY19uYW1lKCkgPz8gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICByZXR1cm4gc3VmZml4ID8gYCR7bmFtZX0ke3N1ZmZpeH1gIDogbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCBhcmd1bWVudHMgdG8gYSBSdW5uYWJsZSwgcmV0dXJuaW5nIGEgbmV3IFJ1bm5hYmxlLlxuICAgICAqIEBwYXJhbSBrd2FyZ3NcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBSdW5uYWJsZUJpbmRpbmcgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIGFwcGx5IHRoZSBib3VuZCBhcmdzLlxuICAgICAqL1xuICAgIGJpbmQoa3dhcmdzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUJpbmRpbmcoeyBib3VuZDogdGhpcywga3dhcmdzLCBjb25maWc6IHt9IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgUnVubmFibGUgdGhhdCBtYXBzIGEgbGlzdCBvZiBpbnB1dHMgdG8gYSBsaXN0IG9mIG91dHB1dHMsXG4gICAgICogYnkgY2FsbGluZyBpbnZva2UoKSB3aXRoIGVhY2ggaW5wdXQuXG4gICAgICovXG4gICAgbWFwKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVFYWNoKHsgYm91bmQ6IHRoaXMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCByZXRyeSBsb2dpYyB0byBhbiBleGlzdGluZyBydW5uYWJsZS5cbiAgICAgKiBAcGFyYW0ga3dhcmdzXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVSZXRyeSB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgcmV0cnkgYWNjb3JkaW5nIHRvIHRoZSBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIHdpdGhSZXRyeShmaWVsZHMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlUmV0cnkoe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMsXG4gICAgICAgICAgICBrd2FyZ3M6IHt9LFxuICAgICAgICAgICAgY29uZmlnOiB7fSxcbiAgICAgICAgICAgIG1heEF0dGVtcHROdW1iZXI6IGZpZWxkcz8uc3RvcEFmdGVyQXR0ZW1wdCxcbiAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgY29uZmlnIHRvIGEgUnVubmFibGUsIHJldHVybmluZyBhIG5ldyBSdW5uYWJsZS5cbiAgICAgKiBAcGFyYW0gY29uZmlnIE5ldyBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgdG8gYXR0YWNoIHRvIHRoZSBuZXcgcnVubmFibGUuXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVCaW5kaW5nIHdpdGggYSBjb25maWcgbWF0Y2hpbmcgd2hhdCdzIHBhc3NlZC5cbiAgICAgKi9cbiAgICB3aXRoQ29uZmlnKGNvbmZpZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVCaW5kaW5nKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAga3dhcmdzOiB7fSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBydW5uYWJsZSBmcm9tIHRoZSBjdXJyZW50IG9uZSB0aGF0IHdpbGwgdHJ5IGludm9raW5nXG4gICAgICogb3RoZXIgcGFzc2VkIGZhbGxiYWNrIHJ1bm5hYmxlcyBpZiB0aGUgaW5pdGlhbCBpbnZvY2F0aW9uIGZhaWxzLlxuICAgICAqIEBwYXJhbSBmaWVsZHMuZmFsbGJhY2tzIE90aGVyIHJ1bm5hYmxlcyB0byBjYWxsIGlmIHRoZSBydW5uYWJsZSBlcnJvcnMuXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVXaXRoRmFsbGJhY2tzLlxuICAgICAqL1xuICAgIHdpdGhGYWxsYmFja3MoZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrcyA9IEFycmF5LmlzQXJyYXkoZmllbGRzKSA/IGZpZWxkcyA6IGZpZWxkcy5mYWxsYmFja3M7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVdpdGhGYWxsYmFja3Moe1xuICAgICAgICAgICAgcnVubmFibGU6IHRoaXMsXG4gICAgICAgICAgICBmYWxsYmFja3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucywgbGVuZ3RoID0gMCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSAmJiBvcHRpb25zLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhc3NlZCBcIm9wdGlvbnNcIiBtdXN0IGJlIGFuIGFycmF5IHdpdGggdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBpbnB1dHMsIGJ1dCBnb3QgJHtvcHRpb25zLmxlbmd0aH0gb3B0aW9ucyBmb3IgJHtsZW5ndGh9IGlucHV0c2ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5tYXAoZW5zdXJlQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID4gMSAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zKSAmJiBvcHRpb25zLnJ1bklkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJQcm92aWRlZCBydW5JZCB3aWxsIGJlIHVzZWQgb25seSBmb3IgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGJhdGNoLlwiKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNlcXVlbnQgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMob3B0aW9ucykuZmlsdGVyKChba2V5XSkgPT4ga2V5ICE9PSBcInJ1bklkXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sIChfLCBpKSA9PiBlbnN1cmVDb25maWcoaSA9PT0gMCA/IG9wdGlvbnMgOiBzdWJzZXF1ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGggfSwgKCkgPT4gZW5zdXJlQ29uZmlnKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnTGlzdCA9IHRoaXMuX2dldE9wdGlvbnNMaXN0KG9wdGlvbnMgPz8ge30sIGlucHV0cy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBtYXhDb25jdXJyZW5jeSA9IGNvbmZpZ0xpc3RbMF0/Lm1heENvbmN1cnJlbmN5ID8/IGJhdGNoT3B0aW9ucz8ubWF4Q29uY3VycmVuY3k7XG4gICAgICAgIGNvbnN0IGNhbGxlciA9IG5ldyBBc3luY0NhbGxlcih7XG4gICAgICAgICAgICBtYXhDb25jdXJyZW5jeSxcbiAgICAgICAgICAgIG9uRmFpbGVkQXR0ZW1wdDogKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJhdGNoQ2FsbHMgPSBpbnB1dHMubWFwKChpbnB1dCwgaSkgPT4gY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmludm9rZShpbnB1dCwgY29uZmlnTGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJhdGNoT3B0aW9ucz8ucmV0dXJuRXhjZXB0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYmF0Y2hDYWxscyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgc3RyZWFtaW5nIGltcGxlbWVudGF0aW9uLlxuICAgICAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHRoZXkgc3VwcG9ydCBzdHJlYW1pbmcgb3V0cHV0LlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICB5aWVsZCB0aGlzLmludm9rZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmVhbSBvdXRwdXQgaW4gY2h1bmtzLlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHJldHVybnMgQSByZWFkYWJsZSBzdHJlYW0gdGhhdCBpcyBhbHNvIGFuIGl0ZXJhYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIHN0cmVhbShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICAvLyBCdWZmZXIgdGhlIGZpcnN0IHN0cmVhbWVkIGNodW5rIHRvIGFsbG93IGZvciBpbml0aWFsIGVycm9yc1xuICAgICAgICAvLyB0byBzdXJmYWNlIGltbWVkaWF0ZWx5LlxuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRHZW5lcmF0b3IgPSBuZXcgQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAoe1xuICAgICAgICAgICAgZ2VuZXJhdG9yOiB0aGlzLl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgY29uZmlnKSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHdyYXBwZWRHZW5lcmF0b3Iuc2V0dXA7XG4gICAgICAgIHJldHVybiBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcih3cmFwcGVkR2VuZXJhdG9yKTtcbiAgICB9XG4gICAgX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBsZXQgcnVubmFibGVDb25maWc7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1bm5hYmxlQ29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcnVubmFibGVDb25maWcgPSBlbnN1cmVDb25maWcoe1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczogb3B0aW9ucy5jYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgdGFnczogb3B0aW9ucy50YWdzLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBvcHRpb25zLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHJ1bk5hbWU6IG9wdGlvbnMucnVuTmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IG9wdGlvbnMuY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgICAgIHJlY3Vyc2lvbkxpbWl0OiBvcHRpb25zLnJlY3Vyc2lvbkxpbWl0LFxuICAgICAgICAgICAgICAgIG1heENvbmN1cnJlbmN5OiBvcHRpb25zLm1heENvbmN1cnJlbmN5LFxuICAgICAgICAgICAgICAgIHJ1bklkOiBvcHRpb25zLnJ1bklkLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCxcbiAgICAgICAgICAgICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FsbE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLmNhbGxiYWNrcztcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLnRhZ3M7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5tZXRhZGF0YTtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLnJ1bk5hbWU7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5jb25maWd1cmFibGU7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5yZWN1cnNpb25MaW1pdDtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLm1heENvbmN1cnJlbmN5O1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMucnVuSWQ7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy50aW1lb3V0O1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMuc2lnbmFsO1xuICAgICAgICByZXR1cm4gW3J1bm5hYmxlQ29uZmlnLCBjYWxsT3B0aW9uc107XG4gICAgfVxuICAgIGFzeW5jIF9jYWxsV2l0aENvbmZpZyhmdW5jLCBpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcoY29uZmlnKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dCwgXCJpbnB1dFwiKSwgY29uZmlnLnJ1bklkLCBjb25maWc/LnJ1blR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWc/LnJ1bk5hbWUgPz8gdGhpcy5nZXROYW1lKCkpO1xuICAgICAgICBkZWxldGUgY29uZmlnLnJ1bklkO1xuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGZ1bmMuY2FsbCh0aGlzLCBpbnB1dCwgY29uZmlnLCBydW5NYW5hZ2VyKTtcbiAgICAgICAgICAgIG91dHB1dCA9IGF3YWl0IHJhY2VXaXRoU2lnbmFsKHByb21pc2UsIG9wdGlvbnM/LnNpZ25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3Qob3V0cHV0LCBcIm91dHB1dFwiKSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0aGF0IGhhbmRsZXMgYmF0Y2hpbmcgYW5kIGNvbmZpZ3VyYXRpb24gZm9yIGEgcnVubmFibGVcbiAgICAgKiBJdCB0YWtlcyBhIGZ1bmN0aW9uLCBpbnB1dCB2YWx1ZXMsIGFuZCBvcHRpb25hbCBjb25maWd1cmF0aW9uLCBhbmRcbiAgICAgKiByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBvdXRwdXQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBmb3IgZWFjaCBpbnB1dCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHZhbHVlcyB0byBiZSBwcm9jZXNzZWQuXG4gICAgICogQHBhcmFtIGNvbmZpZyBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGUgZnVuY3Rpb24gZXhlY3V0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBvdXRwdXQgdmFsdWVzLlxuICAgICAqL1xuICAgIGFzeW5jIF9iYXRjaFdpdGhDb25maWcoZnVuYywgaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uc0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKG9wdGlvbnNMaXN0Lm1hcChnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcpKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChjYWxsYmFja01hbmFnZXJzLm1hcChhc3luYyAoY2FsbGJhY2tNYW5hZ2VyLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVTdGFydFJlcyA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcj8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0c1tpXSwgXCJpbnB1dFwiKSwgb3B0aW9uc0xpc3RbaV0ucnVuSWQsIG9wdGlvbnNMaXN0W2ldLnJ1blR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zTGlzdFtpXS5ydW5OYW1lID8/IHRoaXMuZ2V0TmFtZSgpKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zTGlzdFtpXS5ydW5JZDtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdGFydFJlcztcbiAgICAgICAgfSkpO1xuICAgICAgICBsZXQgb3V0cHV0cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBmdW5jLmNhbGwodGhpcywgaW5wdXRzLCBvcHRpb25zTGlzdCwgcnVuTWFuYWdlcnMsIGJhdGNoT3B0aW9ucyk7XG4gICAgICAgICAgICBvdXRwdXRzID0gYXdhaXQgcmFjZVdpdGhTaWduYWwocHJvbWlzZSwgb3B0aW9uc0xpc3Q/LlswXT8uc2lnbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpKSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChvdXRwdXRzLCBcIm91dHB1dFwiKSkpKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gdHJhbnNmb3JtIGFuIEl0ZXJhdG9yIG9mIElucHV0IHZhbHVlcyBpbnRvIGFuIEl0ZXJhdG9yIG9mXG4gICAgICogT3V0cHV0IHZhbHVlcywgd2l0aCBjYWxsYmFja3MuXG4gICAgICogVXNlIHRoaXMgdG8gaW1wbGVtZW50IGBzdHJlYW0oKWAgb3IgYHRyYW5zZm9ybSgpYCBpbiBSdW5uYWJsZSBzdWJjbGFzc2VzLlxuICAgICAqL1xuICAgIGFzeW5jICpfdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhpbnB1dEdlbmVyYXRvciwgdHJhbnNmb3JtZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGZpbmFsSW5wdXQ7XG4gICAgICAgIGxldCBmaW5hbElucHV0U3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICBsZXQgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcoY29uZmlnKTtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24qIHdyYXBJbnB1dEZvclRyYWNpbmcoKSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGlucHV0R2VuZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsSW5wdXRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsSW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxJbnB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsSW5wdXQgPSBjb25jYXQoZmluYWxJbnB1dCwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsSW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxJbnB1dFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBydW5NYW5hZ2VyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGlwZSA9IGF3YWl0IHBpcGVHZW5lcmF0b3JXaXRoU2V0dXAodHJhbnNmb3JtZXIuYmluZCh0aGlzKSwgd3JhcElucHV0Rm9yVHJhY2luZygpLCBhc3luYyAoKSA9PiBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIHsgaW5wdXQ6IFwiXCIgfSwgY29uZmlnLnJ1bklkLCBjb25maWcucnVuVHlwZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZy5ydW5OYW1lID8/IHRoaXMuZ2V0TmFtZSgpKSwgb3B0aW9ucz8uc2lnbmFsLCBjb25maWcpO1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5ydW5JZDtcbiAgICAgICAgICAgIHJ1bk1hbmFnZXIgPSBwaXBlLnNldHVwO1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtRXZlbnRzSGFuZGxlciA9IHJ1bk1hbmFnZXI/LmhhbmRsZXJzLmZpbmQoaXNTdHJlYW1FdmVudHNIYW5kbGVyKTtcbiAgICAgICAgICAgIGxldCBpdGVyYXRvciA9IHBpcGUub3V0cHV0O1xuICAgICAgICAgICAgaWYgKHN0cmVhbUV2ZW50c0hhbmRsZXIgIT09IHVuZGVmaW5lZCAmJiBydW5NYW5hZ2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvciA9IHN0cmVhbUV2ZW50c0hhbmRsZXIudGFwT3V0cHV0SXRlcmFibGUocnVuTWFuYWdlci5ydW5JZCwgaXRlcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyZWFtTG9nSGFuZGxlciA9IHJ1bk1hbmFnZXI/LmhhbmRsZXJzLmZpbmQoaXNMb2dTdHJlYW1IYW5kbGVyKTtcbiAgICAgICAgICAgIGlmIChzdHJlYW1Mb2dIYW5kbGVyICE9PSB1bmRlZmluZWQgJiYgcnVuTWFuYWdlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBzdHJlYW1Mb2dIYW5kbGVyLnRhcE91dHB1dEl0ZXJhYmxlKHJ1bk1hbmFnZXIucnVuSWQsIGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjb25jYXQoZmluYWxPdXRwdXQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICBpbnB1dHM6IF9jb2VyY2VUb0RpY3QoZmluYWxJbnB1dCwgXCJpbnB1dFwiKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChmaW5hbE91dHB1dCA/PyB7fSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBpbnB1dHM6IF9jb2VyY2VUb0RpY3QoZmluYWxJbnB1dCwgXCJpbnB1dFwiKSB9KTtcbiAgICB9XG4gICAgZ2V0R3JhcGgoXykge1xuICAgICAgICBjb25zdCBncmFwaCA9IG5ldyBHcmFwaCgpO1xuICAgICAgICAvLyBUT0RPOiBBZGQgaW5wdXQgc2NoZW1hIGZvciBydW5uYWJsZXNcbiAgICAgICAgY29uc3QgaW5wdXROb2RlID0gZ3JhcGguYWRkTm9kZSh7XG4gICAgICAgICAgICBuYW1lOiBgJHt0aGlzLmdldE5hbWUoKX1JbnB1dGAsXG4gICAgICAgICAgICBzY2hlbWE6IHouYW55KCksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBydW5uYWJsZU5vZGUgPSBncmFwaC5hZGROb2RlKHRoaXMpO1xuICAgICAgICAvLyBUT0RPOiBBZGQgb3V0cHV0IHNjaGVtYXMgZm9yIHJ1bm5hYmxlc1xuICAgICAgICBjb25zdCBvdXRwdXROb2RlID0gZ3JhcGguYWRkTm9kZSh7XG4gICAgICAgICAgICBuYW1lOiBgJHt0aGlzLmdldE5hbWUoKX1PdXRwdXRgLFxuICAgICAgICAgICAgc2NoZW1hOiB6LmFueSgpLFxuICAgICAgICB9KTtcbiAgICAgICAgZ3JhcGguYWRkRWRnZShpbnB1dE5vZGUsIHJ1bm5hYmxlTm9kZSk7XG4gICAgICAgIGdyYXBoLmFkZEVkZ2UocnVubmFibGVOb2RlLCBvdXRwdXROb2RlKTtcbiAgICAgICAgcmV0dXJuIGdyYXBoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcnVubmFibGUgc2VxdWVuY2UgdGhhdCBydW5zIGVhY2ggaW5kaXZpZHVhbCBydW5uYWJsZSBpbiBzZXJpZXMsXG4gICAgICogcGlwaW5nIHRoZSBvdXRwdXQgb2Ygb25lIHJ1bm5hYmxlIGludG8gYW5vdGhlciBydW5uYWJsZSBvciBydW5uYWJsZS1saWtlLlxuICAgICAqIEBwYXJhbSBjb2VyY2VhYmxlIEEgcnVubmFibGUsIGZ1bmN0aW9uLCBvciBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBmdW5jdGlvbnMgb3IgcnVubmFibGVzLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IHJ1bm5hYmxlIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIHBpcGUoY29lcmNlYWJsZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVTZXF1ZW5jZSh7XG4gICAgICAgICAgICBmaXJzdDogdGhpcyxcbiAgICAgICAgICAgIGxhc3Q6IF9jb2VyY2VUb1J1bm5hYmxlKGNvZXJjZWFibGUpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGljayBrZXlzIGZyb20gdGhlIGRpY3Qgb3V0cHV0IG9mIHRoaXMgcnVubmFibGUuIFJldHVybnMgYSBuZXcgcnVubmFibGUuXG4gICAgICovXG4gICAgcGljayhrZXlzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIHRoaXMucGlwZShuZXcgUnVubmFibGVQaWNrKGtleXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzaWducyBuZXcgZmllbGRzIHRvIHRoZSBkaWN0IG91dHB1dCBvZiB0aGlzIHJ1bm5hYmxlLiBSZXR1cm5zIGEgbmV3IHJ1bm5hYmxlLlxuICAgICAqL1xuICAgIGFzc2lnbihtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpcGUoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgbmV3IFJ1bm5hYmxlQXNzaWduKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIG5ldyBSdW5uYWJsZU1hcCh7IHN0ZXBzOiBtYXBwaW5nIH0pKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdHJhbnNmb3JtLCB3aGljaCBidWZmZXJzIGlucHV0IGFuZCB0aGVuIGNhbGxzIHN0cmVhbS5cbiAgICAgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB0aGV5IGNhbiBzdGFydCBwcm9kdWNpbmcgb3V0cHV0IHdoaWxlXG4gICAgICogaW5wdXQgaXMgc3RpbGwgYmVpbmcgZ2VuZXJhdGVkLlxuICAgICAqIEBwYXJhbSBnZW5lcmF0b3JcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIGFzeW5jICp0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBmaW5hbENodW5rO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGdlbmVyYXRvcikge1xuICAgICAgICAgICAgaWYgKGZpbmFsQ2h1bmsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmsgPSBjaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1ha2UgYSBiZXN0IGVmZm9ydCB0byBnYXRoZXIsIGZvciBhbnkgdHlwZSB0aGF0IHN1cHBvcnRzIGNvbmNhdC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgdGhyb3cgYW4gZXJyb3IgaWYgZ2F0aGVyaW5nIGZhaWxzLlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgZmluYWxDaHVuayA9IGNvbmNhdChmaW5hbENodW5rLCBjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQqIHRoaXMuX3N0cmVhbUl0ZXJhdG9yKGZpbmFsQ2h1bmssIGVuc3VyZUNvbmZpZyhvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmVhbSBhbGwgb3V0cHV0IGZyb20gYSBydW5uYWJsZSwgYXMgcmVwb3J0ZWQgdG8gdGhlIGNhbGxiYWNrIHN5c3RlbS5cbiAgICAgKiBUaGlzIGluY2x1ZGVzIGFsbCBpbm5lciBydW5zIG9mIExMTXMsIFJldHJpZXZlcnMsIFRvb2xzLCBldGMuXG4gICAgICogT3V0cHV0IGlzIHN0cmVhbWVkIGFzIExvZyBvYmplY3RzLCB3aGljaCBpbmNsdWRlIGEgbGlzdCBvZlxuICAgICAqIGpzb25wYXRjaCBvcHMgdGhhdCBkZXNjcmliZSBob3cgdGhlIHN0YXRlIG9mIHRoZSBydW4gaGFzIGNoYW5nZWQgaW4gZWFjaFxuICAgICAqIHN0ZXAsIGFuZCB0aGUgZmluYWwgc3RhdGUgb2YgdGhlIHJ1bi5cbiAgICAgKiBUaGUganNvbnBhdGNoIG9wcyBjYW4gYmUgYXBwbGllZCBpbiBvcmRlciB0byBjb25zdHJ1Y3Qgc3RhdGUuXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gc3RyZWFtT3B0aW9uc1xuICAgICAqL1xuICAgIGFzeW5jICpzdHJlYW1Mb2coaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyID0gbmV3IExvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlcih7XG4gICAgICAgICAgICAuLi5zdHJlYW1PcHRpb25zLFxuICAgICAgICAgICAgYXV0b0Nsb3NlOiBmYWxzZSxcbiAgICAgICAgICAgIF9zY2hlbWFGb3JtYXQ6IFwib3JpZ2luYWxcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgeWllbGQqIHRoaXMuX3N0cmVhbUxvZyhpbnB1dCwgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLCBjb25maWcpO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUxvZyhpbnB1dCwgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLCBjb25maWcpIHtcbiAgICAgICAgY29uc3QgeyBjYWxsYmFja3MgfSA9IGNvbmZpZztcbiAgICAgICAgaWYgKGNhbGxiYWNrcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFja3MgPSBbbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNhbGxiYWNrcykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrcyA9IGNhbGxiYWNrcy5jb25jYXQoW2xvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlcl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29waWVkQ2FsbGJhY2tzID0gY2FsbGJhY2tzLmNvcHkoKTtcbiAgICAgICAgICAgIGNvcGllZENhbGxiYWNrcy5hZGRIYW5kbGVyKGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFja3MgPSBjb3BpZWRDYWxsYmFja3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmFibGVTdHJlYW1Qcm9taXNlID0gdGhpcy5zdHJlYW0oaW5wdXQsIGNvbmZpZyk7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVSdW5uYWJsZVN0cmVhbSgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVubmFibGVTdHJlYW0gPSBhd2FpdCBydW5uYWJsZVN0cmVhbVByb21pc2U7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBydW5uYWJsZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRjaCA9IG5ldyBSdW5Mb2dQYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBcIi9zdHJlYW1lZF9vdXRwdXQvLVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIud3JpdGVyLndyaXRlKHBhdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIud3JpdGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmFibGVTdHJlYW1Db25zdW1lUHJvbWlzZSA9IGNvbnN1bWVSdW5uYWJsZVN0cmVhbSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBsb2cgb2YgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgbG9nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgYXdhaXQgcnVubmFibGVTdHJlYW1Db25zdW1lUHJvbWlzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdHJlYW1FdmVudHMoaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHN0cmVhbTtcbiAgICAgICAgaWYgKG9wdGlvbnMudmVyc2lvbiA9PT0gXCJ2MVwiKSB7XG4gICAgICAgICAgICBzdHJlYW0gPSB0aGlzLl9zdHJlYW1FdmVudHNWMShpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy52ZXJzaW9uID09PSBcInYyXCIpIHtcbiAgICAgICAgICAgIHN0cmVhbSA9IHRoaXMuX3N0cmVhbUV2ZW50c1YyKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSB2ZXJzaW9ucyBcInYxXCIgYW5kIFwidjJcIiBvZiB0aGUgc2NoZW1hIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuY29kaW5nID09PSBcInRleHQvZXZlbnQtc3RyZWFtXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9IdHRwRXZlbnRTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcihzdHJlYW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtRXZlbnRzVjIoaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZXZlbnRTdHJlYW1lciA9IG5ldyBFdmVudFN0cmVhbUNhbGxiYWNrSGFuZGxlcih7XG4gICAgICAgICAgICAuLi5zdHJlYW1PcHRpb25zLFxuICAgICAgICAgICAgYXV0b0Nsb3NlOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcnVuSWQgPSBjb25maWcucnVuSWQgPz8gdXVpZHY0KCk7XG4gICAgICAgIGNvbmZpZy5ydW5JZCA9IHJ1bklkO1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBjb25maWcuY2FsbGJhY2tzO1xuICAgICAgICBpZiAoY2FsbGJhY2tzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFja3MgPSBbZXZlbnRTdHJlYW1lcl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjYWxsYmFja3MpKSB7XG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gY2FsbGJhY2tzLmNvbmNhdChldmVudFN0cmVhbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvcGllZENhbGxiYWNrcyA9IGNhbGxiYWNrcy5jb3B5KCk7XG4gICAgICAgICAgICBjb3BpZWRDYWxsYmFja3MuYWRkSGFuZGxlcihldmVudFN0cmVhbWVyLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrcyA9IGNvcGllZENhbGxiYWNrcztcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxsIHRoZSBydW5uYWJsZSBpbiBzdHJlYW1pbmcgbW9kZSxcbiAgICAgICAgLy8gYWRkIGVhY2ggY2h1bmsgdG8gdGhlIG91dHB1dCBzdHJlYW1cbiAgICAgICAgY29uc3Qgb3V0ZXJUaGlzID0gdGhpcztcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29uc3VtZVJ1bm5hYmxlU3RyZWFtKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBydW5uYWJsZVN0cmVhbSA9IGF3YWl0IG91dGVyVGhpcy5zdHJlYW0oaW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFwcGVkU3RyZWFtID0gZXZlbnRTdHJlYW1lci50YXBPdXRwdXRJdGVyYWJsZShydW5JZCwgcnVubmFibGVTdHJlYW0pO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IF8gb2YgdGFwcGVkU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgaXRlcmF0ZSBzbyB0aGF0IHRoZSBjYWxsYmFjayBoYW5kbGVyIHBpY2tzIHVwIGV2ZW50c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGV2ZW50U3RyZWFtZXIuZmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmFibGVTdHJlYW1Db25zdW1lUHJvbWlzZSA9IGNvbnN1bWVSdW5uYWJsZVN0cmVhbSgpO1xuICAgICAgICBsZXQgZmlyc3RFdmVudFNlbnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGZpcnN0RXZlbnRSdW5JZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgZXZlbnQgb2YgZXZlbnRTdHJlYW1lcikge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB3b3JrLWFyb3VuZCBhbiBpc3N1ZSB3aGVyZSB0aGUgaW5wdXRzIGludG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gY2hhaW4gYXJlIG5vdCBhdmFpbGFibGUgdW50aWwgdGhlIGVudGlyZSBpbnB1dCBpcyBjb25zdW1lZC5cbiAgICAgICAgICAgICAgICAvLyBBcyBhIHRlbXBvcmFyeSBzb2x1dGlvbiwgd2UnbGwgbW9kaWZ5IHRoZSBpbnB1dCB0byBiZSB0aGUgaW5wdXRcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdhcyBwYXNzZWQgaW50byB0aGUgY2hhaW4uXG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdEV2ZW50U2VudCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RXZlbnRTZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFdmVudFJ1bklkID0gZXZlbnQucnVuX2lkO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudC5ydW5faWQgPT09IGZpcnN0RXZlbnRSdW5JZCAmJiBldmVudC5ldmVudC5lbmRzV2l0aChcIl9lbmRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyB0aGUgZW5kIGV2ZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJvb3QgcnVubmFibGVcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9udCBpbmNsdWRlIHRoZSBpbnB1dCBpbiB0aGUgZXZlbnQgc2luY2UgaXQncyBndWFyYW50ZWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBmaXJzdCBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGE/LmlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnQuZGF0YS5pbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5aWVsZCBldmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bm5hYmxlU3RyZWFtQ29uc3VtZVByb21pc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1FdmVudHNWMShpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucykge1xuICAgICAgICBsZXQgcnVuTG9nO1xuICAgICAgICBsZXQgaGFzRW5jb3VudGVyZWRTdGFydEV2ZW50ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgcm9vdFRhZ3MgPSBjb25maWcudGFncyA/PyBbXTtcbiAgICAgICAgY29uc3Qgcm9vdE1ldGFkYXRhID0gY29uZmlnLm1ldGFkYXRhID8/IHt9O1xuICAgICAgICBjb25zdCByb290TmFtZSA9IGNvbmZpZy5ydW5OYW1lID8/IHRoaXMuZ2V0TmFtZSgpO1xuICAgICAgICBjb25zdCBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIgPSBuZXcgTG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyKHtcbiAgICAgICAgICAgIC4uLnN0cmVhbU9wdGlvbnMsXG4gICAgICAgICAgICBhdXRvQ2xvc2U6IGZhbHNlLFxuICAgICAgICAgICAgX3NjaGVtYUZvcm1hdDogXCJzdHJlYW1pbmdfZXZlbnRzXCIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByb290RXZlbnRGaWx0ZXIgPSBuZXcgX1Jvb3RFdmVudEZpbHRlcih7XG4gICAgICAgICAgICAuLi5zdHJlYW1PcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbG9nU3RyZWFtID0gdGhpcy5fc3RyZWFtTG9nKGlucHV0LCBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIsIGNvbmZpZyk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgbG9nIG9mIGxvZ1N0cmVhbSkge1xuICAgICAgICAgICAgaWYgKCFydW5Mb2cpIHtcbiAgICAgICAgICAgICAgICBydW5Mb2cgPSBSdW5Mb2cuZnJvbVJ1bkxvZ1BhdGNoKGxvZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBydW5Mb2cgPSBydW5Mb2cuY29uY2F0KGxvZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnVuTG9nLnN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIGVycm9yOiBcInN0cmVhbUV2ZW50c1wiIHN0YXRlIGlzIG1pc3NpbmcuIFBsZWFzZSBvcGVuIGEgYnVnIHJlcG9ydC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFlpZWxkIHRoZSBzdGFydCBldmVudCBmb3IgdGhlIHJvb3QgcnVubmFibGUgaWYgaXQgaGFzbid0IGJlZW4gc2Vlbi5cbiAgICAgICAgICAgIC8vIFRoZSByb290IHJ1biBpcyBuZXZlciBmaWx0ZXJlZCBvdXRcbiAgICAgICAgICAgIGlmICghaGFzRW5jb3VudGVyZWRTdGFydEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaGFzRW5jb3VudGVyZWRTdGFydEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHsgLi4ucnVuTG9nLnN0YXRlIH07XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bl9pZDogc3RhdGUuaWQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBgb25fJHtzdGF0ZS50eXBlfV9zdGFydGAsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHJvb3ROYW1lLFxuICAgICAgICAgICAgICAgICAgICB0YWdzOiByb290VGFncyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHJvb3RNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocm9vdEV2ZW50RmlsdGVyLmluY2x1ZGVFdmVudChldmVudCwgc3RhdGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgZXZlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGF0aHMgPSBsb2cub3BzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigob3ApID0+IG9wLnBhdGguc3RhcnRzV2l0aChcIi9sb2dzL1wiKSlcbiAgICAgICAgICAgICAgICAubWFwKChvcCkgPT4gb3AucGF0aC5zcGxpdChcIi9cIilbMl0pO1xuICAgICAgICAgICAgY29uc3QgZGVkdXBlZFBhdGhzID0gWy4uLm5ldyBTZXQocGF0aHMpXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBkZWR1cGVkUGF0aHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRUeXBlO1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0ge307XG4gICAgICAgICAgICAgICAgY29uc3QgbG9nRW50cnkgPSBydW5Mb2cuc3RhdGUubG9nc1twYXRoXTtcbiAgICAgICAgICAgICAgICBpZiAobG9nRW50cnkuZW5kX3RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9nRW50cnkuc3RyZWFtZWRfb3V0cHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9IFwic3RyZWFtXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFR5cGUgPSBcInN0YXJ0XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9IFwiZW5kXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudFR5cGUgPT09IFwic3RhcnRcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIHRoZSBpbnB1dHMgd2l0aCB0aGUgc3RhcnQgZXZlbnQgaWYgdGhleSBhcmUgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgICAgICAvLyBVc3VhbGx5IHRoZXkgd2lsbCBOT1QgYmUgYXZhaWxhYmxlIGZvciBjb21wb25lbnRzIHRoYXQgb3BlcmF0ZVxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBzdHJlYW1zLCBzaW5jZSB0aG9zZSBjb21wb25lbnRzIHN0cmVhbSB0aGUgaW5wdXQgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGtub3cgaXRzIGZpbmFsIHZhbHVlIHVudGlsIHRoZSBlbmQgb2YgdGhlIHN0cmVhbS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ0VudHJ5LmlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmlucHV0ID0gbG9nRW50cnkuaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gXCJlbmRcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9nRW50cnkuaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaW5wdXQgPSBsb2dFbnRyeS5pbnB1dHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YS5vdXRwdXQgPSBsb2dFbnRyeS5maW5hbF9vdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gXCJzdHJlYW1cIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua0NvdW50ID0gbG9nRW50cnkuc3RyZWFtZWRfb3V0cHV0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rQ291bnQgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgZXhhY3RseSBvbmUgY2h1bmsgb2Ygc3RyZWFtZWQgb3V0cHV0LCBnb3QgJHtjaHVua0NvdW50fSBpbnN0ZWFkLiBFbmNvdW50ZXJlZCBpbjogXCIke2xvZ0VudHJ5Lm5hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhID0geyBjaHVuazogbG9nRW50cnkuc3RyZWFtZWRfb3V0cHV0WzBdIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSBzdHJlYW0sIHdlIGRvbid0IG5lZWQgaXQgYW55bW9yZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQW5kIHRoaXMgYXZvaWRzIGR1cGxpY2F0ZXMgYXMgd2VsbCFcbiAgICAgICAgICAgICAgICAgICAgbG9nRW50cnkuc3RyZWFtZWRfb3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGBvbl8ke2xvZ0VudHJ5LnR5cGV9XyR7ZXZlbnRUeXBlfWAsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGxvZ0VudHJ5Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJ1bl9pZDogbG9nRW50cnkuaWQsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IGxvZ0VudHJ5LnRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBsb2dFbnRyeS5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluYWxseSwgd2UgdGFrZSBjYXJlIG9mIHRoZSBzdHJlYW1pbmcgb3V0cHV0IGZyb20gdGhlIHJvb3QgY2hhaW5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueS5cbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHJ1bkxvZztcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zdHJlYW1lZF9vdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rQ291bnQgPSBzdGF0ZS5zdHJlYW1lZF9vdXRwdXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjaHVua0NvdW50ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgZXhhY3RseSBvbmUgY2h1bmsgb2Ygc3RyZWFtZWQgb3V0cHV0LCBnb3QgJHtjaHVua0NvdW50fSBpbnN0ZWFkLiBFbmNvdW50ZXJlZCBpbjogXCIke3N0YXRlLm5hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHsgY2h1bms6IHN0YXRlLnN0cmVhbWVkX291dHB1dFswXSB9O1xuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSBzdHJlYW0sIHdlIGRvbid0IG5lZWQgaXQgYW55bW9yZS5cbiAgICAgICAgICAgICAgICBzdGF0ZS5zdHJlYW1lZF9vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGBvbl8ke3N0YXRlLnR5cGV9X3N0cmVhbWAsXG4gICAgICAgICAgICAgICAgICAgIHJ1bl9pZDogc3RhdGUuaWQsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IHJvb3RUYWdzLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogcm9vdE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiByb290TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyb290RXZlbnRGaWx0ZXIuaW5jbHVkZUV2ZW50KGV2ZW50LCBzdGF0ZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBldmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBydW5Mb2c/LnN0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gRmluYWxseSwgeWllbGQgdGhlIGVuZCBldmVudCBmb3IgdGhlIHJvb3QgcnVubmFibGUuXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICAgICAgICBldmVudDogYG9uXyR7c3RhdGUudHlwZX1fZW5kYCxcbiAgICAgICAgICAgICAgICBuYW1lOiByb290TmFtZSxcbiAgICAgICAgICAgICAgICBydW5faWQ6IHN0YXRlLmlkLFxuICAgICAgICAgICAgICAgIHRhZ3M6IHJvb3RUYWdzLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiByb290TWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IHN0YXRlLmZpbmFsX291dHB1dCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyb290RXZlbnRGaWx0ZXIuaW5jbHVkZUV2ZW50KGV2ZW50LCBzdGF0ZS50eXBlKSlcbiAgICAgICAgICAgICAgICB5aWVsZCBldmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBpc1J1bm5hYmxlKHRoaW5nKSB7XG4gICAgICAgIHJldHVybiBpc1J1bm5hYmxlSW50ZXJmYWNlKHRoaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCBsaWZlY3ljbGUgbGlzdGVuZXJzIHRvIGEgUnVubmFibGUsIHJldHVybmluZyBhIG5ldyBSdW5uYWJsZS5cbiAgICAgKiBUaGUgUnVuIG9iamVjdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcnVuLCBpbmNsdWRpbmcgaXRzIGlkLFxuICAgICAqIHR5cGUsIGlucHV0LCBvdXRwdXQsIGVycm9yLCBzdGFydFRpbWUsIGVuZFRpbWUsIGFuZCBhbnkgdGFncyBvciBtZXRhZGF0YVxuICAgICAqIGFkZGVkIHRvIHRoZSBydW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbnMuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vblN0YXJ0IC0gQ2FsbGVkIGJlZm9yZSB0aGUgcnVubmFibGUgc3RhcnRzIHJ1bm5pbmcsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vbkVuZCAtIENhbGxlZCBhZnRlciB0aGUgcnVubmFibGUgZmluaXNoZXMgcnVubmluZywgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uRXJyb3IgLSBDYWxsZWQgaWYgdGhlIHJ1bm5hYmxlIHRocm93cyBhbiBlcnJvciwgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKi9cbiAgICB3aXRoTGlzdGVuZXJzKHsgb25TdGFydCwgb25FbmQsIG9uRXJyb3IsIH0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlQmluZGluZyh7XG4gICAgICAgICAgICBib3VuZDogdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZzoge30sXG4gICAgICAgICAgICBjb25maWdGYWN0b3JpZXM6IFtcbiAgICAgICAgICAgICAgICAoY29uZmlnKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBSb290TGlzdGVuZXJzVHJhY2VyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHJ1bm5hYmxlIHRvIGEgdG9vbC4gUmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGBSdW5uYWJsZVRvb2xMaWtlYFxuICAgICAqIHdoaWNoIGNvbnRhaW5zIHRoZSBydW5uYWJsZSwgbmFtZSwgZGVzY3JpcHRpb24gYW5kIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEB0ZW1wbGF0ZSB7VCBleHRlbmRzIFJ1bklucHV0ID0gUnVuSW5wdXR9IFJ1bklucHV0IC0gVGhlIGlucHV0IHR5cGUgb2YgdGhlIHJ1bm5hYmxlLiBTaG91bGQgYmUgdGhlIHNhbWUgYXMgdGhlIGBSdW5JbnB1dGAgdHlwZSBvZiB0aGUgcnVubmFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGRzXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtmaWVsZHMubmFtZV0gVGhlIG5hbWUgb2YgdGhlIHRvb2wuIElmIG5vdCBwcm92aWRlZCwgaXQgd2lsbCBkZWZhdWx0IHRvIHRoZSBuYW1lIG9mIHRoZSBydW5uYWJsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW2ZpZWxkcy5kZXNjcmlwdGlvbl0gVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSB0b29sLiBGYWxscyBiYWNrIHRvIHRoZSBkZXNjcmlwdGlvbiBvbiB0aGUgWm9kIHNjaGVtYSBpZiBub3QgcHJvdmlkZWQsIG9yIHVuZGVmaW5lZCBpZiBuZWl0aGVyIGFyZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge3ouWm9kVHlwZTxUPn0gW2ZpZWxkcy5zY2hlbWFdIFRoZSBab2Qgc2NoZW1hIGZvciB0aGUgaW5wdXQgb2YgdGhlIHRvb2wuIEluZmVycyB0aGUgWm9kIHR5cGUgZnJvbSB0aGUgaW5wdXQgdHlwZSBvZiB0aGUgcnVubmFibGUuXG4gICAgICogQHJldHVybnMge1J1bm5hYmxlVG9vbExpa2U8ei5ab2RUeXBlPFQ+LCBSdW5PdXRwdXQ+fSBBbiBpbnN0YW5jZSBvZiBgUnVubmFibGVUb29sTGlrZWAgd2hpY2ggaXMgYSBydW5uYWJsZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgdG9vbC5cbiAgICAgKi9cbiAgICBhc1Rvb2woZmllbGRzKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0UnVubmFibGVUb1Rvb2wodGhpcywgZmllbGRzKTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCBkZWxlZ2F0ZXMgY2FsbHMgdG8gYW5vdGhlciBydW5uYWJsZSB3aXRoIGEgc2V0IG9mIGt3YXJncy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlQmluZGluZyBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVCaW5kaW5nXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJvdW5kXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmZpZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrd2FyZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZmlnRmFjdG9yaWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm91bmQgPSBmaWVsZHMuYm91bmQ7XG4gICAgICAgIHRoaXMua3dhcmdzID0gZmllbGRzLmt3YXJncztcbiAgICAgICAgdGhpcy5jb25maWcgPSBmaWVsZHMuY29uZmlnO1xuICAgICAgICB0aGlzLmNvbmZpZ0ZhY3RvcmllcyA9IGZpZWxkcy5jb25maWdGYWN0b3JpZXM7XG4gICAgfVxuICAgIGdldE5hbWUoc3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLmdldE5hbWUoc3VmZml4KTtcbiAgICB9XG4gICAgYXN5bmMgX21lcmdlQ29uZmlnKC4uLm9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gbWVyZ2VDb25maWdzKHRoaXMuY29uZmlnLCAuLi5vcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG1lcmdlQ29uZmlncyhjb25maWcsIC4uLih0aGlzLmNvbmZpZ0ZhY3Rvcmllc1xuICAgICAgICAgICAgPyBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmNvbmZpZ0ZhY3Rvcmllcy5tYXAoYXN5bmMgKGNvbmZpZ0ZhY3RvcnkpID0+IGF3YWl0IGNvbmZpZ0ZhY3RvcnkoY29uZmlnKSkpXG4gICAgICAgICAgICA6IFtdKSk7XG4gICAgfVxuICAgIGJpbmQoa3dhcmdzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZCxcbiAgICAgICAgICAgIGt3YXJnczogeyAuLi50aGlzLmt3YXJncywgLi4ua3dhcmdzIH0sXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2l0aENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLFxuICAgICAgICAgICAga3dhcmdzOiB0aGlzLmt3YXJncyxcbiAgICAgICAgICAgIGNvbmZpZzogeyAuLi50aGlzLmNvbmZpZywgLi4uY29uZmlnIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3aXRoUmV0cnkoZmllbGRzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZC53aXRoUmV0cnkoZmllbGRzKSxcbiAgICAgICAgICAgIGt3YXJnczogdGhpcy5rd2FyZ3MsXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLmludm9rZShpbnB1dCwgYXdhaXQgdGhpcy5fbWVyZ2VDb25maWcoZW5zdXJlQ29uZmlnKG9wdGlvbnMpLCB0aGlzLmt3YXJncykpO1xuICAgIH1cbiAgICBhc3luYyBiYXRjaChpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICBjb25zdCBtZXJnZWRPcHRpb25zID0gQXJyYXkuaXNBcnJheShvcHRpb25zKVxuICAgICAgICAgICAgPyBhd2FpdCBQcm9taXNlLmFsbChvcHRpb25zLm1hcChhc3luYyAoaW5kaXZpZHVhbE9wdGlvbikgPT4gdGhpcy5fbWVyZ2VDb25maWcoZW5zdXJlQ29uZmlnKGluZGl2aWR1YWxPcHRpb24pLCB0aGlzLmt3YXJncykpKVxuICAgICAgICAgICAgOiBhd2FpdCB0aGlzLl9tZXJnZUNvbmZpZyhlbnN1cmVDb25maWcob3B0aW9ucyksIHRoaXMua3dhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmQuYmF0Y2goaW5wdXRzLCBtZXJnZWRPcHRpb25zLCBiYXRjaE9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLmJvdW5kLl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgYXdhaXQgdGhpcy5fbWVyZ2VDb25maWcoZW5zdXJlQ29uZmlnKG9wdGlvbnMpLCB0aGlzLmt3YXJncykpO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmQuc3RyZWFtKGlucHV0LCBhd2FpdCB0aGlzLl9tZXJnZUNvbmZpZyhlbnN1cmVDb25maWcob3B0aW9ucyksIHRoaXMua3dhcmdzKSk7XG4gICAgfVxuICAgIGFzeW5jICp0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLmJvdW5kLnRyYW5zZm9ybShnZW5lcmF0b3IsIGF3YWl0IHRoaXMuX21lcmdlQ29uZmlnKGVuc3VyZUNvbmZpZyhvcHRpb25zKSwgdGhpcy5rd2FyZ3MpKTtcbiAgICB9XG4gICAgc3RyZWFtRXZlbnRzKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBjb25zdCBvdXRlclRoaXMgPSB0aGlzO1xuICAgICAgICBjb25zdCBnZW5lcmF0b3IgPSBhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQqIG91dGVyVGhpcy5ib3VuZC5zdHJlYW1FdmVudHMoaW5wdXQsIHtcbiAgICAgICAgICAgICAgICAuLi4oYXdhaXQgb3V0ZXJUaGlzLl9tZXJnZUNvbmZpZyhlbnN1cmVDb25maWcob3B0aW9ucyksIG91dGVyVGhpcy5rd2FyZ3MpKSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24sXG4gICAgICAgICAgICB9LCBzdHJlYW1PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbUFzeW5jR2VuZXJhdG9yKGdlbmVyYXRvcigpKTtcbiAgICB9XG4gICAgc3RhdGljIGlzUnVubmFibGVCaW5kaW5nKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgdGhpbmdcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICkge1xuICAgICAgICByZXR1cm4gdGhpbmcuYm91bmQgJiYgUnVubmFibGUuaXNSdW5uYWJsZSh0aGluZy5ib3VuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgbGlmZWN5Y2xlIGxpc3RlbmVycyB0byBhIFJ1bm5hYmxlLCByZXR1cm5pbmcgYSBuZXcgUnVubmFibGUuXG4gICAgICogVGhlIFJ1biBvYmplY3QgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJ1biwgaW5jbHVkaW5nIGl0cyBpZCxcbiAgICAgKiB0eXBlLCBpbnB1dCwgb3V0cHV0LCBlcnJvciwgc3RhcnRUaW1lLCBlbmRUaW1lLCBhbmQgYW55IHRhZ3Mgb3IgbWV0YWRhdGFcbiAgICAgKiBhZGRlZCB0byB0aGUgcnVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25TdGFydCAtIENhbGxlZCBiZWZvcmUgdGhlIHJ1bm5hYmxlIHN0YXJ0cyBydW5uaW5nLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25FbmQgLSBDYWxsZWQgYWZ0ZXIgdGhlIHJ1bm5hYmxlIGZpbmlzaGVzIHJ1bm5pbmcsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vbkVycm9yIC0gQ2FsbGVkIGlmIHRoZSBydW5uYWJsZSB0aHJvd3MgYW4gZXJyb3IsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICovXG4gICAgd2l0aExpc3RlbmVycyh7IG9uU3RhcnQsIG9uRW5kLCBvbkVycm9yLCB9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVCaW5kaW5nKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLFxuICAgICAgICAgICAga3dhcmdzOiB0aGlzLmt3YXJncyxcbiAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgICAgICBjb25maWdGYWN0b3JpZXM6IFtcbiAgICAgICAgICAgICAgICAoY29uZmlnKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBSb290TGlzdGVuZXJzVHJhY2VyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCBkZWxlZ2F0ZXMgY2FsbHMgdG8gYW5vdGhlciBydW5uYWJsZVxuICogd2l0aCBlYWNoIGVsZW1lbnQgb2YgdGhlIGlucHV0IHNlcXVlbmNlLlxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGVFYWNoIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZUVhY2hcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYm91bmRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib3VuZCA9IGZpZWxkcy5ib3VuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZHMgdGhlIHJ1bm5hYmxlIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIGt3YXJncyBUaGUgYXJndW1lbnRzIHRvIGJpbmQgdGhlIHJ1bm5hYmxlIHdpdGguXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBSdW5uYWJsZUVhY2hgIGNsYXNzIHRoYXQgaXMgYm91bmQgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBiaW5kKGt3YXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlRWFjaCh7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZC5iaW5kKGt3YXJncyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBydW5uYWJsZSB3aXRoIHRoZSBzcGVjaWZpZWQgaW5wdXQgYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBpbnZva2UgdGhlIHJ1bm5hYmxlIHdpdGguXG4gICAgICogQHBhcmFtIGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiB0byBpbnZva2UgdGhlIHJ1bm5hYmxlIHdpdGguXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG91dHB1dCBvZiB0aGUgcnVubmFibGUuXG4gICAgICovXG4gICAgYXN5bmMgaW52b2tlKGlucHV0cywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsV2l0aENvbmZpZyh0aGlzLl9pbnZva2UsIGlucHV0cywgY29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbnZva2UgdGhlIHJ1bm5hYmxlIHdpdGggdGhlIHNwZWNpZmllZCBpbnB1dCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGludm9rZSB0aGUgcnVubmFibGUgd2l0aC5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIHRvIGludm9rZSB0aGUgcnVubmFibGUgd2l0aC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IG9mIHRoZSBydW5uYWJsZS5cbiAgICAgKi9cbiAgICBhc3luYyBfaW52b2tlKGlucHV0cywgY29uZmlnLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLmJhdGNoKGlucHV0cywgcGF0Y2hDb25maWcoY29uZmlnLCB7IGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgbGlmZWN5Y2xlIGxpc3RlbmVycyB0byBhIFJ1bm5hYmxlLCByZXR1cm5pbmcgYSBuZXcgUnVubmFibGUuXG4gICAgICogVGhlIFJ1biBvYmplY3QgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJ1biwgaW5jbHVkaW5nIGl0cyBpZCxcbiAgICAgKiB0eXBlLCBpbnB1dCwgb3V0cHV0LCBlcnJvciwgc3RhcnRUaW1lLCBlbmRUaW1lLCBhbmQgYW55IHRhZ3Mgb3IgbWV0YWRhdGFcbiAgICAgKiBhZGRlZCB0byB0aGUgcnVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25TdGFydCAtIENhbGxlZCBiZWZvcmUgdGhlIHJ1bm5hYmxlIHN0YXJ0cyBydW5uaW5nLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25FbmQgLSBDYWxsZWQgYWZ0ZXIgdGhlIHJ1bm5hYmxlIGZpbmlzaGVzIHJ1bm5pbmcsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vbkVycm9yIC0gQ2FsbGVkIGlmIHRoZSBydW5uYWJsZSB0aHJvd3MgYW4gZXJyb3IsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICovXG4gICAgd2l0aExpc3RlbmVycyh7IG9uU3RhcnQsIG9uRW5kLCBvbkVycm9yLCB9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVFYWNoKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLndpdGhMaXN0ZW5lcnMoeyBvblN0YXJ0LCBvbkVuZCwgb25FcnJvciB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBydW5uYWJsZXMgdGhhdCBjYW4gYmUgcmV0cmllZCBhXG4gKiBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzLlxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGVSZXRyeSBleHRlbmRzIFJ1bm5hYmxlQmluZGluZyB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlUmV0cnlcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heEF0dGVtcHROdW1iZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRmFpbGVkQXR0ZW1wdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogKCkgPT4geyB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heEF0dGVtcHROdW1iZXIgPSBmaWVsZHMubWF4QXR0ZW1wdE51bWJlciA/PyB0aGlzLm1heEF0dGVtcHROdW1iZXI7XG4gICAgICAgIHRoaXMub25GYWlsZWRBdHRlbXB0ID0gZmllbGRzLm9uRmFpbGVkQXR0ZW1wdCA/PyB0aGlzLm9uRmFpbGVkQXR0ZW1wdDtcbiAgICB9XG4gICAgX3BhdGNoQ29uZmlnRm9yUmV0cnkoYXR0ZW1wdCwgY29uZmlnLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IGF0dGVtcHQgPiAxID8gYHJldHJ5OmF0dGVtcHQ6JHthdHRlbXB0fWAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBwYXRjaENvbmZpZyhjb25maWcsIHsgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCh0YWcpIH0pO1xuICAgIH1cbiAgICBhc3luYyBfaW52b2tlKGlucHV0LCBjb25maWcsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIHBSZXRyeSgoYXR0ZW1wdE51bWJlcikgPT4gc3VwZXIuaW52b2tlKGlucHV0LCB0aGlzLl9wYXRjaENvbmZpZ0ZvclJldHJ5KGF0dGVtcHROdW1iZXIsIGNvbmZpZywgcnVuTWFuYWdlcikpLCB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25GYWlsZWRBdHRlbXB0OiAoZXJyb3IpID0+IHRoaXMub25GYWlsZWRBdHRlbXB0KGVycm9yLCBpbnB1dCksXG4gICAgICAgICAgICByZXRyaWVzOiBNYXRoLm1heCh0aGlzLm1heEF0dGVtcHROdW1iZXIgLSAxLCAwKSxcbiAgICAgICAgICAgIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGludm9rZXMgdGhlIHJ1bm5hYmxlIHdpdGggdGhlIHNwZWNpZmllZCBpbnB1dCwgcnVuIG1hbmFnZXIsXG4gICAgICogYW5kIGNvbmZpZy4gSXQgaGFuZGxlcyB0aGUgcmV0cnkgbG9naWMgYnkgY2F0Y2hpbmcgYW55IGVycm9ycyBhbmRcbiAgICAgKiByZWN1cnNpdmVseSBpbnZva2luZyBpdHNlbGYgd2l0aCB0aGUgdXBkYXRlZCBjb25maWcgZm9yIHRoZSBuZXh0IHJldHJ5XG4gICAgICogYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IGZvciB0aGUgcnVubmFibGUuXG4gICAgICogQHBhcmFtIHJ1bk1hbmFnZXIgVGhlIHJ1biBtYW5hZ2VyIGZvciB0aGUgcnVubmFibGUuXG4gICAgICogQHBhcmFtIGNvbmZpZyBUaGUgY29uZmlnIGZvciB0aGUgcnVubmFibGUuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG91dHB1dCBvZiB0aGUgcnVubmFibGUuXG4gICAgICovXG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKHRoaXMuX2ludm9rZSwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICAgIGFzeW5jIF9iYXRjaChpbnB1dHMsIGNvbmZpZ3MsIHJ1bk1hbmFnZXJzLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0c01hcCA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgcFJldHJ5KGFzeW5jIChhdHRlbXB0TnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nSW5kZXhlcyA9IGlucHV0c1xuICAgICAgICAgICAgICAgICAgICAubWFwKChfLCBpKSA9PiBpKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChpKSA9PiByZXN1bHRzTWFwW2kudG9TdHJpbmcoKV0gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNNYXBbaS50b1N0cmluZygpXSBpbnN0YW5jZW9mIEVycm9yKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdJbnB1dHMgPSByZW1haW5pbmdJbmRleGVzLm1hcCgoaSkgPT4gaW5wdXRzW2ldKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRjaGVkQ29uZmlncyA9IHJlbWFpbmluZ0luZGV4ZXMubWFwKChpKSA9PiB0aGlzLl9wYXRjaENvbmZpZ0ZvclJldHJ5KGF0dGVtcHROdW1iZXIsIGNvbmZpZ3M/LltpXSwgcnVuTWFuYWdlcnM/LltpXSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBzdXBlci5iYXRjaChyZW1haW5pbmdJbnB1dHMsIHBhdGNoZWRDb25maWdzLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmJhdGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRXhjZXB0aW9uczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgZmlyc3RFeGNlcHRpb247XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdE1hcEluZGV4ID0gcmVtYWluaW5nSW5kZXhlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdEV4Y2VwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RFeGNlcHRpb24gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdEV4Y2VwdGlvbi5pbnB1dCA9IHJlbWFpbmluZ0lucHV0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzTWFwW3Jlc3VsdE1hcEluZGV4LnRvU3RyaW5nKCldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RFeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZmlyc3RFeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgb25GYWlsZWRBdHRlbXB0OiAoZXJyb3IpID0+IHRoaXMub25GYWlsZWRBdHRlbXB0KGVycm9yLCBlcnJvci5pbnB1dCksXG4gICAgICAgICAgICAgICAgcmV0cmllczogTWF0aC5tYXgodGhpcy5tYXhBdHRlbXB0TnVtYmVyIC0gMSwgMCksXG4gICAgICAgICAgICAgICAgcmFuZG9taXplOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChiYXRjaE9wdGlvbnM/LnJldHVybkV4Y2VwdGlvbnMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXN1bHRzTWFwKVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IHBhcnNlSW50KGEsIDEwKSAtIHBhcnNlSW50KGIsIDEwKSlcbiAgICAgICAgICAgIC5tYXAoKGtleSkgPT4gcmVzdWx0c01hcFtwYXJzZUludChrZXksIDEwKV0pO1xuICAgIH1cbiAgICBhc3luYyBiYXRjaChpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmF0Y2hXaXRoQ29uZmlnKHRoaXMuX2JhdGNoLmJpbmQodGhpcyksIGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKTtcbiAgICB9XG59XG4vKipcbiAqIEEgc2VxdWVuY2Ugb2YgcnVubmFibGVzLCB3aGVyZSB0aGUgb3V0cHV0IG9mIGVhY2ggaXMgdGhlIGlucHV0IG9mIHRoZSBuZXh0LlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHByb21wdFRlbXBsYXRlID0gUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKFxuICogICBcIlRlbGwgbWUgYSBqb2tlIGFib3V0IHt0b3BpY31cIixcbiAqICk7XG4gKiBjb25zdCBjaGFpbiA9IFJ1bm5hYmxlU2VxdWVuY2UuZnJvbShbcHJvbXB0VGVtcGxhdGUsIG5ldyBDaGF0T3BlbkFJKHt9KV0pO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hhaW4uaW52b2tlKHsgdG9waWM6IFwiYmVhcnNcIiB9KTtcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGVTZXF1ZW5jZSBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVTZXF1ZW5jZVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmlyc3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWlkZGxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGFzdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmlyc3QgPSBmaWVsZHMuZmlyc3Q7XG4gICAgICAgIHRoaXMubWlkZGxlID0gZmllbGRzLm1pZGRsZSA/PyB0aGlzLm1pZGRsZTtcbiAgICAgICAgdGhpcy5sYXN0ID0gZmllbGRzLmxhc3Q7XG4gICAgICAgIHRoaXMubmFtZSA9IGZpZWxkcy5uYW1lO1xuICAgIH1cbiAgICBnZXQgc3RlcHMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5maXJzdCwgLi4udGhpcy5taWRkbGUsIHRoaXMubGFzdF07XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcoY29uZmlnKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dCwgXCJpbnB1dFwiKSwgY29uZmlnLnJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWc/LnJ1bk5hbWUpO1xuICAgICAgICBkZWxldGUgY29uZmlnLnJ1bklkO1xuICAgICAgICBsZXQgbmV4dFN0ZXBJbnB1dCA9IGlucHV0O1xuICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsU3RlcHMgPSBbdGhpcy5maXJzdCwgLi4udGhpcy5taWRkbGVdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbml0aWFsU3RlcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gaW5pdGlhbFN0ZXBzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBzdGVwLmludm9rZShuZXh0U3RlcElucHV0LCBwYXRjaENvbmZpZyhjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZChgc2VxOnN0ZXA6JHtpICsgMX1gKSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgbmV4dFN0ZXBJbnB1dCA9IGF3YWl0IHJhY2VXaXRoU2lnbmFsKHByb21pc2UsIG9wdGlvbnM/LnNpZ25hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUeXBlU2NyaXB0IGNhbid0IGRldGVjdCB0aGF0IHRoZSBsYXN0IG91dHB1dCBvZiB0aGUgc2VxdWVuY2UgcmV0dXJucyBSdW5PdXRwdXQsIHNvIGNhbGwgaXQgb3V0IG9mIHRoZSBsb29wIGhlcmVcbiAgICAgICAgICAgIGlmIChvcHRpb25zPy5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYm9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBhd2FpdCB0aGlzLmxhc3QuaW52b2tlKG5leHRTdGVwSW5wdXQsIHBhdGNoQ29uZmlnKGNvbmZpZywge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYHNlcTpzdGVwOiR7dGhpcy5zdGVwcy5sZW5ndGh9YCksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3QoZmluYWxPdXRwdXQsIFwib3V0cHV0XCIpKTtcbiAgICAgICAgcmV0dXJuIGZpbmFsT3V0cHV0O1xuICAgIH1cbiAgICBhc3luYyBiYXRjaChpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWdMaXN0ID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChjb25maWdMaXN0Lm1hcChnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcpKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChjYWxsYmFja01hbmFnZXJzLm1hcChhc3luYyAoY2FsbGJhY2tNYW5hZ2VyLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVTdGFydFJlcyA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcj8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0c1tpXSwgXCJpbnB1dFwiKSwgY29uZmlnTGlzdFtpXS5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnTGlzdFtpXS5ydW5OYW1lKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWdMaXN0W2ldLnJ1bklkO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0YXJ0UmVzO1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCBuZXh0U3RlcElucHV0cyA9IGlucHV0cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGVwcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLnN0ZXBzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBzdGVwLmJhdGNoKG5leHRTdGVwSW5wdXRzLCBydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIsIGopID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRSdW5NYW5hZ2VyID0gcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYHNlcTpzdGVwOiR7aSArIDF9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRjaENvbmZpZyhjb25maWdMaXN0W2pdLCB7IGNhbGxiYWNrczogY2hpbGRSdW5NYW5hZ2VyIH0pO1xuICAgICAgICAgICAgICAgIH0pLCBiYXRjaE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIG5leHRTdGVwSW5wdXRzID0gYXdhaXQgcmFjZVdpdGhTaWduYWwocHJvbWlzZSwgY29uZmlnTGlzdFswXT8uc2lnbmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpKSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChuZXh0U3RlcElucHV0cywgXCJvdXRwdXRcIikpKSk7XG4gICAgICAgIHJldHVybiBuZXh0U3RlcElucHV0cztcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7IHJ1bklkLCAuLi5vdGhlck9wdGlvbnMgfSA9IG9wdGlvbnMgPz8ge307XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXQsIFwiaW5wdXRcIiksIHJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvdGhlck9wdGlvbnM/LnJ1bk5hbWUpO1xuICAgICAgICBjb25zdCBzdGVwcyA9IFt0aGlzLmZpcnN0LCAuLi50aGlzLm1pZGRsZSwgdGhpcy5sYXN0XTtcbiAgICAgICAgbGV0IGNvbmNhdFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIGxldCBmaW5hbE91dHB1dDtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24qIGlucHV0R2VuZXJhdG9yKCkge1xuICAgICAgICAgICAgeWllbGQgaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBmaW5hbEdlbmVyYXRvciA9IHN0ZXBzWzBdLnRyYW5zZm9ybShpbnB1dEdlbmVyYXRvcigpLCBwYXRjaENvbmZpZyhvdGhlck9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKGBzZXE6c3RlcDoxYCksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0ZXBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcCA9IHN0ZXBzW2ldO1xuICAgICAgICAgICAgICAgIGZpbmFsR2VuZXJhdG9yID0gYXdhaXQgc3RlcC50cmFuc2Zvcm0oZmluYWxHZW5lcmF0b3IsIHBhdGNoQ29uZmlnKG90aGVyT3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKGBzZXE6c3RlcDoke2kgKyAxfWApLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgZmluYWxHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmNhdFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNvbmNhdChmaW5hbE91dHB1dCwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25jYXRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChmaW5hbE91dHB1dCwgXCJvdXRwdXRcIikpO1xuICAgIH1cbiAgICBnZXRHcmFwaChjb25maWcpIHtcbiAgICAgICAgY29uc3QgZ3JhcGggPSBuZXcgR3JhcGgoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IGN1cnJlbnRMYXN0Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RlcHMuZm9yRWFjaCgoc3RlcCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBHcmFwaCA9IHN0ZXAuZ2V0R3JhcGgoY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHN0ZXBHcmFwaC50cmltRmlyc3ROb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IHRoaXMuc3RlcHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHN0ZXBHcmFwaC50cmltTGFzdE5vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyYXBoLmV4dGVuZChzdGVwR3JhcGgpO1xuICAgICAgICAgICAgY29uc3Qgc3RlcEZpcnN0Tm9kZSA9IHN0ZXBHcmFwaC5maXJzdE5vZGUoKTtcbiAgICAgICAgICAgIGlmICghc3RlcEZpcnN0Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUnVubmFibGUgJHtzdGVwfSBoYXMgbm8gZmlyc3Qgbm9kZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMYXN0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGdyYXBoLmFkZEVkZ2UoY3VycmVudExhc3ROb2RlLCBzdGVwRmlyc3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRMYXN0Tm9kZSA9IHN0ZXBHcmFwaC5sYXN0Tm9kZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdyYXBoO1xuICAgIH1cbiAgICBwaXBlKGNvZXJjZWFibGUpIHtcbiAgICAgICAgaWYgKFJ1bm5hYmxlU2VxdWVuY2UuaXNSdW5uYWJsZVNlcXVlbmNlKGNvZXJjZWFibGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlU2VxdWVuY2Uoe1xuICAgICAgICAgICAgICAgIGZpcnN0OiB0aGlzLmZpcnN0LFxuICAgICAgICAgICAgICAgIG1pZGRsZTogdGhpcy5taWRkbGUuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0LFxuICAgICAgICAgICAgICAgICAgICBjb2VyY2VhYmxlLmZpcnN0LFxuICAgICAgICAgICAgICAgICAgICAuLi5jb2VyY2VhYmxlLm1pZGRsZSxcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBsYXN0OiBjb2VyY2VhYmxlLmxhc3QsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lID8/IGNvZXJjZWFibGUubmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVNlcXVlbmNlKHtcbiAgICAgICAgICAgICAgICBmaXJzdDogdGhpcy5maXJzdCxcbiAgICAgICAgICAgICAgICBtaWRkbGU6IFsuLi50aGlzLm1pZGRsZSwgdGhpcy5sYXN0XSxcbiAgICAgICAgICAgICAgICBsYXN0OiBfY29lcmNlVG9SdW5uYWJsZShjb2VyY2VhYmxlKSxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBpc1J1bm5hYmxlU2VxdWVuY2UodGhpbmcpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpbmcubWlkZGxlKSAmJiBSdW5uYWJsZS5pc1J1bm5hYmxlKHRoaW5nKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgZnJvbShbZmlyc3QsIC4uLnJ1bm5hYmxlc10sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVNlcXVlbmNlKHtcbiAgICAgICAgICAgIGZpcnN0OiBfY29lcmNlVG9SdW5uYWJsZShmaXJzdCksXG4gICAgICAgICAgICBtaWRkbGU6IHJ1bm5hYmxlcy5zbGljZSgwLCAtMSkubWFwKF9jb2VyY2VUb1J1bm5hYmxlKSxcbiAgICAgICAgICAgIGxhc3Q6IF9jb2VyY2VUb1J1bm5hYmxlKHJ1bm5hYmxlc1tydW5uYWJsZXMubGVuZ3RoIC0gMV0pLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgcnVucyBhIG1hcHBpbmcgb2YgcnVubmFibGVzIGluIHBhcmFsbGVsLFxuICogYW5kIHJldHVybnMgYSBtYXBwaW5nIG9mIHRoZWlyIG91dHB1dHMuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgbWFwQ2hhaW4gPSBSdW5uYWJsZU1hcC5mcm9tKHtcbiAqICAgam9rZTogUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKFwiVGVsbCBtZSBhIGpva2UgYWJvdXQge3RvcGljfVwiKS5waXBlKFxuICogICAgIG5ldyBDaGF0QW50aHJvcGljKHt9KSxcbiAqICAgKSxcbiAqICAgcG9lbTogUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKFwid3JpdGUgYSAyLWxpbmUgcG9lbSBhYm91dCB7dG9waWN9XCIpLnBpcGUoXG4gKiAgICAgbmV3IENoYXRBbnRocm9waWMoe30pLFxuICogICApLFxuICogfSk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBtYXBDaGFpbi5pbnZva2UoeyB0b3BpYzogXCJiZWFyXCIgfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlTWFwIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZU1hcFwiO1xuICAgIH1cbiAgICBnZXRTdGVwc0tleXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0ZXBzKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RlcHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGVwcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmaWVsZHMuc3RlcHMpKSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXBzW2tleV0gPSBfY29lcmNlVG9SdW5uYWJsZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb20oc3RlcHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZU1hcCh7IHN0ZXBzIH0pO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIHtcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICB9LCBjb25maWcucnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZz8ucnVuTmFtZSk7XG4gICAgICAgIGRlbGV0ZSBjb25maWcucnVuSWQ7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLnN0ZXBzKS5tYXAoYXN5bmMgKFtrZXksIHJ1bm5hYmxlXSkgPT4ge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gYXdhaXQgcnVubmFibGUuaW52b2tlKGlucHV0LCBwYXRjaENvbmZpZyhjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZChgbWFwOmtleToke2tleX1gKSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhY2VXaXRoU2lnbmFsKFByb21pc2UuYWxsKHByb21pc2VzKSwgb3B0aW9ucz8uc2lnbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQob3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oZ2VuZXJhdG9yLCBydW5NYW5hZ2VyLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIHNoYWxsb3cgY29weSBzdGVwcyB0byBpZ25vcmUgY2hhbmdlcyB3aGlsZSBpdGVyYXRpbmdcbiAgICAgICAgY29uc3Qgc3RlcHMgPSB7IC4uLnRoaXMuc3RlcHMgfTtcbiAgICAgICAgLy8gZWFjaCBzdGVwIGdldHMgYSBjb3B5IG9mIHRoZSBpbnB1dCBpdGVyYXRvclxuICAgICAgICBjb25zdCBpbnB1dENvcGllcyA9IGF0ZWUoZ2VuZXJhdG9yLCBPYmplY3Qua2V5cyhzdGVwcykubGVuZ3RoKTtcbiAgICAgICAgLy8gc3RhcnQgdGhlIGZpcnN0IGl0ZXJhdGlvbiBvZiBlYWNoIG91dHB1dCBpdGVyYXRvclxuICAgICAgICBjb25zdCB0YXNrcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoc3RlcHMpLm1hcCgoW2tleSwgcnVubmFibGVdLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnZW4gPSBydW5uYWJsZS50cmFuc2Zvcm0oaW5wdXRDb3BpZXNbaV0sIHBhdGNoQ29uZmlnKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKGBtYXA6a2V5OiR7a2V5fWApLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIFtrZXksIGdlbi5uZXh0KCkudGhlbigocmVzdWx0KSA9PiAoeyBrZXksIGdlbiwgcmVzdWx0IH0pKV07XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8geWllbGQgY2h1bmtzIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSxcbiAgICAgICAgLy8gc3RhcnRpbmcgbmV3IGl0ZXJhdGlvbnMgYXMgbmVlZGVkLFxuICAgICAgICAvLyB1bnRpbCBhbGwgaXRlcmF0b3JzIGFyZSBkb25lXG4gICAgICAgIHdoaWxlICh0YXNrcy5zaXplKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yYWNlKHRhc2tzLnZhbHVlcygpKTtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCByZXN1bHQsIGdlbiB9ID0gYXdhaXQgcmFjZVdpdGhTaWduYWwocHJvbWlzZSwgb3B0aW9ucz8uc2lnbmFsKTtcbiAgICAgICAgICAgIHRhc2tzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHsgW2tleV06IHJlc3VsdC52YWx1ZSB9O1xuICAgICAgICAgICAgICAgIHRhc2tzLnNldChrZXksIGdlbi5uZXh0KCkudGhlbigocmVzdWx0KSA9PiAoeyBrZXksIGdlbiwgcmVzdWx0IH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhnZW5lcmF0b3IsIHRoaXMuX3RyYW5zZm9ybS5iaW5kKHRoaXMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBnZW5lcmF0b3IoKSB7XG4gICAgICAgICAgICB5aWVsZCBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRHZW5lcmF0b3IgPSBuZXcgQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAoe1xuICAgICAgICAgICAgZ2VuZXJhdG9yOiB0aGlzLnRyYW5zZm9ybShnZW5lcmF0b3IoKSwgY29uZmlnKSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHdyYXBwZWRHZW5lcmF0b3Iuc2V0dXA7XG4gICAgICAgIHJldHVybiBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcih3cmFwcGVkR2VuZXJhdG9yKTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCB3cmFwcyBhIHRyYWNlZCBMYW5nU21pdGggZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZVRyYWNlYWJsZSBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnVuY1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWlzVHJhY2VhYmxlRnVuY3Rpb24oZmllbGRzLmZ1bmMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW5uYWJsZVRyYWNlYWJsZSByZXF1aXJlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgd3JhcHBlZCBpbiB0cmFjZWFibGUgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnVuYyA9IGZpZWxkcy5mdW5jO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgW2NvbmZpZ10gPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCAxKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmZ1bmMocGF0Y2hDb25maWcoY29uZmlnLCB7IGNhbGxiYWNrcyB9KSwgaW5wdXQpO1xuICAgICAgICByZXR1cm4gcmFjZVdpdGhTaWduYWwocHJvbWlzZSwgY29uZmlnPy5zaWduYWwpO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFtjb25maWddID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgMSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuaW52b2tlKGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGlzQXN5bmNJdGVyYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uZmlnPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgeWllbGQgaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJdGVyYXRvcihyZXN1bHQpKSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZz8uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gcmVzdWx0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgeWllbGQgc3RhdGUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShmdW5jKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVUcmFjZWFibGUoeyBmdW5jIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydE5vblRyYWNlYWJsZUZ1bmN0aW9uKGZ1bmMpIHtcbiAgICBpZiAoaXNUcmFjZWFibGVGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW5uYWJsZUxhbWJkYSByZXF1aXJlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgbm90IHdyYXBwZWQgaW4gdHJhY2VhYmxlIGhpZ2hlci1vcmRlciBmdW5jdGlvbi4gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLlwiKTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCBydW5zIGEgY2FsbGFibGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZUxhbWJkYSBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVMYW1iZGFcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGlmIChpc1RyYWNlYWJsZUZ1bmN0aW9uKGZpZWxkcy5mdW5jKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuICAgICAgICAgICAgcmV0dXJuIFJ1bm5hYmxlVHJhY2VhYmxlLmZyb20oZmllbGRzLmZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZ1bmNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0Tm9uVHJhY2VhYmxlRnVuY3Rpb24oZmllbGRzLmZ1bmMpO1xuICAgICAgICB0aGlzLmZ1bmMgPSBmaWVsZHMuZnVuYztcbiAgICB9XG4gICAgc3RhdGljIGZyb20oZnVuYykge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlTGFtYmRhKHtcbiAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfaW52b2tlKGlucHV0LCBjb25maWcsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ29uZmlnID0gcGF0Y2hDb25maWcoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpLFxuICAgICAgICAgICAgICAgIHJlY3Vyc2lvbkxpbWl0OiAoY29uZmlnPy5yZWN1cnNpb25MaW1pdCA/PyBERUZBVUxUX1JFQ1VSU0lPTl9MSU1JVCkgLSAxLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2b2lkIEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZyhjaGlsZENvbmZpZywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBhd2FpdCB0aGlzLmZ1bmMoaW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjaGlsZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQgJiYgUnVubmFibGUuaXNSdW5uYWJsZShvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnPy5yZWN1cnNpb25MaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY3Vyc2lvbiBsaW1pdCByZWFjaGVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGF3YWl0IG91dHB1dC5pbnZva2UoaW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jaGlsZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN1cnNpb25MaW1pdDogKGNoaWxkQ29uZmlnLnJlY3Vyc2lvbkxpbWl0ID8/IERFRkFVTFRfUkVDVVJTSU9OX0xJTUlUKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FzeW5jSXRlcmFibGUob3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBjb25zdW1lQXN5bmNJdGVyYWJsZUluQ29udGV4dChjaGlsZENvbmZpZywgb3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZz8uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIGEgYmVzdCBlZmZvcnQgdG8gZ2F0aGVyLCBmb3IgYW55IHR5cGUgdGhhdCBzdXBwb3J0cyBjb25jYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjb25jYXQoZmluYWxPdXRwdXQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGZpbmFsT3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSXRlcmFibGVJdGVyYXRvcihvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNvbnN1bWVJdGVyYXRvckluQ29udGV4dChjaGlsZENvbmZpZywgb3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZz8uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIGEgYmVzdCBlZmZvcnQgdG8gZ2F0aGVyLCBmb3IgYW55IHR5cGUgdGhhdCBzdXBwb3J0cyBjb25jYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjb25jYXQoZmluYWxPdXRwdXQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGZpbmFsT3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsV2l0aENvbmZpZyh0aGlzLl9pbnZva2UsIGlucHV0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oZ2VuZXJhdG9yLCBydW5NYW5hZ2VyLCBjb25maWcpIHtcbiAgICAgICAgbGV0IGZpbmFsQ2h1bms7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBpZiAoZmluYWxDaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmluYWxDaHVuayA9IGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBhIGJlc3QgZWZmb3J0IHRvIGdhdGhlciwgZm9yIGFueSB0eXBlIHRoYXQgc3VwcG9ydHMgY29uY2F0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmsgPSBjb25jYXQoZmluYWxDaHVuaywgY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbENodW5rID0gY2h1bms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkQ29uZmlnID0gcGF0Y2hDb25maWcoY29uZmlnLCB7XG4gICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICByZWN1cnNpb25MaW1pdDogKGNvbmZpZz8ucmVjdXJzaW9uTGltaXQgPz8gREVGQVVMVF9SRUNVUlNJT05fTElNSVQpIC0gMSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZvaWQgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKGNoaWxkQ29uZmlnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5mdW5jKGZpbmFsQ2h1bmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjaGlsZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dHB1dCAmJiBSdW5uYWJsZS5pc1J1bm5hYmxlKG91dHB1dCkpIHtcbiAgICAgICAgICAgIGlmIChjb25maWc/LnJlY3Vyc2lvbkxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjdXJzaW9uIGxpbWl0IHJlYWNoZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgb3V0cHV0LnN0cmVhbShmaW5hbENodW5rLCBjaGlsZENvbmZpZyk7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQXN5bmNJdGVyYWJsZShvdXRwdXQpKSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNvbnN1bWVBc3luY0l0ZXJhYmxlSW5Db250ZXh0KGNoaWxkQ29uZmlnLCBvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNJdGVyYWJsZUl0ZXJhdG9yKG91dHB1dCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY29uc3VtZUl0ZXJhdG9ySW5Db250ZXh0KGNoaWxkQ29uZmlnLCBvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhnZW5lcmF0b3IsIHRoaXMuX3RyYW5zZm9ybS5iaW5kKHRoaXMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBnZW5lcmF0b3IoKSB7XG4gICAgICAgICAgICB5aWVsZCBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRHZW5lcmF0b3IgPSBuZXcgQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAoe1xuICAgICAgICAgICAgZ2VuZXJhdG9yOiB0aGlzLnRyYW5zZm9ybShnZW5lcmF0b3IoKSwgY29uZmlnKSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHdyYXBwZWRHZW5lcmF0b3Iuc2V0dXA7XG4gICAgICAgIHJldHVybiBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcih3cmFwcGVkR2VuZXJhdG9yKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUnVubmFibGVQYXJhbGxlbCBleHRlbmRzIFJ1bm5hYmxlTWFwIHtcbn1cbi8qKlxuICogQSBSdW5uYWJsZSB0aGF0IGNhbiBmYWxsYmFjayB0byBvdGhlciBSdW5uYWJsZXMgaWYgaXQgZmFpbHMuXG4gKiBFeHRlcm5hbCBBUElzIChlLmcuLCBBUElzIGZvciBhIGxhbmd1YWdlIG1vZGVsKSBtYXkgYXQgdGltZXMgZXhwZXJpZW5jZVxuICogZGVncmFkZWQgcGVyZm9ybWFuY2Ugb3IgZXZlbiBkb3dudGltZS5cbiAqXG4gKiBJbiB0aGVzZSBjYXNlcywgaXQgY2FuIGJlIHVzZWZ1bCB0byBoYXZlIGEgZmFsbGJhY2sgUnVubmFibGUgdGhhdCBjYW4gYmVcbiAqIHVzZWQgaW4gcGxhY2Ugb2YgdGhlIG9yaWdpbmFsIFJ1bm5hYmxlIChlLmcuLCBmYWxsYmFjayB0byBhbm90aGVyIExMTSBwcm92aWRlcikuXG4gKlxuICogRmFsbGJhY2tzIGNhbiBiZSBkZWZpbmVkIGF0IHRoZSBsZXZlbCBvZiBhIHNpbmdsZSBSdW5uYWJsZSwgb3IgYXQgdGhlIGxldmVsXG4gKiBvZiBhIGNoYWluIG9mIFJ1bm5hYmxlcy4gRmFsbGJhY2tzIGFyZSB0cmllZCBpbiBvcmRlciB1bnRpbCBvbmUgc3VjY2VlZHMgb3JcbiAqIGFsbCBmYWlsLlxuICpcbiAqIFdoaWxlIHlvdSBjYW4gaW5zdGFudGlhdGUgYSBgUnVubmFibGVXaXRoRmFsbGJhY2tzYCBkaXJlY3RseSwgaXQgaXMgdXN1YWxseVxuICogbW9yZSBjb252ZW5pZW50IHRvIHVzZSB0aGUgYHdpdGhGYWxsYmFja3NgIG1ldGhvZCBvbiBhbiBleGlzdGluZyBSdW5uYWJsZS5cbiAqXG4gKiBXaGVuIHN0cmVhbWluZywgZmFsbGJhY2tzIHdpbGwgb25seSBiZSBjYWxsZWQgb24gZmFpbHVyZXMgZHVyaW5nIHRoZSBpbml0aWFsXG4gKiBzdHJlYW0gY3JlYXRpb24uIEVycm9ycyB0aGF0IG9jY3VyIGFmdGVyIGEgc3RyZWFtIHN0YXJ0cyB3aWxsIG5vdCBmYWxsYmFja1xuICogdG8gdGhlIG5leHQgUnVubmFibGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZVdpdGhGYWxsYmFja3MgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlV2l0aEZhbGxiYWNrc1wiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5uYWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmYWxsYmFja3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ydW5uYWJsZSA9IGZpZWxkcy5ydW5uYWJsZTtcbiAgICAgICAgdGhpcy5mYWxsYmFja3MgPSBmaWVsZHMuZmFsbGJhY2tzO1xuICAgIH1cbiAgICAqcnVubmFibGVzKCkge1xuICAgICAgICB5aWVsZCB0aGlzLnJ1bm5hYmxlO1xuICAgICAgICBmb3IgKGNvbnN0IGZhbGxiYWNrIG9mIHRoaXMuZmFsbGJhY2tzKSB7XG4gICAgICAgICAgICB5aWVsZCBmYWxsYmFjaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7IHJ1bklkLCAuLi5vdGhlckNvbmZpZ0ZpZWxkcyB9ID0gY29uZmlnO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0LCBcImlucHV0XCIpLCBydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3RoZXJDb25maWdGaWVsZHM/LnJ1bk5hbWUpO1xuICAgICAgICBsZXQgZmlyc3RFcnJvcjtcbiAgICAgICAgZm9yIChjb25zdCBydW5uYWJsZSBvZiB0aGlzLnJ1bm5hYmxlcygpKSB7XG4gICAgICAgICAgICBjb25maWc/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcnVubmFibGUuaW52b2tlKGlucHV0LCBwYXRjaENvbmZpZyhvdGhlckNvbmZpZ0ZpZWxkcywgeyBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCkgfSkpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3Qob3V0cHV0LCBcIm91dHB1dFwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEVycm9yID0gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0RXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZXJyb3Igc3RvcmVkIGF0IGVuZCBvZiBmYWxsYmFjay5cIik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihmaXJzdEVycm9yKTtcbiAgICAgICAgdGhyb3cgZmlyc3RFcnJvcjtcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgcnVuSWQsIC4uLm90aGVyQ29uZmlnRmllbGRzIH0gPSBjb25maWc7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXQsIFwiaW5wdXRcIiksIHJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvdGhlckNvbmZpZ0ZpZWxkcz8ucnVuTmFtZSk7XG4gICAgICAgIGxldCBmaXJzdEVycm9yO1xuICAgICAgICBsZXQgc3RyZWFtO1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bm5hYmxlIG9mIHRoaXMucnVubmFibGVzKCkpIHtcbiAgICAgICAgICAgIGNvbmZpZz8uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRDb25maWcgPSBwYXRjaENvbmZpZyhvdGhlckNvbmZpZ0ZpZWxkcywge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdHJlYW0gPSBhd2FpdCBydW5uYWJsZS5zdHJlYW0oaW5wdXQsIGNoaWxkQ29uZmlnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEVycm9yID0gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGZpcnN0RXJyb3IgPz8gbmV3IEVycm9yKFwiTm8gZXJyb3Igc3RvcmVkIGF0IGVuZCBvZiBmYWxsYmFjay5cIik7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCA9PT0gdW5kZWZpbmVkID8gb3V0cHV0IDogY29uY2F0KG91dHB1dCwgY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KG91dHB1dCwgXCJvdXRwdXRcIikpO1xuICAgIH1cbiAgICBhc3luYyBiYXRjaChpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICBpZiAoYmF0Y2hPcHRpb25zPy5yZXR1cm5FeGNlcHRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZ0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKGNvbmZpZ0xpc3QubWFwKChjb25maWcpID0+IGdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY2FsbGJhY2tNYW5hZ2Vycy5tYXAoYXN5bmMgKGNhbGxiYWNrTWFuYWdlciwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlU3RhcnRSZXMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXI/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dHNbaV0sIFwiaW5wdXRcIiksIGNvbmZpZ0xpc3RbaV0ucnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZ0xpc3RbaV0ucnVuTmFtZSk7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnTGlzdFtpXS5ydW5JZDtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdGFydFJlcztcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgZmlyc3RFcnJvcjtcbiAgICAgICAgZm9yIChjb25zdCBydW5uYWJsZSBvZiB0aGlzLnJ1bm5hYmxlcygpKSB7XG4gICAgICAgICAgICBjb25maWdMaXN0WzBdLnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0cyA9IGF3YWl0IHJ1bm5hYmxlLmJhdGNoKGlucHV0cywgcnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyLCBqKSA9PiBwYXRjaENvbmZpZyhjb25maWdMaXN0W2pdLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSxcbiAgICAgICAgICAgICAgICB9KSksIGJhdGNoT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyLCBpKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KG91dHB1dHNbaV0sIFwib3V0cHV0XCIpKSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RFcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZpcnN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGVycm9yIHN0b3JlZCBhdCBlbmQgb2YgZmFsbGJhY2tzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZmlyc3RFcnJvcikpKTtcbiAgICAgICAgdGhyb3cgZmlyc3RFcnJvcjtcbiAgICB9XG59XG4vLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGUgY29tcGlsZXIgbmVlZHMgaGVscCBlbGltaW5hdGluZyBFcnJvciBhcyBhIFJ1bk91dHB1dCB0eXBlXG5leHBvcnQgZnVuY3Rpb24gX2NvZXJjZVRvUnVubmFibGUoY29lcmNlYWJsZSkge1xuICAgIGlmICh0eXBlb2YgY29lcmNlYWJsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVMYW1iZGEoeyBmdW5jOiBjb2VyY2VhYmxlIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChSdW5uYWJsZS5pc1J1bm5hYmxlKGNvZXJjZWFibGUpKSB7XG4gICAgICAgIHJldHVybiBjb2VyY2VhYmxlO1xuICAgIH1cbiAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShjb2VyY2VhYmxlKSAmJiB0eXBlb2YgY29lcmNlYWJsZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCBydW5uYWJsZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoY29lcmNlYWJsZSkpIHtcbiAgICAgICAgICAgIHJ1bm5hYmxlc1trZXldID0gX2NvZXJjZVRvUnVubmFibGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVNYXAoe1xuICAgICAgICAgICAgc3RlcHM6IHJ1bm5hYmxlcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgUnVubmFibGUsIGZ1bmN0aW9uIG9yIG9iamVjdC5cXG5JbnN0ZWFkIGdvdCBhbiB1bnN1cHBvcnRlZCB0eXBlLmApO1xuICAgIH1cbn1cbi8qKlxuICogQSBydW5uYWJsZSB0aGF0IGFzc2lnbnMga2V5LXZhbHVlIHBhaXJzIHRvIGlucHV0cyBvZiB0eXBlIGBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPmAuXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZUFzc2lnbiBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVBc3NpZ25cIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgaWYgKGZpZWxkcyBpbnN0YW5jZW9mIFJ1bm5hYmxlTWFwKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsgbWFwcGVyOiBmaWVsZHMgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1hcHBlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcHBlciA9IGZpZWxkcy5tYXBwZXI7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtYXBwZXJSZXN1bHQgPSBhd2FpdCB0aGlzLm1hcHBlci5pbnZva2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uaW5wdXQsXG4gICAgICAgICAgICAuLi5tYXBwZXJSZXN1bHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jICpfdHJhbnNmb3JtKGdlbmVyYXRvciwgcnVuTWFuYWdlciwgb3B0aW9ucykge1xuICAgICAgICAvLyBjb2xsZWN0IG1hcHBlciBrZXlzXG4gICAgICAgIGNvbnN0IG1hcHBlcktleXMgPSB0aGlzLm1hcHBlci5nZXRTdGVwc0tleXMoKTtcbiAgICAgICAgLy8gY3JlYXRlIHR3byBpbnB1dCBnZW5zLCBvbmUgZm9yIHRoZSBtYXBwZXIsIG9uZSBmb3IgdGhlIGlucHV0XG4gICAgICAgIGNvbnN0IFtmb3JQYXNzdGhyb3VnaCwgZm9yTWFwcGVyXSA9IGF0ZWUoZ2VuZXJhdG9yKTtcbiAgICAgICAgLy8gY3JlYXRlIG1hcHBlciBvdXRwdXQgZ2VuXG4gICAgICAgIGNvbnN0IG1hcHBlck91dHB1dCA9IHRoaXMubWFwcGVyLnRyYW5zZm9ybShmb3JNYXBwZXIsIHBhdGNoQ29uZmlnKG9wdGlvbnMsIHsgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpIH0pKTtcbiAgICAgICAgLy8gc3RhcnQgdGhlIG1hcHBlclxuICAgICAgICBjb25zdCBmaXJzdE1hcHBlckNodW5rUHJvbWlzZSA9IG1hcHBlck91dHB1dC5uZXh0KCk7XG4gICAgICAgIC8vIHlpZWxkIHRoZSBwYXNzdGhyb3VnaFxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGZvclBhc3N0aHJvdWdoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSdW5uYWJsZUFzc2lnbiBjYW4gb25seSBiZSB1c2VkIHdpdGggb2JqZWN0cyBhcyBpbnB1dCwgZ290ICR7dHlwZW9mIGNodW5rfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY2h1bmspLmZpbHRlcigoW2tleV0pID0+ICFtYXBwZXJLZXlzLmluY2x1ZGVzKGtleSkpKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhmaWx0ZXJlZCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGZpbHRlcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHlpZWxkIHRoZSBtYXBwZXIgb3V0cHV0XG4gICAgICAgIHlpZWxkIChhd2FpdCBmaXJzdE1hcHBlckNodW5rUHJvbWlzZSkudmFsdWU7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgbWFwcGVyT3V0cHV0KSB7XG4gICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1TdHJlYW1XaXRoQ29uZmlnKGdlbmVyYXRvciwgdGhpcy5fdHJhbnNmb3JtLmJpbmQodGhpcyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRvcigpIHtcbiAgICAgICAgICAgIHlpZWxkIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlZEdlbmVyYXRvciA9IG5ldyBBc3luY0dlbmVyYXRvcldpdGhTZXR1cCh7XG4gICAgICAgICAgICBnZW5lcmF0b3I6IHRoaXMudHJhbnNmb3JtKGdlbmVyYXRvcigpLCBjb25maWcpLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgd3JhcHBlZEdlbmVyYXRvci5zZXR1cDtcbiAgICAgICAgcmV0dXJuIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbUFzeW5jR2VuZXJhdG9yKHdyYXBwZWRHZW5lcmF0b3IpO1xuICAgIH1cbn1cbi8qKlxuICogQSBydW5uYWJsZSB0aGF0IGFzc2lnbnMga2V5LXZhbHVlIHBhaXJzIHRvIGlucHV0cyBvZiB0eXBlIGBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPmAuXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZVBpY2sgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlUGlja1wiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShmaWVsZHMpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsga2V5czogZmllbGRzIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrZXlzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMua2V5cyA9IGZpZWxkcy5rZXlzO1xuICAgIH1cbiAgICBhc3luYyBfcGljayhpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMua2V5cyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0W3RoaXMua2V5c107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwaWNrZWQgPSB0aGlzLmtleXNcbiAgICAgICAgICAgICAgICAubWFwKChrZXkpID0+IFtrZXksIGlucHV0W2tleV1dKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHYpID0+IHZbMV0gIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICByZXR1cm4gcGlja2VkLmxlbmd0aCA9PT0gMCA/IHVuZGVmaW5lZCA6IE9iamVjdC5mcm9tRW50cmllcyhwaWNrZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5fcGljay5iaW5kKHRoaXMpLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jICpfdHJhbnNmb3JtKGdlbmVyYXRvcikge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGdlbmVyYXRvcikge1xuICAgICAgICAgICAgY29uc3QgcGlja2VkID0gYXdhaXQgdGhpcy5fcGljayhjaHVuayk7XG4gICAgICAgICAgICBpZiAocGlja2VkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBwaWNrZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhnZW5lcmF0b3IsIHRoaXMuX3RyYW5zZm9ybS5iaW5kKHRoaXMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBnZW5lcmF0b3IoKSB7XG4gICAgICAgICAgICB5aWVsZCBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRHZW5lcmF0b3IgPSBuZXcgQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAoe1xuICAgICAgICAgICAgZ2VuZXJhdG9yOiB0aGlzLnRyYW5zZm9ybShnZW5lcmF0b3IoKSwgY29uZmlnKSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHdyYXBwZWRHZW5lcmF0b3Iuc2V0dXA7XG4gICAgICAgIHJldHVybiBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcih3cmFwcGVkR2VuZXJhdG9yKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUnVubmFibGVUb29sTGlrZSBleHRlbmRzIFJ1bm5hYmxlQmluZGluZyB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlID0gUnVubmFibGVTZXF1ZW5jZS5mcm9tKFtcbiAgICAgICAgICAgIFJ1bm5hYmxlTGFtYmRhLmZyb20oYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRvb2xJbnB1dDtcbiAgICAgICAgICAgICAgICBpZiAoX2lzVG9vbENhbGwoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sSW5wdXQgPSBhd2FpdCB0aGlzLnNjaGVtYS5wYXJzZUFzeW5jKGlucHV0LmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9vbElucHV0UGFyc2luZ0V4Y2VwdGlvbihgUmVjZWl2ZWQgdG9vbCBpbnB1dCBkaWQgbm90IG1hdGNoIGV4cGVjdGVkIHNjaGVtYWAsIEpTT04uc3RyaW5naWZ5KGlucHV0LmFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbElucHV0ID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b29sSW5wdXQ7XG4gICAgICAgICAgICB9KS53aXRoQ29uZmlnKHsgcnVuTmFtZTogYCR7ZmllbGRzLm5hbWV9OnBhcnNlX2lucHV0YCB9KSxcbiAgICAgICAgICAgIGZpZWxkcy5ib3VuZCxcbiAgICAgICAgXSkud2l0aENvbmZpZyh7IHJ1bk5hbWU6IGZpZWxkcy5uYW1lIH0pO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBib3VuZDogc2VxdWVuY2UsXG4gICAgICAgICAgICBjb25maWc6IGZpZWxkcy5jb25maWcgPz8ge30sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlc2NyaXB0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjaGVtYVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGZpZWxkcy5kZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBmaWVsZHMuc2NoZW1hO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVUb29sTGlrZVwiO1xuICAgIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBydW5uYWJsZSBhbmQgYSBab2Qgc2NoZW1hLCBjb252ZXJ0IHRoZSBydW5uYWJsZSB0byBhIHRvb2wuXG4gKlxuICogQHRlbXBsYXRlIFJ1bklucHV0IFRoZSBpbnB1dCB0eXBlIGZvciB0aGUgcnVubmFibGUuXG4gKiBAdGVtcGxhdGUgUnVuT3V0cHV0IFRoZSBvdXRwdXQgdHlwZSBmb3IgdGhlIHJ1bm5hYmxlLlxuICpcbiAqIEBwYXJhbSB7UnVubmFibGU8UnVuSW5wdXQsIFJ1bk91dHB1dD59IHJ1bm5hYmxlIFRoZSBydW5uYWJsZSB0byBjb252ZXJ0IHRvIGEgdG9vbC5cbiAqIEBwYXJhbSBmaWVsZHNcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbZmllbGRzLm5hbWVdIFRoZSBuYW1lIG9mIHRoZSB0b29sLiBJZiBub3QgcHJvdmlkZWQsIGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgbmFtZSBvZiB0aGUgcnVubmFibGUuXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW2ZpZWxkcy5kZXNjcmlwdGlvbl0gVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSB0b29sLiBGYWxscyBiYWNrIHRvIHRoZSBkZXNjcmlwdGlvbiBvbiB0aGUgWm9kIHNjaGVtYSBpZiBub3QgcHJvdmlkZWQsIG9yIHVuZGVmaW5lZCBpZiBuZWl0aGVyIGFyZSBwcm92aWRlZC5cbiAqIEBwYXJhbSB7ei5ab2RUeXBlPFJ1bklucHV0Pn0gW2ZpZWxkcy5zY2hlbWFdIFRoZSBab2Qgc2NoZW1hIGZvciB0aGUgaW5wdXQgb2YgdGhlIHRvb2wuIEluZmVycyB0aGUgWm9kIHR5cGUgZnJvbSB0aGUgaW5wdXQgdHlwZSBvZiB0aGUgcnVubmFibGUuXG4gKiBAcmV0dXJucyB7UnVubmFibGVUb29sTGlrZTx6LlpvZFR5cGU8UnVuSW5wdXQ+LCBSdW5PdXRwdXQ+fSBBbiBpbnN0YW5jZSBvZiBgUnVubmFibGVUb29sTGlrZWAgd2hpY2ggaXMgYSBydW5uYWJsZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgdG9vbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSdW5uYWJsZVRvVG9vbChydW5uYWJsZSwgZmllbGRzKSB7XG4gICAgY29uc3QgbmFtZSA9IGZpZWxkcy5uYW1lID8/IHJ1bm5hYmxlLmdldE5hbWUoKTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGZpZWxkcy5kZXNjcmlwdGlvbiA/PyBmaWVsZHMuc2NoZW1hPy5kZXNjcmlwdGlvbjtcbiAgICBpZiAoZmllbGRzLnNjaGVtYS5jb25zdHJ1Y3RvciA9PT0gei5ab2RTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVRvb2xMaWtlKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHNjaGVtYTogelxuICAgICAgICAgICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlucHV0OiB6LnN0cmluZygpLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudHJhbnNmb3JtKChpbnB1dCkgPT4gaW5wdXQuaW5wdXQpLFxuICAgICAgICAgICAgYm91bmQ6IHJ1bm5hYmxlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSdW5uYWJsZVRvb2xMaWtlKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIHNjaGVtYTogZmllbGRzLnNjaGVtYSxcbiAgICAgICAgYm91bmQ6IHJ1bm5hYmxlLFxuICAgIH0pO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/base.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/config.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/config.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_RECURSION_LIMIT: () => (/* binding */ DEFAULT_RECURSION_LIMIT),\n/* harmony export */   ensureConfig: () => (/* binding */ ensureConfig),\n/* harmony export */   getCallbackManagerForConfig: () => (/* binding */ getCallbackManagerForConfig),\n/* harmony export */   mergeConfigs: () => (/* binding */ mergeConfigs),\n/* harmony export */   patchConfig: () => (/* binding */ patchConfig)\n/* harmony export */ });\n/* harmony import */ var _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../callbacks/manager.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/callbacks/manager.js\");\n/* harmony import */ var _singletons_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../singletons/index.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/singletons/index.js\");\n\n\nconst DEFAULT_RECURSION_LIMIT = 25;\nasync function getCallbackManagerForConfig(config) {\n    return _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.CallbackManager._configureSync(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n}\nfunction mergeConfigs(...configs) {\n    // We do not want to call ensureConfig on the empty state here as this may cause\n    // double loading of callbacks if async local storage is being used.\n    const copy = {};\n    for (const options of configs.filter((c) => !!c)) {\n        for (const key of Object.keys(options)) {\n            if (key === \"metadata\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"tags\") {\n                const baseKeys = copy[key] ?? [];\n                copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];\n            }\n            else if (key === \"configurable\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"timeout\") {\n                if (copy.timeout === undefined) {\n                    copy.timeout = options.timeout;\n                }\n                else if (options.timeout !== undefined) {\n                    copy.timeout = Math.min(copy.timeout, options.timeout);\n                }\n            }\n            else if (key === \"signal\") {\n                if (copy.signal === undefined) {\n                    copy.signal = options.signal;\n                }\n                else if (options.signal !== undefined) {\n                    if (\"any\" in AbortSignal) {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        copy.signal = AbortSignal.any([\n                            copy.signal,\n                            options.signal,\n                        ]);\n                    }\n                    else {\n                        copy.signal = options.signal;\n                    }\n                }\n            }\n            else if (key === \"callbacks\") {\n                const baseCallbacks = copy.callbacks;\n                const providedCallbacks = options.callbacks;\n                // callbacks can be either undefined, Array<handler> or manager\n                // so merging two callbacks values has 6 cases\n                if (Array.isArray(providedCallbacks)) {\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        copy.callbacks = baseCallbacks.concat(providedCallbacks);\n                    }\n                    else {\n                        // baseCallbacks is a manager\n                        const manager = baseCallbacks.copy();\n                        for (const callback of providedCallbacks) {\n                            manager.addHandler((0,_callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.ensureHandler)(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                }\n                else if (providedCallbacks) {\n                    // providedCallbacks is a manager\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        const manager = providedCallbacks.copy();\n                        for (const callback of baseCallbacks) {\n                            manager.addHandler((0,_callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.ensureHandler)(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                    else {\n                        // baseCallbacks is also a manager\n                        copy.callbacks = new _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_0__.CallbackManager(providedCallbacks._parentRunId, {\n                            handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),\n                            inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),\n                            tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),\n                            inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),\n                            metadata: {\n                                ...baseCallbacks.metadata,\n                                ...providedCallbacks.metadata,\n                            },\n                        });\n                    }\n                }\n            }\n            else {\n                const typedKey = key;\n                copy[typedKey] = options[typedKey] ?? copy[typedKey];\n            }\n        }\n    }\n    return copy;\n}\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n/**\n * Ensure that a passed config is an object with all required keys present.\n */\nfunction ensureConfig(config) {\n    const implicitConfig = _singletons_index_js__WEBPACK_IMPORTED_MODULE_1__.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    let empty = {\n        tags: [],\n        metadata: {},\n        recursionLimit: 25,\n        runId: undefined,\n    };\n    if (implicitConfig) {\n        // Don't allow runId and runName to be loaded implicitly, as this can cause\n        // child runs to improperly inherit their parents' run ids.\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { runId, runName, ...rest } = implicitConfig;\n        empty = Object.entries(rest).reduce(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (currentConfig, [key, value]) => {\n            if (value !== undefined) {\n                // eslint-disable-next-line no-param-reassign\n                currentConfig[key] = value;\n            }\n            return currentConfig;\n        }, empty);\n    }\n    if (config) {\n        empty = Object.entries(config).reduce(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (currentConfig, [key, value]) => {\n            if (value !== undefined) {\n                // eslint-disable-next-line no-param-reassign\n                currentConfig[key] = value;\n            }\n            return currentConfig;\n        }, empty);\n    }\n    if (empty?.configurable) {\n        for (const key of Object.keys(empty.configurable)) {\n            if (PRIMITIVES.has(typeof empty.configurable[key]) &&\n                !empty.metadata?.[key]) {\n                if (!empty.metadata) {\n                    empty.metadata = {};\n                }\n                empty.metadata[key] = empty.configurable[key];\n            }\n        }\n    }\n    if (empty.timeout !== undefined) {\n        if (empty.timeout <= 0) {\n            throw new Error(\"Timeout must be a positive number\");\n        }\n        const timeoutSignal = AbortSignal.timeout(empty.timeout);\n        if (empty.signal !== undefined) {\n            if (\"any\" in AbortSignal) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                empty.signal = AbortSignal.any([empty.signal, timeoutSignal]);\n            }\n        }\n        else {\n            empty.signal = timeoutSignal;\n        }\n        delete empty.timeout;\n    }\n    return empty;\n}\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nfunction patchConfig(config = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, runId, } = {}) {\n    const newConfig = ensureConfig(config);\n    if (callbacks !== undefined) {\n        /**\n         * If we're replacing callbacks we need to unset runName\n         * since that should apply only to the same run as the original callbacks\n         */\n        delete newConfig.runName;\n        newConfig.callbacks = callbacks;\n    }\n    if (recursionLimit !== undefined) {\n        newConfig.recursionLimit = recursionLimit;\n    }\n    if (maxConcurrency !== undefined) {\n        newConfig.maxConcurrency = maxConcurrency;\n    }\n    if (runName !== undefined) {\n        newConfig.runName = runName;\n    }\n    if (configurable !== undefined) {\n        newConfig.configurable = { ...newConfig.configurable, ...configurable };\n    }\n    if (runId !== undefined) {\n        delete newConfig.runId;\n    }\n    return newConfig;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy9jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF5RTtBQUNHO0FBQ3JFO0FBQ0E7QUFDUCxXQUFXLGtFQUFlO0FBQzFCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvRUFBYTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msb0VBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrRUFBZTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCwyQkFBMkIsb0ZBQWtDO0FBQzdEO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLElBQUksMkVBQTJFLElBQUk7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcdGV4dHNwbGl0dGVyc1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxydW5uYWJsZXNcXGNvbmZpZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDYWxsYmFja01hbmFnZXIsIGVuc3VyZUhhbmRsZXIgfSBmcm9tIFwiLi4vY2FsbGJhY2tzL21hbmFnZXIuanNcIjtcbmltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gfSBmcm9tIFwiLi4vc2luZ2xldG9ucy9pbmRleC5qc1wiO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVDVVJTSU9OX0xJTUlUID0gMjU7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZykge1xuICAgIHJldHVybiBDYWxsYmFja01hbmFnZXIuX2NvbmZpZ3VyZVN5bmMoY29uZmlnPy5jYWxsYmFja3MsIHVuZGVmaW5lZCwgY29uZmlnPy50YWdzLCB1bmRlZmluZWQsIGNvbmZpZz8ubWV0YWRhdGEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQ29uZmlncyguLi5jb25maWdzKSB7XG4gICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gY2FsbCBlbnN1cmVDb25maWcgb24gdGhlIGVtcHR5IHN0YXRlIGhlcmUgYXMgdGhpcyBtYXkgY2F1c2VcbiAgICAvLyBkb3VibGUgbG9hZGluZyBvZiBjYWxsYmFja3MgaWYgYXN5bmMgbG9jYWwgc3RvcmFnZSBpcyBiZWluZyB1c2VkLlxuICAgIGNvbnN0IGNvcHkgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2YgY29uZmlncy5maWx0ZXIoKGMpID0+ICEhYykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob3B0aW9ucykpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwibWV0YWRhdGFcIikge1xuICAgICAgICAgICAgICAgIGNvcHlba2V5XSA9IHsgLi4uY29weVtrZXldLCAuLi5vcHRpb25zW2tleV0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJ0YWdzXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlS2V5cyA9IGNvcHlba2V5XSA/PyBbXTtcbiAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSBbLi4ubmV3IFNldChiYXNlS2V5cy5jb25jYXQob3B0aW9uc1trZXldID8/IFtdKSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImNvbmZpZ3VyYWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgY29weVtrZXldID0geyAuLi5jb3B5W2tleV0sIC4uLm9wdGlvbnNba2V5XSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcInRpbWVvdXRcIikge1xuICAgICAgICAgICAgICAgIGlmIChjb3B5LnRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5LnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMudGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkudGltZW91dCA9IE1hdGgubWluKGNvcHkudGltZW91dCwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwic2lnbmFsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29weS5zaWduYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5LnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImFueVwiIGluIEFib3J0U2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5zaWduYWwgPSBBYm9ydFNpZ25hbC5hbnkoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImNhbGxiYWNrc1wiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUNhbGxiYWNrcyA9IGNvcHkuY2FsbGJhY2tzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVkQ2FsbGJhY2tzID0gb3B0aW9ucy5jYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgLy8gY2FsbGJhY2tzIGNhbiBiZSBlaXRoZXIgdW5kZWZpbmVkLCBBcnJheTxoYW5kbGVyPiBvciBtYW5hZ2VyXG4gICAgICAgICAgICAgICAgLy8gc28gbWVyZ2luZyB0d28gY2FsbGJhY2tzIHZhbHVlcyBoYXMgNiBjYXNlc1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3ZpZGVkQ2FsbGJhY2tzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2VDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuY2FsbGJhY2tzID0gcHJvdmlkZWRDYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiYXNlQ2FsbGJhY2tzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBiYXNlQ2FsbGJhY2tzLmNvbmNhdChwcm92aWRlZENhbGxiYWNrcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiYXNlQ2FsbGJhY2tzIGlzIGEgbWFuYWdlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFuYWdlciA9IGJhc2VDYWxsYmFja3MuY29weSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBwcm92aWRlZENhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuYWRkSGFuZGxlcihlbnN1cmVIYW5kbGVyKGNhbGxiYWNrKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LmNhbGxiYWNrcyA9IG1hbmFnZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZWRDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvdmlkZWRDYWxsYmFja3MgaXMgYSBtYW5hZ2VyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYmFzZUNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBwcm92aWRlZENhbGxiYWNrcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJhc2VDYWxsYmFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYW5hZ2VyID0gcHJvdmlkZWRDYWxsYmFja3MuY29weSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBiYXNlQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKGVuc3VyZUhhbmRsZXIoY2FsbGJhY2spLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuY2FsbGJhY2tzID0gbWFuYWdlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhc2VDYWxsYmFja3MgaXMgYWxzbyBhIG1hbmFnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuY2FsbGJhY2tzID0gbmV3IENhbGxiYWNrTWFuYWdlcihwcm92aWRlZENhbGxiYWNrcy5fcGFyZW50UnVuSWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyczogYmFzZUNhbGxiYWNrcy5oYW5kbGVycy5jb25jYXQocHJvdmlkZWRDYWxsYmFja3MuaGFuZGxlcnMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaGVyaXRhYmxlSGFuZGxlcnM6IGJhc2VDYWxsYmFja3MuaW5oZXJpdGFibGVIYW5kbGVycy5jb25jYXQocHJvdmlkZWRDYWxsYmFja3MuaW5oZXJpdGFibGVIYW5kbGVycyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogQXJyYXkuZnJvbShuZXcgU2V0KGJhc2VDYWxsYmFja3MudGFncy5jb25jYXQocHJvdmlkZWRDYWxsYmFja3MudGFncykpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmhlcml0YWJsZVRhZ3M6IEFycmF5LmZyb20obmV3IFNldChiYXNlQ2FsbGJhY2tzLmluaGVyaXRhYmxlVGFncy5jb25jYXQocHJvdmlkZWRDYWxsYmFja3MuaW5oZXJpdGFibGVUYWdzKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmJhc2VDYWxsYmFja3MubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnByb3ZpZGVkQ2FsbGJhY2tzLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkS2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIGNvcHlbdHlwZWRLZXldID0gb3B0aW9uc1t0eXBlZEtleV0gPz8gY29weVt0eXBlZEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5jb25zdCBQUklNSVRJVkVTID0gbmV3IFNldChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCJdKTtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSBwYXNzZWQgY29uZmlnIGlzIGFuIG9iamVjdCB3aXRoIGFsbCByZXF1aXJlZCBrZXlzIHByZXNlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVDb25maWcoY29uZmlnKSB7XG4gICAgY29uc3QgaW1wbGljaXRDb25maWcgPSBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLmdldFJ1bm5hYmxlQ29uZmlnKCk7XG4gICAgbGV0IGVtcHR5ID0ge1xuICAgICAgICB0YWdzOiBbXSxcbiAgICAgICAgbWV0YWRhdGE6IHt9LFxuICAgICAgICByZWN1cnNpb25MaW1pdDogMjUsXG4gICAgICAgIHJ1bklkOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICBpZiAoaW1wbGljaXRDb25maWcpIHtcbiAgICAgICAgLy8gRG9uJ3QgYWxsb3cgcnVuSWQgYW5kIHJ1bk5hbWUgdG8gYmUgbG9hZGVkIGltcGxpY2l0bHksIGFzIHRoaXMgY2FuIGNhdXNlXG4gICAgICAgIC8vIGNoaWxkIHJ1bnMgdG8gaW1wcm9wZXJseSBpbmhlcml0IHRoZWlyIHBhcmVudHMnIHJ1biBpZHMuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgeyBydW5JZCwgcnVuTmFtZSwgLi4ucmVzdCB9ID0gaW1wbGljaXRDb25maWc7XG4gICAgICAgIGVtcHR5ID0gT2JqZWN0LmVudHJpZXMocmVzdCkucmVkdWNlKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAoY3VycmVudENvbmZpZywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb25maWdba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDb25maWc7XG4gICAgICAgIH0sIGVtcHR5KTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgICBlbXB0eSA9IE9iamVjdC5lbnRyaWVzKGNvbmZpZykucmVkdWNlKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAoY3VycmVudENvbmZpZywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb25maWdba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDb25maWc7XG4gICAgICAgIH0sIGVtcHR5KTtcbiAgICB9XG4gICAgaWYgKGVtcHR5Py5jb25maWd1cmFibGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZW1wdHkuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgaWYgKFBSSU1JVElWRVMuaGFzKHR5cGVvZiBlbXB0eS5jb25maWd1cmFibGVba2V5XSkgJiZcbiAgICAgICAgICAgICAgICAhZW1wdHkubWV0YWRhdGE/LltrZXldKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbXB0eS5tZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eS5tZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbXB0eS5tZXRhZGF0YVtrZXldID0gZW1wdHkuY29uZmlndXJhYmxlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVtcHR5LnRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZW1wdHkudGltZW91dCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaW1lb3V0IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZW91dFNpZ25hbCA9IEFib3J0U2lnbmFsLnRpbWVvdXQoZW1wdHkudGltZW91dCk7XG4gICAgICAgIGlmIChlbXB0eS5zaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKFwiYW55XCIgaW4gQWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGVtcHR5LnNpZ25hbCA9IEFib3J0U2lnbmFsLmFueShbZW1wdHkuc2lnbmFsLCB0aW1lb3V0U2lnbmFsXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbXB0eS5zaWduYWwgPSB0aW1lb3V0U2lnbmFsO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBlbXB0eS50aW1lb3V0O1xuICAgIH1cbiAgICByZXR1cm4gZW1wdHk7XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IHBhdGNoZXMgcnVubmFibGUgY29uZmlncyB3aXRoIHVwZGF0ZWQgcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoQ29uZmlnKGNvbmZpZyA9IHt9LCB7IGNhbGxiYWNrcywgbWF4Q29uY3VycmVuY3ksIHJlY3Vyc2lvbkxpbWl0LCBydW5OYW1lLCBjb25maWd1cmFibGUsIHJ1bklkLCB9ID0ge30pIHtcbiAgICBjb25zdCBuZXdDb25maWcgPSBlbnN1cmVDb25maWcoY29uZmlnKTtcbiAgICBpZiAoY2FsbGJhY2tzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlJ3JlIHJlcGxhY2luZyBjYWxsYmFja3Mgd2UgbmVlZCB0byB1bnNldCBydW5OYW1lXG4gICAgICAgICAqIHNpbmNlIHRoYXQgc2hvdWxkIGFwcGx5IG9ubHkgdG8gdGhlIHNhbWUgcnVuIGFzIHRoZSBvcmlnaW5hbCBjYWxsYmFja3NcbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZSBuZXdDb25maWcucnVuTmFtZTtcbiAgICAgICAgbmV3Q29uZmlnLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB9XG4gICAgaWYgKHJlY3Vyc2lvbkxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3Q29uZmlnLnJlY3Vyc2lvbkxpbWl0ID0gcmVjdXJzaW9uTGltaXQ7XG4gICAgfVxuICAgIGlmIChtYXhDb25jdXJyZW5jeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld0NvbmZpZy5tYXhDb25jdXJyZW5jeSA9IG1heENvbmN1cnJlbmN5O1xuICAgIH1cbiAgICBpZiAocnVuTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld0NvbmZpZy5ydW5OYW1lID0gcnVuTmFtZTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZ3VyYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld0NvbmZpZy5jb25maWd1cmFibGUgPSB7IC4uLm5ld0NvbmZpZy5jb25maWd1cmFibGUsIC4uLmNvbmZpZ3VyYWJsZSB9O1xuICAgIH1cbiAgICBpZiAocnVuSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgbmV3Q29uZmlnLnJ1bklkO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Q29uZmlnO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/config.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/graph.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/graph.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Graph: () => (/* binding */ Graph)\n/* harmony export */ });\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod-to-json-schema */ \"(action-browser)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"(action-browser)/./node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uuid */ \"(action-browser)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/utils.js\");\n/* harmony import */ var _graph_mermaid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./graph_mermaid.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/graph_mermaid.js\");\n\n\n\n\nconst MAX_DATA_DISPLAY_NAME_LENGTH = 42;\nfunction nodeDataStr(node) {\n    if (!(0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(node.id)) {\n        return node.id;\n    }\n    else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isRunnableInterface)(node.data)) {\n        try {\n            let data = node.data.getName();\n            data = data.startsWith(\"Runnable\") ? data.slice(\"Runnable\".length) : data;\n            if (data.length > MAX_DATA_DISPLAY_NAME_LENGTH) {\n                data = `${data.substring(0, MAX_DATA_DISPLAY_NAME_LENGTH)}...`;\n            }\n            return data;\n        }\n        catch (error) {\n            return node.data.getName();\n        }\n    }\n    else {\n        return node.data.name ?? \"UnknownSchema\";\n    }\n}\nfunction nodeDataJson(node) {\n    // if node.data is implements Runnable\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isRunnableInterface)(node.data)) {\n        return {\n            type: \"runnable\",\n            data: {\n                id: node.data.lc_id,\n                name: node.data.getName(),\n            },\n        };\n    }\n    else {\n        return {\n            type: \"schema\",\n            data: { ...(0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__.zodToJsonSchema)(node.data.schema), title: node.data.name },\n        };\n    }\n}\nclass Graph {\n    constructor() {\n        Object.defineProperty(this, \"nodes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"edges\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    // Convert the graph to a JSON-serializable format.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    toJSON() {\n        const stableNodeIds = {};\n        Object.values(this.nodes).forEach((node, i) => {\n            stableNodeIds[node.id] = (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(node.id) ? i : node.id;\n        });\n        return {\n            nodes: Object.values(this.nodes).map((node) => ({\n                id: stableNodeIds[node.id],\n                ...nodeDataJson(node),\n            })),\n            edges: this.edges.map((edge) => {\n                const item = {\n                    source: stableNodeIds[edge.source],\n                    target: stableNodeIds[edge.target],\n                };\n                if (typeof edge.data !== \"undefined\") {\n                    item.data = edge.data;\n                }\n                if (typeof edge.conditional !== \"undefined\") {\n                    item.conditional = edge.conditional;\n                }\n                return item;\n            }),\n        };\n    }\n    addNode(data, id) {\n        if (id !== undefined && this.nodes[id] !== undefined) {\n            throw new Error(`Node with id ${id} already exists`);\n        }\n        const nodeId = id || (0,uuid__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n        const node = { id: nodeId, data };\n        this.nodes[nodeId] = node;\n        return node;\n    }\n    removeNode(node) {\n        // Remove the node from the nodes map\n        delete this.nodes[node.id];\n        // Filter out edges connected to the node\n        this.edges = this.edges.filter((edge) => edge.source !== node.id && edge.target !== node.id);\n    }\n    addEdge(source, target, data, conditional) {\n        if (this.nodes[source.id] === undefined) {\n            throw new Error(`Source node ${source.id} not in graph`);\n        }\n        if (this.nodes[target.id] === undefined) {\n            throw new Error(`Target node ${target.id} not in graph`);\n        }\n        const edge = {\n            source: source.id,\n            target: target.id,\n            data,\n            conditional,\n        };\n        this.edges.push(edge);\n        return edge;\n    }\n    firstNode() {\n        const targets = new Set(this.edges.map((edge) => edge.target));\n        const found = [];\n        Object.values(this.nodes).forEach((node) => {\n            if (!targets.has(node.id)) {\n                found.push(node);\n            }\n        });\n        return found[0];\n    }\n    lastNode() {\n        const sources = new Set(this.edges.map((edge) => edge.source));\n        const found = [];\n        Object.values(this.nodes).forEach((node) => {\n            if (!sources.has(node.id)) {\n                found.push(node);\n            }\n        });\n        return found[0];\n    }\n    /**\n     * Add all nodes and edges from another graph.\n     * Note this doesn't check for duplicates, nor does it connect the graphs.\n     */\n    extend(graph, prefix = \"\") {\n        let finalPrefix = prefix;\n        const nodeIds = Object.values(graph.nodes).map((node) => node.id);\n        if (nodeIds.every(uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])) {\n            finalPrefix = \"\";\n        }\n        const prefixed = (id) => {\n            return finalPrefix ? `${finalPrefix}:${id}` : id;\n        };\n        Object.entries(graph.nodes).forEach(([key, value]) => {\n            this.nodes[prefixed(key)] = { ...value, id: prefixed(key) };\n        });\n        const newEdges = graph.edges.map((edge) => {\n            return {\n                ...edge,\n                source: prefixed(edge.source),\n                target: prefixed(edge.target),\n            };\n        });\n        // Add all edges from the other graph\n        this.edges = [...this.edges, ...newEdges];\n        const first = graph.firstNode();\n        const last = graph.lastNode();\n        return [\n            first ? { id: prefixed(first.id), data: first.data } : undefined,\n            last ? { id: prefixed(last.id), data: last.data } : undefined,\n        ];\n    }\n    trimFirstNode() {\n        const firstNode = this.firstNode();\n        if (firstNode) {\n            const outgoingEdges = this.edges.filter((edge) => edge.source === firstNode.id);\n            if (Object.keys(this.nodes).length === 1 || outgoingEdges.length === 1) {\n                this.removeNode(firstNode);\n            }\n        }\n    }\n    trimLastNode() {\n        const lastNode = this.lastNode();\n        if (lastNode) {\n            const incomingEdges = this.edges.filter((edge) => edge.target === lastNode.id);\n            if (Object.keys(this.nodes).length === 1 || incomingEdges.length === 1) {\n                this.removeNode(lastNode);\n            }\n        }\n    }\n    drawMermaid(params) {\n        const { withStyles, curveStyle, nodeColors = { start: \"#ffdfba\", end: \"#baffc9\", other: \"#fad7de\" }, wrapLabelNWords, } = params ?? {};\n        const nodes = {};\n        for (const node of Object.values(this.nodes)) {\n            nodes[node.id] = nodeDataStr(node);\n        }\n        const firstNode = this.firstNode();\n        const firstNodeLabel = firstNode ? nodeDataStr(firstNode) : undefined;\n        const lastNode = this.lastNode();\n        const lastNodeLabel = lastNode ? nodeDataStr(lastNode) : undefined;\n        return (0,_graph_mermaid_js__WEBPACK_IMPORTED_MODULE_2__.drawMermaid)(nodes, this.edges, {\n            firstNodeLabel,\n            lastNodeLabel,\n            withStyles,\n            curveStyle,\n            nodeColors,\n            wrapLabelNWords,\n        });\n    }\n    async drawMermaidPng(params) {\n        const mermaidSyntax = this.drawMermaid(params);\n        return (0,_graph_mermaid_js__WEBPACK_IMPORTED_MODULE_2__.drawMermaidPng)(mermaidSyntax, {\n            backgroundColor: params?.backgroundColor,\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy9ncmFwaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBcUQ7QUFDRztBQUNQO0FBQ2dCO0FBQ2pFO0FBQ0E7QUFDQSxTQUFTLGdEQUFNO0FBQ2Y7QUFDQTtBQUNBLGFBQWEsOERBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdEQUFnRDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixHQUFHLG1FQUFlLDJDQUEyQztBQUNqRjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnREFBTTtBQUMzQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLElBQUk7QUFDaEQ7QUFDQSw2QkFBNkIsZ0RBQU07QUFDbkMsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRDQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZLEdBQUcsR0FBRztBQUN0RDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQ0FBMkM7QUFDakUscUJBQXFCLHlDQUF5QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDLG9EQUFvRCxxQkFBcUI7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOERBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUVBQWM7QUFDN0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXHRleHRzcGxpdHRlcnNcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxccnVubmFibGVzXFxncmFwaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB6b2RUb0pzb25TY2hlbWEgfSBmcm9tIFwiem9kLXRvLWpzb24tc2NoZW1hXCI7XG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQsIHZhbGlkYXRlIGFzIGlzVXVpZCB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBpc1J1bm5hYmxlSW50ZXJmYWNlIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IGRyYXdNZXJtYWlkLCBkcmF3TWVybWFpZFBuZyB9IGZyb20gXCIuL2dyYXBoX21lcm1haWQuanNcIjtcbmNvbnN0IE1BWF9EQVRBX0RJU1BMQVlfTkFNRV9MRU5HVEggPSA0MjtcbmZ1bmN0aW9uIG5vZGVEYXRhU3RyKG5vZGUpIHtcbiAgICBpZiAoIWlzVXVpZChub2RlLmlkKSkge1xuICAgICAgICByZXR1cm4gbm9kZS5pZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNSdW5uYWJsZUludGVyZmFjZShub2RlLmRhdGEpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IG5vZGUuZGF0YS5nZXROYW1lKCk7XG4gICAgICAgICAgICBkYXRhID0gZGF0YS5zdGFydHNXaXRoKFwiUnVubmFibGVcIikgPyBkYXRhLnNsaWNlKFwiUnVubmFibGVcIi5sZW5ndGgpIDogZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IE1BWF9EQVRBX0RJU1BMQVlfTkFNRV9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYCR7ZGF0YS5zdWJzdHJpbmcoMCwgTUFYX0RBVEFfRElTUExBWV9OQU1FX0xFTkdUSCl9Li4uYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZGF0YS5nZXROYW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBub2RlLmRhdGEubmFtZSA/PyBcIlVua25vd25TY2hlbWFcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBub2RlRGF0YUpzb24obm9kZSkge1xuICAgIC8vIGlmIG5vZGUuZGF0YSBpcyBpbXBsZW1lbnRzIFJ1bm5hYmxlXG4gICAgaWYgKGlzUnVubmFibGVJbnRlcmZhY2Uobm9kZS5kYXRhKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJydW5uYWJsZVwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGlkOiBub2RlLmRhdGEubGNfaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogbm9kZS5kYXRhLmdldE5hbWUoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJzY2hlbWFcIixcbiAgICAgICAgICAgIGRhdGE6IHsgLi4uem9kVG9Kc29uU2NoZW1hKG5vZGUuZGF0YS5zY2hlbWEpLCB0aXRsZTogbm9kZS5kYXRhLm5hbWUgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgR3JhcGgge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJub2Rlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVkZ2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgZ3JhcGggdG8gYSBKU09OLXNlcmlhbGl6YWJsZSBmb3JtYXQuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHN0YWJsZU5vZGVJZHMgPSB7fTtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKS5mb3JFYWNoKChub2RlLCBpKSA9PiB7XG4gICAgICAgICAgICBzdGFibGVOb2RlSWRzW25vZGUuaWRdID0gaXNVdWlkKG5vZGUuaWQpID8gaSA6IG5vZGUuaWQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZXM6IE9iamVjdC52YWx1ZXModGhpcy5ub2RlcykubWFwKChub2RlKSA9PiAoe1xuICAgICAgICAgICAgICAgIGlkOiBzdGFibGVOb2RlSWRzW25vZGUuaWRdLFxuICAgICAgICAgICAgICAgIC4uLm5vZGVEYXRhSnNvbihub2RlKSxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIGVkZ2VzOiB0aGlzLmVkZ2VzLm1hcCgoZWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc3RhYmxlTm9kZUlkc1tlZGdlLnNvdXJjZV0sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogc3RhYmxlTm9kZUlkc1tlZGdlLnRhcmdldF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVkZ2UuZGF0YSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRhdGEgPSBlZGdlLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWRnZS5jb25kaXRpb25hbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNvbmRpdGlvbmFsID0gZWRnZS5jb25kaXRpb25hbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYWRkTm9kZShkYXRhLCBpZCkge1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm5vZGVzW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgd2l0aCBpZCAke2lkfSBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVJZCA9IGlkIHx8IHV1aWR2NCgpO1xuICAgICAgICBjb25zdCBub2RlID0geyBpZDogbm9kZUlkLCBkYXRhIH07XG4gICAgICAgIHRoaXMubm9kZXNbbm9kZUlkXSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIG5vZGVzIG1hcFxuICAgICAgICBkZWxldGUgdGhpcy5ub2Rlc1tub2RlLmlkXTtcbiAgICAgICAgLy8gRmlsdGVyIG91dCBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIG5vZGVcbiAgICAgICAgdGhpcy5lZGdlcyA9IHRoaXMuZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBlZGdlLnNvdXJjZSAhPT0gbm9kZS5pZCAmJiBlZGdlLnRhcmdldCAhPT0gbm9kZS5pZCk7XG4gICAgfVxuICAgIGFkZEVkZ2Uoc291cmNlLCB0YXJnZXQsIGRhdGEsIGNvbmRpdGlvbmFsKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVzW3NvdXJjZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTb3VyY2Ugbm9kZSAke3NvdXJjZS5pZH0gbm90IGluIGdyYXBoYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubm9kZXNbdGFyZ2V0LmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRhcmdldCBub2RlICR7dGFyZ2V0LmlkfSBub3QgaW4gZ3JhcGhgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZGdlID0ge1xuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UuaWQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldC5pZCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBjb25kaXRpb25hbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICByZXR1cm4gZWRnZTtcbiAgICB9XG4gICAgZmlyc3ROb2RlKCkge1xuICAgICAgICBjb25zdCB0YXJnZXRzID0gbmV3IFNldCh0aGlzLmVkZ2VzLm1hcCgoZWRnZSkgPT4gZWRnZS50YXJnZXQpKTtcbiAgICAgICAgY29uc3QgZm91bmQgPSBbXTtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRhcmdldHMuaGFzKG5vZGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgZm91bmQucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZFswXTtcbiAgICB9XG4gICAgbGFzdE5vZGUoKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZXMgPSBuZXcgU2V0KHRoaXMuZWRnZXMubWFwKChlZGdlKSA9PiBlZGdlLnNvdXJjZSkpO1xuICAgICAgICBjb25zdCBmb3VuZCA9IFtdO1xuICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMubm9kZXMpLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmICghc291cmNlcy5oYXMobm9kZS5pZCkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvdW5kWzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYWxsIG5vZGVzIGFuZCBlZGdlcyBmcm9tIGFub3RoZXIgZ3JhcGguXG4gICAgICogTm90ZSB0aGlzIGRvZXNuJ3QgY2hlY2sgZm9yIGR1cGxpY2F0ZXMsIG5vciBkb2VzIGl0IGNvbm5lY3QgdGhlIGdyYXBocy5cbiAgICAgKi9cbiAgICBleHRlbmQoZ3JhcGgsIHByZWZpeCA9IFwiXCIpIHtcbiAgICAgICAgbGV0IGZpbmFsUHJlZml4ID0gcHJlZml4O1xuICAgICAgICBjb25zdCBub2RlSWRzID0gT2JqZWN0LnZhbHVlcyhncmFwaC5ub2RlcykubWFwKChub2RlKSA9PiBub2RlLmlkKTtcbiAgICAgICAgaWYgKG5vZGVJZHMuZXZlcnkoaXNVdWlkKSkge1xuICAgICAgICAgICAgZmluYWxQcmVmaXggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZpeGVkID0gKGlkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZmluYWxQcmVmaXggPyBgJHtmaW5hbFByZWZpeH06JHtpZH1gIDogaWQ7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGdyYXBoLm5vZGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIHRoaXMubm9kZXNbcHJlZml4ZWQoa2V5KV0gPSB7IC4uLnZhbHVlLCBpZDogcHJlZml4ZWQoa2V5KSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbmV3RWRnZXMgPSBncmFwaC5lZGdlcy5tYXAoKGVkZ2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uZWRnZSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHByZWZpeGVkKGVkZ2Uuc291cmNlKSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHByZWZpeGVkKGVkZ2UudGFyZ2V0KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBZGQgYWxsIGVkZ2VzIGZyb20gdGhlIG90aGVyIGdyYXBoXG4gICAgICAgIHRoaXMuZWRnZXMgPSBbLi4udGhpcy5lZGdlcywgLi4ubmV3RWRnZXNdO1xuICAgICAgICBjb25zdCBmaXJzdCA9IGdyYXBoLmZpcnN0Tm9kZSgpO1xuICAgICAgICBjb25zdCBsYXN0ID0gZ3JhcGgubGFzdE5vZGUoKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZpcnN0ID8geyBpZDogcHJlZml4ZWQoZmlyc3QuaWQpLCBkYXRhOiBmaXJzdC5kYXRhIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBsYXN0ID8geyBpZDogcHJlZml4ZWQobGFzdC5pZCksIGRhdGE6IGxhc3QuZGF0YSB9IDogdW5kZWZpbmVkLFxuICAgICAgICBdO1xuICAgIH1cbiAgICB0cmltRmlyc3ROb2RlKCkge1xuICAgICAgICBjb25zdCBmaXJzdE5vZGUgPSB0aGlzLmZpcnN0Tm9kZSgpO1xuICAgICAgICBpZiAoZmlyc3ROb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBvdXRnb2luZ0VkZ2VzID0gdGhpcy5lZGdlcy5maWx0ZXIoKGVkZ2UpID0+IGVkZ2Uuc291cmNlID09PSBmaXJzdE5vZGUuaWQpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMubm9kZXMpLmxlbmd0aCA9PT0gMSB8fCBvdXRnb2luZ0VkZ2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZShmaXJzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyaW1MYXN0Tm9kZSgpIHtcbiAgICAgICAgY29uc3QgbGFzdE5vZGUgPSB0aGlzLmxhc3ROb2RlKCk7XG4gICAgICAgIGlmIChsYXN0Tm9kZSkge1xuICAgICAgICAgICAgY29uc3QgaW5jb21pbmdFZGdlcyA9IHRoaXMuZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBlZGdlLnRhcmdldCA9PT0gbGFzdE5vZGUuaWQpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMubm9kZXMpLmxlbmd0aCA9PT0gMSB8fCBpbmNvbWluZ0VkZ2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZShsYXN0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhd01lcm1haWQocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHsgd2l0aFN0eWxlcywgY3VydmVTdHlsZSwgbm9kZUNvbG9ycyA9IHsgc3RhcnQ6IFwiI2ZmZGZiYVwiLCBlbmQ6IFwiI2JhZmZjOVwiLCBvdGhlcjogXCIjZmFkN2RlXCIgfSwgd3JhcExhYmVsTldvcmRzLCB9ID0gcGFyYW1zID8/IHt9O1xuICAgICAgICBjb25zdCBub2RlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKSkge1xuICAgICAgICAgICAgbm9kZXNbbm9kZS5pZF0gPSBub2RlRGF0YVN0cihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdE5vZGUgPSB0aGlzLmZpcnN0Tm9kZSgpO1xuICAgICAgICBjb25zdCBmaXJzdE5vZGVMYWJlbCA9IGZpcnN0Tm9kZSA/IG5vZGVEYXRhU3RyKGZpcnN0Tm9kZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGxhc3ROb2RlID0gdGhpcy5sYXN0Tm9kZSgpO1xuICAgICAgICBjb25zdCBsYXN0Tm9kZUxhYmVsID0gbGFzdE5vZGUgPyBub2RlRGF0YVN0cihsYXN0Tm9kZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBkcmF3TWVybWFpZChub2RlcywgdGhpcy5lZGdlcywge1xuICAgICAgICAgICAgZmlyc3ROb2RlTGFiZWwsXG4gICAgICAgICAgICBsYXN0Tm9kZUxhYmVsLFxuICAgICAgICAgICAgd2l0aFN0eWxlcyxcbiAgICAgICAgICAgIGN1cnZlU3R5bGUsXG4gICAgICAgICAgICBub2RlQ29sb3JzLFxuICAgICAgICAgICAgd3JhcExhYmVsTldvcmRzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZHJhd01lcm1haWRQbmcocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IG1lcm1haWRTeW50YXggPSB0aGlzLmRyYXdNZXJtYWlkKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiBkcmF3TWVybWFpZFBuZyhtZXJtYWlkU3ludGF4LCB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHBhcmFtcz8uYmFja2dyb3VuZENvbG9yLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/graph.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/graph_mermaid.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/graph_mermaid.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawMermaid: () => (/* binding */ drawMermaid),\n/* harmony export */   drawMermaidPng: () => (/* binding */ drawMermaidPng)\n/* harmony export */ });\nfunction _escapeNodeLabel(nodeLabel) {\n    // Escapes the node label for Mermaid syntax.\n    return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, \"_\");\n}\n// Adjusts Mermaid edge to map conditional nodes to pure nodes.\nfunction _adjustMermaidEdge(edge, nodes) {\n    const sourceNodeLabel = nodes[edge.source] ?? edge.source;\n    const targetNodeLabel = nodes[edge.target] ?? edge.target;\n    return [sourceNodeLabel, targetNodeLabel];\n}\nfunction _generateMermaidGraphStyles(nodeColors) {\n    let styles = \"\";\n    for (const [className, color] of Object.entries(nodeColors)) {\n        styles += `\\tclassDef ${className}class fill:${color};\\n`;\n    }\n    return styles;\n}\n/**\n * Draws a Mermaid graph using the provided graph data\n */\nfunction drawMermaid(nodes, edges, config) {\n    const { firstNodeLabel, lastNodeLabel, nodeColors, withStyles = true, curveStyle = \"linear\", wrapLabelNWords = 9, } = config ?? {};\n    // Initialize Mermaid graph configuration\n    let mermaidGraph = withStyles\n        ? `%%{init: {'flowchart': {'curve': '${curveStyle}'}}}%%\\ngraph TD;\\n`\n        : \"graph TD;\\n\";\n    if (withStyles) {\n        // Node formatting templates\n        const defaultClassLabel = \"default\";\n        const formatDict = {\n            [defaultClassLabel]: \"{0}([{1}]):::otherclass\",\n        };\n        if (firstNodeLabel !== undefined) {\n            formatDict[firstNodeLabel] = \"{0}[{0}]:::startclass\";\n        }\n        if (lastNodeLabel !== undefined) {\n            formatDict[lastNodeLabel] = \"{0}[{0}]:::endclass\";\n        }\n        // Add nodes to the graph\n        for (const node of Object.values(nodes)) {\n            const nodeLabel = formatDict[node] ?? formatDict[defaultClassLabel];\n            const escapedNodeLabel = _escapeNodeLabel(node);\n            const nodeParts = node.split(\":\");\n            const nodeSplit = nodeParts[nodeParts.length - 1];\n            mermaidGraph += `\\t${nodeLabel\n                .replace(/\\{0\\}/g, escapedNodeLabel)\n                .replace(/\\{1\\}/g, nodeSplit)};\\n`;\n        }\n    }\n    let subgraph = \"\";\n    // Add edges to the graph\n    for (const edge of edges) {\n        const sourcePrefix = edge.source.includes(\":\")\n            ? edge.source.split(\":\")[0]\n            : undefined;\n        const targetPrefix = edge.target.includes(\":\")\n            ? edge.target.split(\":\")[0]\n            : undefined;\n        // Exit subgraph if source or target is not in the same subgraph\n        if (subgraph !== \"\" &&\n            (subgraph !== sourcePrefix || subgraph !== targetPrefix)) {\n            mermaidGraph += \"\\tend\\n\";\n            subgraph = \"\";\n        }\n        // Enter subgraph if source and target are in the same subgraph\n        if (subgraph === \"\" &&\n            sourcePrefix !== undefined &&\n            sourcePrefix === targetPrefix) {\n            mermaidGraph = `\\tsubgraph ${sourcePrefix}\\n`;\n            subgraph = sourcePrefix;\n        }\n        const [source, target] = _adjustMermaidEdge(edge, nodes);\n        let edgeLabel = \"\";\n        // Add BR every wrapLabelNWords words\n        if (edge.data !== undefined) {\n            let edgeData = edge.data;\n            const words = edgeData.split(\" \");\n            // Group words into chunks of wrapLabelNWords size\n            if (words.length > wrapLabelNWords) {\n                edgeData = words\n                    .reduce((acc, word, i) => {\n                    if (i % wrapLabelNWords === 0)\n                        acc.push(\"\");\n                    acc[acc.length - 1] += ` ${word}`;\n                    return acc;\n                }, [])\n                    .join(\"<br>\");\n            }\n            if (edge.conditional) {\n                edgeLabel = ` -. ${edgeData} .-> `;\n            }\n            else {\n                edgeLabel = ` -- ${edgeData} --> `;\n            }\n        }\n        else {\n            if (edge.conditional) {\n                edgeLabel = ` -.-> `;\n            }\n            else {\n                edgeLabel = ` --> `;\n            }\n        }\n        mermaidGraph += `\\t${_escapeNodeLabel(source)}${edgeLabel}${_escapeNodeLabel(target)};\\n`;\n    }\n    if (subgraph !== \"\") {\n        mermaidGraph += \"end\\n\";\n    }\n    // Add custom styles for nodes\n    if (withStyles && nodeColors !== undefined) {\n        mermaidGraph += _generateMermaidGraphStyles(nodeColors);\n    }\n    return mermaidGraph;\n}\n/**\n * Renders Mermaid graph using the Mermaid.INK API.\n */\nasync function drawMermaidPng(mermaidSyntax, config) {\n    let { backgroundColor = \"white\" } = config ?? {};\n    // Use btoa for compatibility, assume ASCII\n    const mermaidSyntaxEncoded = btoa(mermaidSyntax);\n    // Check if the background color is a hexadecimal color code using regex\n    if (backgroundColor !== undefined) {\n        const hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;\n        if (!hexColorPattern.test(backgroundColor)) {\n            backgroundColor = `!${backgroundColor}`;\n        }\n    }\n    const imageUrl = `https://mermaid.ink/img/${mermaidSyntaxEncoded}?bgColor=${backgroundColor}`;\n    const res = await fetch(imageUrl);\n    if (!res.ok) {\n        throw new Error([\n            `Failed to render the graph using the Mermaid.INK API.`,\n            `Status code: ${res.status}`,\n            `Status text: ${res.statusText}`,\n        ].join(\"\\n\"));\n    }\n    const content = await res.blob();\n    return content;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy9ncmFwaF9tZXJtYWlkLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxhQUFhLE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLDRHQUE0RztBQUN4SDtBQUNBO0FBQ0EsY0FBYyxPQUFPLGNBQWMsWUFBWSxXQUFXLElBQUksYUFBYTtBQUMzRSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRSxHQUFHLEVBQUU7QUFDMUM7QUFDQTtBQUNBLDJDQUEyQyxFQUFFLEVBQUUsRUFBRTtBQUNqRDtBQUNBO0FBQ0EsMENBQTBDLEVBQUUsRUFBRSxFQUFFO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDRCQUE0QixHQUFHO0FBQy9CLDRCQUE0QixHQUFHLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEtBQUs7QUFDcEQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlCQUF5QixFQUFFLFVBQVUsRUFBRSwwQkFBMEI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFVBQVUsNEJBQTRCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUUsRUFBRSxJQUFJO0FBQzFEO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0EsZ0RBQWdELHFCQUFxQixXQUFXLGdCQUFnQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFx0ZXh0c3BsaXR0ZXJzXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHJ1bm5hYmxlc1xcZ3JhcGhfbWVybWFpZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZXNjYXBlTm9kZUxhYmVsKG5vZGVMYWJlbCkge1xuICAgIC8vIEVzY2FwZXMgdGhlIG5vZGUgbGFiZWwgZm9yIE1lcm1haWQgc3ludGF4LlxuICAgIHJldHVybiBub2RlTGFiZWwucmVwbGFjZSgvW15hLXpBLVotXzAtOV0vZywgXCJfXCIpO1xufVxuLy8gQWRqdXN0cyBNZXJtYWlkIGVkZ2UgdG8gbWFwIGNvbmRpdGlvbmFsIG5vZGVzIHRvIHB1cmUgbm9kZXMuXG5mdW5jdGlvbiBfYWRqdXN0TWVybWFpZEVkZ2UoZWRnZSwgbm9kZXMpIHtcbiAgICBjb25zdCBzb3VyY2VOb2RlTGFiZWwgPSBub2Rlc1tlZGdlLnNvdXJjZV0gPz8gZWRnZS5zb3VyY2U7XG4gICAgY29uc3QgdGFyZ2V0Tm9kZUxhYmVsID0gbm9kZXNbZWRnZS50YXJnZXRdID8/IGVkZ2UudGFyZ2V0O1xuICAgIHJldHVybiBbc291cmNlTm9kZUxhYmVsLCB0YXJnZXROb2RlTGFiZWxdO1xufVxuZnVuY3Rpb24gX2dlbmVyYXRlTWVybWFpZEdyYXBoU3R5bGVzKG5vZGVDb2xvcnMpIHtcbiAgICBsZXQgc3R5bGVzID0gXCJcIjtcbiAgICBmb3IgKGNvbnN0IFtjbGFzc05hbWUsIGNvbG9yXSBvZiBPYmplY3QuZW50cmllcyhub2RlQ29sb3JzKSkge1xuICAgICAgICBzdHlsZXMgKz0gYFxcdGNsYXNzRGVmICR7Y2xhc3NOYW1lfWNsYXNzIGZpbGw6JHtjb2xvcn07XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlcztcbn1cbi8qKlxuICogRHJhd3MgYSBNZXJtYWlkIGdyYXBoIHVzaW5nIHRoZSBwcm92aWRlZCBncmFwaCBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkcmF3TWVybWFpZChub2RlcywgZWRnZXMsIGNvbmZpZykge1xuICAgIGNvbnN0IHsgZmlyc3ROb2RlTGFiZWwsIGxhc3ROb2RlTGFiZWwsIG5vZGVDb2xvcnMsIHdpdGhTdHlsZXMgPSB0cnVlLCBjdXJ2ZVN0eWxlID0gXCJsaW5lYXJcIiwgd3JhcExhYmVsTldvcmRzID0gOSwgfSA9IGNvbmZpZyA/PyB7fTtcbiAgICAvLyBJbml0aWFsaXplIE1lcm1haWQgZ3JhcGggY29uZmlndXJhdGlvblxuICAgIGxldCBtZXJtYWlkR3JhcGggPSB3aXRoU3R5bGVzXG4gICAgICAgID8gYCUle2luaXQ6IHsnZmxvd2NoYXJ0JzogeydjdXJ2ZSc6ICcke2N1cnZlU3R5bGV9J319fSUlXFxuZ3JhcGggVEQ7XFxuYFxuICAgICAgICA6IFwiZ3JhcGggVEQ7XFxuXCI7XG4gICAgaWYgKHdpdGhTdHlsZXMpIHtcbiAgICAgICAgLy8gTm9kZSBmb3JtYXR0aW5nIHRlbXBsYXRlc1xuICAgICAgICBjb25zdCBkZWZhdWx0Q2xhc3NMYWJlbCA9IFwiZGVmYXVsdFwiO1xuICAgICAgICBjb25zdCBmb3JtYXREaWN0ID0ge1xuICAgICAgICAgICAgW2RlZmF1bHRDbGFzc0xhYmVsXTogXCJ7MH0oW3sxfV0pOjo6b3RoZXJjbGFzc1wiLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZmlyc3ROb2RlTGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9ybWF0RGljdFtmaXJzdE5vZGVMYWJlbF0gPSBcInswfVt7MH1dOjo6c3RhcnRjbGFzc1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0Tm9kZUxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdERpY3RbbGFzdE5vZGVMYWJlbF0gPSBcInswfVt7MH1dOjo6ZW5kY2xhc3NcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgbm9kZXMgdG8gdGhlIGdyYXBoXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBPYmplY3QudmFsdWVzKG5vZGVzKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUxhYmVsID0gZm9ybWF0RGljdFtub2RlXSA/PyBmb3JtYXREaWN0W2RlZmF1bHRDbGFzc0xhYmVsXTtcbiAgICAgICAgICAgIGNvbnN0IGVzY2FwZWROb2RlTGFiZWwgPSBfZXNjYXBlTm9kZUxhYmVsKG5vZGUpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZVBhcnRzID0gbm9kZS5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICBjb25zdCBub2RlU3BsaXQgPSBub2RlUGFydHNbbm9kZVBhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgbWVybWFpZEdyYXBoICs9IGBcXHQke25vZGVMYWJlbFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHswXFx9L2csIGVzY2FwZWROb2RlTGFiZWwpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcezFcXH0vZywgbm9kZVNwbGl0KX07XFxuYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3ViZ3JhcGggPSBcIlwiO1xuICAgIC8vIEFkZCBlZGdlcyB0byB0aGUgZ3JhcGhcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZWRnZXMpIHtcbiAgICAgICAgY29uc3Qgc291cmNlUHJlZml4ID0gZWRnZS5zb3VyY2UuaW5jbHVkZXMoXCI6XCIpXG4gICAgICAgICAgICA/IGVkZ2Uuc291cmNlLnNwbGl0KFwiOlwiKVswXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHRhcmdldFByZWZpeCA9IGVkZ2UudGFyZ2V0LmluY2x1ZGVzKFwiOlwiKVxuICAgICAgICAgICAgPyBlZGdlLnRhcmdldC5zcGxpdChcIjpcIilbMF1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBFeGl0IHN1YmdyYXBoIGlmIHNvdXJjZSBvciB0YXJnZXQgaXMgbm90IGluIHRoZSBzYW1lIHN1YmdyYXBoXG4gICAgICAgIGlmIChzdWJncmFwaCAhPT0gXCJcIiAmJlxuICAgICAgICAgICAgKHN1YmdyYXBoICE9PSBzb3VyY2VQcmVmaXggfHwgc3ViZ3JhcGggIT09IHRhcmdldFByZWZpeCkpIHtcbiAgICAgICAgICAgIG1lcm1haWRHcmFwaCArPSBcIlxcdGVuZFxcblwiO1xuICAgICAgICAgICAgc3ViZ3JhcGggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVudGVyIHN1YmdyYXBoIGlmIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBpbiB0aGUgc2FtZSBzdWJncmFwaFxuICAgICAgICBpZiAoc3ViZ3JhcGggPT09IFwiXCIgJiZcbiAgICAgICAgICAgIHNvdXJjZVByZWZpeCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBzb3VyY2VQcmVmaXggPT09IHRhcmdldFByZWZpeCkge1xuICAgICAgICAgICAgbWVybWFpZEdyYXBoID0gYFxcdHN1YmdyYXBoICR7c291cmNlUHJlZml4fVxcbmA7XG4gICAgICAgICAgICBzdWJncmFwaCA9IHNvdXJjZVByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbc291cmNlLCB0YXJnZXRdID0gX2FkanVzdE1lcm1haWRFZGdlKGVkZ2UsIG5vZGVzKTtcbiAgICAgICAgbGV0IGVkZ2VMYWJlbCA9IFwiXCI7XG4gICAgICAgIC8vIEFkZCBCUiBldmVyeSB3cmFwTGFiZWxOV29yZHMgd29yZHNcbiAgICAgICAgaWYgKGVkZ2UuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgZWRnZURhdGEgPSBlZGdlLmRhdGE7XG4gICAgICAgICAgICBjb25zdCB3b3JkcyA9IGVkZ2VEYXRhLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICAgIC8vIEdyb3VwIHdvcmRzIGludG8gY2h1bmtzIG9mIHdyYXBMYWJlbE5Xb3JkcyBzaXplXG4gICAgICAgICAgICBpZiAod29yZHMubGVuZ3RoID4gd3JhcExhYmVsTldvcmRzKSB7XG4gICAgICAgICAgICAgICAgZWRnZURhdGEgPSB3b3Jkc1xuICAgICAgICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIHdvcmQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgJSB3cmFwTGFiZWxOV29yZHMgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2MucHVzaChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2FjYy5sZW5ndGggLSAxXSArPSBgICR7d29yZH1gO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAuam9pbihcIjxicj5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWRnZS5jb25kaXRpb25hbCkge1xuICAgICAgICAgICAgICAgIGVkZ2VMYWJlbCA9IGAgLS4gJHtlZGdlRGF0YX0gLi0+IGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlZGdlTGFiZWwgPSBgIC0tICR7ZWRnZURhdGF9IC0tPiBgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVkZ2UuY29uZGl0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICBlZGdlTGFiZWwgPSBgIC0uLT4gYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVkZ2VMYWJlbCA9IGAgLS0+IGA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWVybWFpZEdyYXBoICs9IGBcXHQke19lc2NhcGVOb2RlTGFiZWwoc291cmNlKX0ke2VkZ2VMYWJlbH0ke19lc2NhcGVOb2RlTGFiZWwodGFyZ2V0KX07XFxuYDtcbiAgICB9XG4gICAgaWYgKHN1YmdyYXBoICE9PSBcIlwiKSB7XG4gICAgICAgIG1lcm1haWRHcmFwaCArPSBcImVuZFxcblwiO1xuICAgIH1cbiAgICAvLyBBZGQgY3VzdG9tIHN0eWxlcyBmb3Igbm9kZXNcbiAgICBpZiAod2l0aFN0eWxlcyAmJiBub2RlQ29sb3JzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWVybWFpZEdyYXBoICs9IF9nZW5lcmF0ZU1lcm1haWRHcmFwaFN0eWxlcyhub2RlQ29sb3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcm1haWRHcmFwaDtcbn1cbi8qKlxuICogUmVuZGVycyBNZXJtYWlkIGdyYXBoIHVzaW5nIHRoZSBNZXJtYWlkLklOSyBBUEkuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkcmF3TWVybWFpZFBuZyhtZXJtYWlkU3ludGF4LCBjb25maWcpIHtcbiAgICBsZXQgeyBiYWNrZ3JvdW5kQ29sb3IgPSBcIndoaXRlXCIgfSA9IGNvbmZpZyA/PyB7fTtcbiAgICAvLyBVc2UgYnRvYSBmb3IgY29tcGF0aWJpbGl0eSwgYXNzdW1lIEFTQ0lJXG4gICAgY29uc3QgbWVybWFpZFN5bnRheEVuY29kZWQgPSBidG9hKG1lcm1haWRTeW50YXgpO1xuICAgIC8vIENoZWNrIGlmIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGlzIGEgaGV4YWRlY2ltYWwgY29sb3IgY29kZSB1c2luZyByZWdleFxuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBoZXhDb2xvclBhdHRlcm4gPSAvXiMoPzpbMC05YS1mQS1GXXszfSl7MSwyfSQvO1xuICAgICAgICBpZiAoIWhleENvbG9yUGF0dGVybi50ZXN0KGJhY2tncm91bmRDb2xvcikpIHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IGAhJHtiYWNrZ3JvdW5kQ29sb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbWFnZVVybCA9IGBodHRwczovL21lcm1haWQuaW5rL2ltZy8ke21lcm1haWRTeW50YXhFbmNvZGVkfT9iZ0NvbG9yPSR7YmFja2dyb3VuZENvbG9yfWA7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goaW1hZ2VVcmwpO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgICAgICBgRmFpbGVkIHRvIHJlbmRlciB0aGUgZ3JhcGggdXNpbmcgdGhlIE1lcm1haWQuSU5LIEFQSS5gLFxuICAgICAgICAgICAgYFN0YXR1cyBjb2RlOiAke3Jlcy5zdGF0dXN9YCxcbiAgICAgICAgICAgIGBTdGF0dXMgdGV4dDogJHtyZXMuc3RhdHVzVGV4dH1gLFxuICAgICAgICBdLmpvaW4oXCJcXG5cIikpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVzLmJsb2IoKTtcbiAgICByZXR1cm4gY29udGVudDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/graph_mermaid.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/iter.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/iter.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   consumeAsyncIterableInContext: () => (/* binding */ consumeAsyncIterableInContext),\n/* harmony export */   consumeIteratorInContext: () => (/* binding */ consumeIteratorInContext),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),\n/* harmony export */   isIterableIterator: () => (/* binding */ isIterableIterator),\n/* harmony export */   isIterator: () => (/* binding */ isIterator)\n/* harmony export */ });\n/* harmony import */ var _singletons_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../singletons/index.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/singletons/index.js\");\n\nfunction isIterableIterator(thing) {\n    return (typeof thing === \"object\" &&\n        thing !== null &&\n        typeof thing[Symbol.iterator] === \"function\" &&\n        // avoid detecting array/set as iterator\n        typeof thing.next === \"function\");\n}\nconst isIterator = (x) => x != null &&\n    typeof x === \"object\" &&\n    \"next\" in x &&\n    typeof x.next === \"function\";\nfunction isAsyncIterable(thing) {\n    return (typeof thing === \"object\" &&\n        thing !== null &&\n        typeof thing[Symbol.asyncIterator] ===\n            \"function\");\n}\nfunction* consumeIteratorInContext(context, iter) {\n    while (true) {\n        const { value, done } = _singletons_index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.runWithConfig(context, iter.next.bind(iter), true);\n        if (done) {\n            break;\n        }\n        else {\n            yield value;\n        }\n    }\n}\nasync function* consumeAsyncIterableInContext(context, iter) {\n    const iterator = iter[Symbol.asyncIterator]();\n    while (true) {\n        const { value, done } = await _singletons_index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.runWithConfig(context, iterator.next.bind(iter), true);\n        if (done) {\n            break;\n        }\n        else {\n            yield value;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy9pdGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE0RTtBQUNyRTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdCQUFnQixjQUFjLEVBQUUsb0ZBQWtDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYyxRQUFRLG9GQUFrQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcdGV4dHNwbGl0dGVyc1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxydW5uYWJsZXNcXGl0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiB9IGZyb20gXCIuLi9zaW5nbGV0b25zL2luZGV4LmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gaXNJdGVyYWJsZUl0ZXJhdG9yKHRoaW5nKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdGhpbmcgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgdGhpbmcgIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHRoaW5nW1N5bWJvbC5pdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAvLyBhdm9pZCBkZXRlY3RpbmcgYXJyYXkvc2V0IGFzIGl0ZXJhdG9yXG4gICAgICAgIHR5cGVvZiB0aGluZy5uZXh0ID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZXhwb3J0IGNvbnN0IGlzSXRlcmF0b3IgPSAoeCkgPT4geCAhPSBudWxsICYmXG4gICAgdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiZcbiAgICBcIm5leHRcIiBpbiB4ICYmXG4gICAgdHlwZW9mIHgubmV4dCA9PT0gXCJmdW5jdGlvblwiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZSh0aGluZykge1xuICAgIHJldHVybiAodHlwZW9mIHRoaW5nID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHRoaW5nICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB0aGluZ1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uKiBjb25zdW1lSXRlcmF0b3JJbkNvbnRleHQoY29udGV4dCwgaXRlcikge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZyhjb250ZXh0LCBpdGVyLm5leHQuYmluZChpdGVyKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiBjb25zdW1lQXN5bmNJdGVyYWJsZUluQ29udGV4dChjb250ZXh0LCBpdGVyKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBpdGVyW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZyhjb250ZXh0LCBpdGVyYXRvci5uZXh0LmJpbmQoaXRlciksIHRydWUpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/iter.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/utils.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/utils.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _RootEventFilter: () => (/* binding */ _RootEventFilter),\n/* harmony export */   isRunnableInterface: () => (/* binding */ isRunnableInterface)\n/* harmony export */ });\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isRunnableInterface(thing) {\n    return thing ? thing.lc_runnable : false;\n}\n/**\n * Utility to filter the root event in the streamEvents implementation.\n * This is simply binding the arguments to the namespace to make save on\n * a bit of typing in the streamEvents implementation.\n *\n * TODO: Refactor and remove.\n */\nclass _RootEventFilter {\n    constructor(fields) {\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.includeNames = fields.includeNames;\n        this.includeTypes = fields.includeTypes;\n        this.includeTags = fields.includeTags;\n        this.excludeNames = fields.excludeNames;\n        this.excludeTypes = fields.excludeTypes;\n        this.excludeTags = fields.excludeTags;\n    }\n    includeEvent(event, rootType) {\n        let include = this.includeNames === undefined &&\n            this.includeTypes === undefined &&\n            this.includeTags === undefined;\n        const eventTags = event.tags ?? [];\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(event.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(rootType);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include || eventTags.some((tag) => this.includeTags?.includes(tag));\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(event.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(rootType);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && eventTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXHRleHRzcGxpdHRlcnNcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxccnVubmFibGVzXFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGZ1bmN0aW9uIGlzUnVubmFibGVJbnRlcmZhY2UodGhpbmcpIHtcbiAgICByZXR1cm4gdGhpbmcgPyB0aGluZy5sY19ydW5uYWJsZSA6IGZhbHNlO1xufVxuLyoqXG4gKiBVdGlsaXR5IHRvIGZpbHRlciB0aGUgcm9vdCBldmVudCBpbiB0aGUgc3RyZWFtRXZlbnRzIGltcGxlbWVudGF0aW9uLlxuICogVGhpcyBpcyBzaW1wbHkgYmluZGluZyB0aGUgYXJndW1lbnRzIHRvIHRoZSBuYW1lc3BhY2UgdG8gbWFrZSBzYXZlIG9uXG4gKiBhIGJpdCBvZiB0eXBpbmcgaW4gdGhlIHN0cmVhbUV2ZW50cyBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUT0RPOiBSZWZhY3RvciBhbmQgcmVtb3ZlLlxuICovXG5leHBvcnQgY2xhc3MgX1Jvb3RFdmVudEZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVOYW1lc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlVHlwZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZU5hbWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVUeXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmluY2x1ZGVOYW1lcyA9IGZpZWxkcy5pbmNsdWRlTmFtZXM7XG4gICAgICAgIHRoaXMuaW5jbHVkZVR5cGVzID0gZmllbGRzLmluY2x1ZGVUeXBlcztcbiAgICAgICAgdGhpcy5pbmNsdWRlVGFncyA9IGZpZWxkcy5pbmNsdWRlVGFncztcbiAgICAgICAgdGhpcy5leGNsdWRlTmFtZXMgPSBmaWVsZHMuZXhjbHVkZU5hbWVzO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVUeXBlcyA9IGZpZWxkcy5leGNsdWRlVHlwZXM7XG4gICAgICAgIHRoaXMuZXhjbHVkZVRhZ3MgPSBmaWVsZHMuZXhjbHVkZVRhZ3M7XG4gICAgfVxuICAgIGluY2x1ZGVFdmVudChldmVudCwgcm9vdFR5cGUpIHtcbiAgICAgICAgbGV0IGluY2x1ZGUgPSB0aGlzLmluY2x1ZGVOYW1lcyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVUeXBlcyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGV2ZW50VGFncyA9IGV2ZW50LnRhZ3MgPz8gW107XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSB8fCB0aGlzLmluY2x1ZGVOYW1lcy5pbmNsdWRlcyhldmVudC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgfHwgdGhpcy5pbmNsdWRlVHlwZXMuaW5jbHVkZXMocm9vdFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVUYWdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgfHwgZXZlbnRUYWdzLnNvbWUoKHRhZykgPT4gdGhpcy5pbmNsdWRlVGFncz8uaW5jbHVkZXModGFnKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZU5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlICYmICF0aGlzLmV4Y2x1ZGVOYW1lcy5pbmNsdWRlcyhldmVudC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlVHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgJiYgIXRoaXMuZXhjbHVkZVR5cGVzLmluY2x1ZGVzKHJvb3RUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlICYmIGV2ZW50VGFncy5ldmVyeSgodGFnKSA9PiAhdGhpcy5leGNsdWRlVGFncz8uaW5jbHVkZXModGFnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/utils.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/wrappers.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/wrappers.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertToHttpEventStream: () => (/* binding */ convertToHttpEventStream)\n/* harmony export */ });\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/stream.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/stream.js\");\n\nfunction convertToHttpEventStream(stream) {\n    const encoder = new TextEncoder();\n    const finalStream = new ReadableStream({\n        async start(controller) {\n            for await (const chunk of stream) {\n                controller.enqueue(encoder.encode(`event: data\\ndata: ${JSON.stringify(chunk)}\\n\\n`));\n            }\n            controller.enqueue(encoder.encode(\"event: end\\n\\n\"));\n            controller.close();\n        },\n    });\n    return _utils_stream_js__WEBPACK_IMPORTED_MODULE_0__.IterableReadableStream.fromReadableStream(finalStream);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy93cmFwcGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE0RDtBQUNyRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLHNCQUFzQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLFdBQVcsb0VBQXNCO0FBQ2pDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcdGV4dHNwbGl0dGVyc1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFxydW5uYWJsZXNcXHdyYXBwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0gfSBmcm9tIFwiLi4vdXRpbHMvc3RyZWFtLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvSHR0cEV2ZW50U3RyZWFtKHN0cmVhbSkge1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBmaW5hbFN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKGBldmVudDogZGF0YVxcbmRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoY2h1bmspfVxcblxcbmApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShcImV2ZW50OiBlbmRcXG5cXG5cIikpO1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbShmaW5hbFN0cmVhbSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/runnables/wrappers.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/singletons/index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/singletons/index.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* binding */ AsyncLocalStorageProviderSingleton),\n/* harmony export */   MockAsyncLocalStorage: () => (/* binding */ MockAsyncLocalStorage)\n/* harmony export */ });\n/* harmony import */ var langsmith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! langsmith */ \"(action-browser)/./node_modules/langsmith/index.js\");\n/* harmony import */ var _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../callbacks/manager.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/callbacks/manager.js\");\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n\nclass MockAsyncLocalStorage {\n    getStore() {\n        return undefined;\n    }\n    run(_store, callback) {\n        return callback();\n    }\n}\nconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\nconst TRACING_ALS_KEY = Symbol.for(\"ls:tracing_async_local_storage\");\nconst LC_CHILD_KEY = Symbol.for(\"lc:child_config\");\nclass AsyncLocalStorageProvider {\n    getInstance() {\n        return globalThis[TRACING_ALS_KEY] ?? mockAsyncLocalStorage;\n    }\n    getRunnableConfig() {\n        const storage = this.getInstance();\n        // this has the runnable config\n        // which means that we should also have an instance of a LangChainTracer\n        // with the run map prepopulated\n        return storage.getStore()?.extra?.[LC_CHILD_KEY];\n    }\n    runWithConfig(config, callback, avoidCreatingRootRunTree) {\n        const callbackManager = _callbacks_manager_js__WEBPACK_IMPORTED_MODULE_1__.CallbackManager._configureSync(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n        const storage = this.getInstance();\n        const parentRunId = callbackManager?.getParentRunId();\n        const langChainTracer = callbackManager?.handlers?.find((handler) => handler?.name === \"langchain_tracer\");\n        let runTree;\n        if (langChainTracer && parentRunId) {\n            runTree = langChainTracer.convertToRunTree(parentRunId);\n        }\n        else if (!avoidCreatingRootRunTree) {\n            runTree = new langsmith__WEBPACK_IMPORTED_MODULE_0__.RunTree({\n                name: \"<runnable_lambda>\",\n                tracingEnabled: false,\n            });\n        }\n        if (runTree) {\n            runTree.extra = { ...runTree.extra, [LC_CHILD_KEY]: config };\n        }\n        return storage.run(runTree, callback);\n    }\n    initializeGlobalInstance(instance) {\n        if (globalThis[TRACING_ALS_KEY] === undefined) {\n            globalThis[TRACING_ALS_KEY] = instance;\n        }\n    }\n}\nconst AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3NpbmdsZXRvbnMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ29DO0FBQ3NCO0FBQ25EO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0VBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBTztBQUNqQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFx0ZXh0c3BsaXR0ZXJzXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHNpbmdsZXRvbnNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmltcG9ydCB7IFJ1blRyZWUgfSBmcm9tIFwibGFuZ3NtaXRoXCI7XG5pbXBvcnQgeyBDYWxsYmFja01hbmFnZXIgfSBmcm9tIFwiLi4vY2FsbGJhY2tzL21hbmFnZXIuanNcIjtcbmV4cG9ydCBjbGFzcyBNb2NrQXN5bmNMb2NhbFN0b3JhZ2Uge1xuICAgIGdldFN0b3JlKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBydW4oX3N0b3JlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG59XG5jb25zdCBtb2NrQXN5bmNMb2NhbFN0b3JhZ2UgPSBuZXcgTW9ja0FzeW5jTG9jYWxTdG9yYWdlKCk7XG5jb25zdCBUUkFDSU5HX0FMU19LRVkgPSBTeW1ib2wuZm9yKFwibHM6dHJhY2luZ19hc3luY19sb2NhbF9zdG9yYWdlXCIpO1xuY29uc3QgTENfQ0hJTERfS0VZID0gU3ltYm9sLmZvcihcImxjOmNoaWxkX2NvbmZpZ1wiKTtcbmNsYXNzIEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXIge1xuICAgIGdldEluc3RhbmNlKCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpc1tUUkFDSU5HX0FMU19LRVldID8/IG1vY2tBc3luY0xvY2FsU3RvcmFnZTtcbiAgICB9XG4gICAgZ2V0UnVubmFibGVDb25maWcoKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmdldEluc3RhbmNlKCk7XG4gICAgICAgIC8vIHRoaXMgaGFzIHRoZSBydW5uYWJsZSBjb25maWdcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgdGhhdCB3ZSBzaG91bGQgYWxzbyBoYXZlIGFuIGluc3RhbmNlIG9mIGEgTGFuZ0NoYWluVHJhY2VyXG4gICAgICAgIC8vIHdpdGggdGhlIHJ1biBtYXAgcHJlcG9wdWxhdGVkXG4gICAgICAgIHJldHVybiBzdG9yYWdlLmdldFN0b3JlKCk/LmV4dHJhPy5bTENfQ0hJTERfS0VZXTtcbiAgICB9XG4gICAgcnVuV2l0aENvbmZpZyhjb25maWcsIGNhbGxiYWNrLCBhdm9pZENyZWF0aW5nUm9vdFJ1blRyZWUpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyID0gQ2FsbGJhY2tNYW5hZ2VyLl9jb25maWd1cmVTeW5jKGNvbmZpZz8uY2FsbGJhY2tzLCB1bmRlZmluZWQsIGNvbmZpZz8udGFncywgdW5kZWZpbmVkLCBjb25maWc/Lm1ldGFkYXRhKTtcbiAgICAgICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgY29uc3QgcGFyZW50UnVuSWQgPSBjYWxsYmFja01hbmFnZXI/LmdldFBhcmVudFJ1bklkKCk7XG4gICAgICAgIGNvbnN0IGxhbmdDaGFpblRyYWNlciA9IGNhbGxiYWNrTWFuYWdlcj8uaGFuZGxlcnM/LmZpbmQoKGhhbmRsZXIpID0+IGhhbmRsZXI/Lm5hbWUgPT09IFwibGFuZ2NoYWluX3RyYWNlclwiKTtcbiAgICAgICAgbGV0IHJ1blRyZWU7XG4gICAgICAgIGlmIChsYW5nQ2hhaW5UcmFjZXIgJiYgcGFyZW50UnVuSWQpIHtcbiAgICAgICAgICAgIHJ1blRyZWUgPSBsYW5nQ2hhaW5UcmFjZXIuY29udmVydFRvUnVuVHJlZShwYXJlbnRSdW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWF2b2lkQ3JlYXRpbmdSb290UnVuVHJlZSkge1xuICAgICAgICAgICAgcnVuVHJlZSA9IG5ldyBSdW5UcmVlKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIjxydW5uYWJsZV9sYW1iZGE+XCIsXG4gICAgICAgICAgICAgICAgdHJhY2luZ0VuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1blRyZWUpIHtcbiAgICAgICAgICAgIHJ1blRyZWUuZXh0cmEgPSB7IC4uLnJ1blRyZWUuZXh0cmEsIFtMQ19DSElMRF9LRVldOiBjb25maWcgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmFnZS5ydW4ocnVuVHJlZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBpbml0aWFsaXplR2xvYmFsSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXNbVFJBQ0lOR19BTFNfS0VZXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBnbG9iYWxUaGlzW1RSQUNJTkdfQUxTX0tFWV0gPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gPSBuZXcgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlcigpO1xuZXhwb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/singletons/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tools/utils.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tools/utils.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ToolInputParsingException: () => (/* binding */ ToolInputParsingException),\n/* harmony export */   _isToolCall: () => (/* binding */ _isToolCall)\n/* harmony export */ });\nfunction _isToolCall(toolCall) {\n    return !!(toolCall &&\n        typeof toolCall === \"object\" &&\n        \"type\" in toolCall &&\n        toolCall.type === \"tool_call\");\n}\n/**\n * Custom error class used to handle exceptions related to tool input parsing.\n * It extends the built-in `Error` class and adds an optional `output`\n * property that can hold the output that caused the exception.\n */\nclass ToolInputParsingException extends Error {\n    constructor(message, output) {\n        super(message);\n        Object.defineProperty(this, \"output\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.output = output;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3Rvb2xzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcdGV4dHNwbGl0dGVyc1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx0b29sc1xcdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIF9pc1Rvb2xDYWxsKHRvb2xDYWxsKSB7XG4gICAgcmV0dXJuICEhKHRvb2xDYWxsICYmXG4gICAgICAgIHR5cGVvZiB0b29sQ2FsbCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBcInR5cGVcIiBpbiB0b29sQ2FsbCAmJlxuICAgICAgICB0b29sQ2FsbC50eXBlID09PSBcInRvb2xfY2FsbFwiKTtcbn1cbi8qKlxuICogQ3VzdG9tIGVycm9yIGNsYXNzIHVzZWQgdG8gaGFuZGxlIGV4Y2VwdGlvbnMgcmVsYXRlZCB0byB0b29sIGlucHV0IHBhcnNpbmcuXG4gKiBJdCBleHRlbmRzIHRoZSBidWlsdC1pbiBgRXJyb3JgIGNsYXNzIGFuZCBhZGRzIGFuIG9wdGlvbmFsIGBvdXRwdXRgXG4gKiBwcm9wZXJ0eSB0aGF0IGNhbiBob2xkIHRoZSBvdXRwdXQgdGhhdCBjYXVzZWQgdGhlIGV4Y2VwdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFRvb2xJbnB1dFBhcnNpbmdFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3V0cHV0KSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvdXRwdXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBvdXRwdXQ7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tools/utils.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/base.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/base.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseTracer: () => (/* binding */ BaseTracer),\n/* harmony export */   isBaseTracer: () => (/* binding */ isBaseTracer)\n/* harmony export */ });\n/* harmony import */ var _callbacks_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../callbacks/base.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/callbacks/base.js\");\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\nfunction stripNonAlphanumeric(input) {\n    return input.replace(/[-:.]/g, \"\");\n}\nfunction convertToDottedOrderFormat(epoch, runId, executionOrder) {\n    const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, \"0\");\n    return (stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId);\n}\nfunction isBaseTracer(x) {\n    return typeof x._addRunToRunMap === \"function\";\n}\nclass BaseTracer extends _callbacks_base_js__WEBPACK_IMPORTED_MODULE_0__.BaseCallbackHandler {\n    constructor(_fields) {\n        super(...arguments);\n        Object.defineProperty(this, \"runMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n    }\n    copy() {\n        return this;\n    }\n    stringifyError(error) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (error instanceof Error) {\n            return error.message + (error?.stack ? `\\n\\n${error.stack}` : \"\");\n        }\n        if (typeof error === \"string\") {\n            return error;\n        }\n        return `${error}`;\n    }\n    _addChildRun(parentRun, childRun) {\n        parentRun.child_runs.push(childRun);\n    }\n    _addRunToRunMap(run) {\n        const currentDottedOrder = convertToDottedOrderFormat(run.start_time, run.id, run.execution_order);\n        const storedRun = { ...run };\n        if (storedRun.parent_run_id !== undefined) {\n            const parentRun = this.runMap.get(storedRun.parent_run_id);\n            if (parentRun) {\n                this._addChildRun(parentRun, storedRun);\n                parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);\n                storedRun.trace_id = parentRun.trace_id;\n                if (parentRun.dotted_order !== undefined) {\n                    storedRun.dotted_order = [\n                        parentRun.dotted_order,\n                        currentDottedOrder,\n                    ].join(\".\");\n                }\n                else {\n                    // This can happen naturally for callbacks added within a run\n                    // console.debug(`Parent run with UUID ${storedRun.parent_run_id} has no dotted order.`);\n                }\n            }\n            else {\n                // This can happen naturally for callbacks added within a run\n                // console.debug(\n                //   `Parent run with UUID ${storedRun.parent_run_id} not found.`\n                // );\n            }\n        }\n        else {\n            storedRun.trace_id = storedRun.id;\n            storedRun.dotted_order = currentDottedOrder;\n        }\n        this.runMap.set(storedRun.id, storedRun);\n        return storedRun;\n    }\n    async _endTrace(run) {\n        const parentRun = run.parent_run_id !== undefined && this.runMap.get(run.parent_run_id);\n        if (parentRun) {\n            parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);\n        }\n        else {\n            await this.persistRun(run);\n        }\n        this.runMap.delete(run.id);\n        await this.onRunUpdate?.(run);\n    }\n    _getExecutionOrder(parentRunId) {\n        const parentRun = parentRunId !== undefined && this.runMap.get(parentRunId);\n        // If a run has no parent then execution order is 1\n        if (!parentRun) {\n            return 1;\n        }\n        return parentRun.child_execution_order + 1;\n    }\n    /**\n     * Create and add a run to the run map for LLM start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: name ?? llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { prompts },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n        const run = this.runMap.get(runId) ??\n            this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onLLMStart?.(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for chat model start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: name ?? llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { messages },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n        const run = this.runMap.get(runId) ??\n            this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onLLMStart?.(run);\n        return run;\n    }\n    async handleLLMEnd(output, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = output;\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onLLMEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleLLMError(error, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onLLMError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for chain start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? chain.id[chain.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: chain,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs,\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: runType ?? \"chain\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n        const run = this.runMap.get(runId) ??\n            this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);\n        await this.onRunCreate?.(run);\n        await this.onChainStart?.(run);\n        return run;\n    }\n    async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {\n        const run = this.runMap.get(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = _coerceToDict(outputs, \"output\");\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        if (kwargs?.inputs !== undefined) {\n            run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n        }\n        await this.onChainEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleChainError(error, runId, _parentRunId, _tags, kwargs) {\n        const run = this.runMap.get(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        if (kwargs?.inputs !== undefined) {\n            run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n        }\n        await this.onChainError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for tool start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? tool.id[tool.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: tool,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { input },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"tool\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n        const run = this.runMap.get(runId) ??\n            this._createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onToolStart?.(run);\n        return run;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleToolEnd(output, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { output };\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onToolEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleToolError(error, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onToolError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleAgentAction(action, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        const agentRun = run;\n        agentRun.actions = agentRun.actions || [];\n        agentRun.actions.push(action);\n        agentRun.events.push({\n            name: \"agent_action\",\n            time: new Date().toISOString(),\n            kwargs: { action },\n        });\n        await this.onAgentAction?.(run);\n    }\n    async handleAgentEnd(action, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"agent_end\",\n            time: new Date().toISOString(),\n            kwargs: { action },\n        });\n        await this.onAgentEnd?.(run);\n    }\n    /**\n     * Create and add a run to the run map for retriever start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? retriever.id[retriever.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: retriever,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { query },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"retriever\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n        const run = this.runMap.get(runId) ??\n            this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onRetrieverStart?.(run);\n        return run;\n    }\n    async handleRetrieverEnd(documents, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { documents };\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onRetrieverEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleRetrieverError(error, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onRetrieverError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleText(text, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"text\",\n            time: new Date().toISOString(),\n            kwargs: { text },\n        });\n        await this.onText?.(run);\n    }\n    async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(`Invalid \"runId\" provided to \"handleLLMNewToken\" callback.`);\n        }\n        run.events.push({\n            name: \"new_token\",\n            time: new Date().toISOString(),\n            kwargs: { token, idx, chunk: fields?.chunk },\n        });\n        await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });\n        return run;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3RyYWNlcnMvYmFzZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJDQUEyQyxFQUFFLFlBQVk7QUFDN0Y7QUFDTztBQUNQO0FBQ0E7QUFDTyx5QkFBeUIsbUVBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFlBQVk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx5QkFBeUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx5QkFBeUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hELFNBQVM7QUFDVCxpREFBaUQsc0JBQXNCO0FBQ3ZFO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXHRleHRzcGxpdHRlcnNcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdHJhY2Vyc1xcYmFzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ2FsbGJhY2tIYW5kbGVyLCB9IGZyb20gXCIuLi9jYWxsYmFja3MvYmFzZS5qc1wiO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIF9jb2VyY2VUb0RpY3QodmFsdWUsIGRlZmF1bHRLZXkpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIlxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogeyBbZGVmYXVsdEtleV06IHZhbHVlIH07XG59XG5mdW5jdGlvbiBzdHJpcE5vbkFscGhhbnVtZXJpYyhpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9bLTouXS9nLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0RvdHRlZE9yZGVyRm9ybWF0KGVwb2NoLCBydW5JZCwgZXhlY3V0aW9uT3JkZXIpIHtcbiAgICBjb25zdCBwYWRkZWRPcmRlciA9IGV4ZWN1dGlvbk9yZGVyLnRvRml4ZWQoMCkuc2xpY2UoMCwgMykucGFkU3RhcnQoMywgXCIwXCIpO1xuICAgIHJldHVybiAoc3RyaXBOb25BbHBoYW51bWVyaWMoYCR7bmV3IERhdGUoZXBvY2gpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgLTEpfSR7cGFkZGVkT3JkZXJ9WmApICsgcnVuSWQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQmFzZVRyYWNlcih4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4Ll9hZGRSdW5Ub1J1bk1hcCA9PT0gXCJmdW5jdGlvblwiO1xufVxuZXhwb3J0IGNsYXNzIEJhc2VUcmFjZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihfZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bk1hcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb3B5KCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RyaW5naWZ5RXJyb3IoZXJyb3IpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2UgKyAoZXJyb3I/LnN0YWNrID8gYFxcblxcbiR7ZXJyb3Iuc3RhY2t9YCA6IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7ZXJyb3J9YDtcbiAgICB9XG4gICAgX2FkZENoaWxkUnVuKHBhcmVudFJ1biwgY2hpbGRSdW4pIHtcbiAgICAgICAgcGFyZW50UnVuLmNoaWxkX3J1bnMucHVzaChjaGlsZFJ1bik7XG4gICAgfVxuICAgIF9hZGRSdW5Ub1J1bk1hcChydW4pIHtcbiAgICAgICAgY29uc3QgY3VycmVudERvdHRlZE9yZGVyID0gY29udmVydFRvRG90dGVkT3JkZXJGb3JtYXQocnVuLnN0YXJ0X3RpbWUsIHJ1bi5pZCwgcnVuLmV4ZWN1dGlvbl9vcmRlcik7XG4gICAgICAgIGNvbnN0IHN0b3JlZFJ1biA9IHsgLi4ucnVuIH07XG4gICAgICAgIGlmIChzdG9yZWRSdW4ucGFyZW50X3J1bl9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRSdW4gPSB0aGlzLnJ1bk1hcC5nZXQoc3RvcmVkUnVuLnBhcmVudF9ydW5faWQpO1xuICAgICAgICAgICAgaWYgKHBhcmVudFJ1bikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZENoaWxkUnVuKHBhcmVudFJ1biwgc3RvcmVkUnVuKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyID0gTWF0aC5tYXgocGFyZW50UnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciwgc3RvcmVkUnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlcik7XG4gICAgICAgICAgICAgICAgc3RvcmVkUnVuLnRyYWNlX2lkID0gcGFyZW50UnVuLnRyYWNlX2lkO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRSdW4uZG90dGVkX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVkUnVuLmRvdHRlZF9vcmRlciA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJ1bi5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RG90dGVkT3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIF0uam9pbihcIi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gbmF0dXJhbGx5IGZvciBjYWxsYmFja3MgYWRkZWQgd2l0aGluIGEgcnVuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZGVidWcoYFBhcmVudCBydW4gd2l0aCBVVUlEICR7c3RvcmVkUnVuLnBhcmVudF9ydW5faWR9IGhhcyBubyBkb3R0ZWQgb3JkZXIuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIG5hdHVyYWxseSBmb3IgY2FsbGJhY2tzIGFkZGVkIHdpdGhpbiBhIHJ1blxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgICAgICAgLy8gICBgUGFyZW50IHJ1biB3aXRoIFVVSUQgJHtzdG9yZWRSdW4ucGFyZW50X3J1bl9pZH0gbm90IGZvdW5kLmBcbiAgICAgICAgICAgICAgICAvLyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RvcmVkUnVuLnRyYWNlX2lkID0gc3RvcmVkUnVuLmlkO1xuICAgICAgICAgICAgc3RvcmVkUnVuLmRvdHRlZF9vcmRlciA9IGN1cnJlbnREb3R0ZWRPcmRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJ1bk1hcC5zZXQoc3RvcmVkUnVuLmlkLCBzdG9yZWRSdW4pO1xuICAgICAgICByZXR1cm4gc3RvcmVkUnVuO1xuICAgIH1cbiAgICBhc3luYyBfZW5kVHJhY2UocnVuKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFJ1biA9IHJ1bi5wYXJlbnRfcnVuX2lkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ydW5NYXAuZ2V0KHJ1bi5wYXJlbnRfcnVuX2lkKTtcbiAgICAgICAgaWYgKHBhcmVudFJ1bikge1xuICAgICAgICAgICAgcGFyZW50UnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciA9IE1hdGgubWF4KHBhcmVudFJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIsIHJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0UnVuKHJ1bik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ydW5NYXAuZGVsZXRlKHJ1bi5pZCk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SdW5VcGRhdGU/LihydW4pO1xuICAgIH1cbiAgICBfZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50UnVuID0gcGFyZW50UnVuSWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJ1bk1hcC5nZXQocGFyZW50UnVuSWQpO1xuICAgICAgICAvLyBJZiBhIHJ1biBoYXMgbm8gcGFyZW50IHRoZW4gZXhlY3V0aW9uIG9yZGVyIGlzIDFcbiAgICAgICAgaWYgKCFwYXJlbnRSdW4pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBhZGQgYSBydW4gdG8gdGhlIHJ1biBtYXAgZm9yIExMTSBzdGFydCBldmVudHMuXG4gICAgICogVGhpcyBtdXN0IHNvbWV0aW1lcyBiZSBkb25lIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICogd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZCwgc28gd2UgZXhwb3NlIGl0IGFzIGEgc2VwYXJhdGUgbWV0aG9kIGhlcmUuXG4gICAgICovXG4gICAgX2NyZWF0ZVJ1bkZvckxMTVN0YXJ0KGxsbSwgcHJvbXB0cywgcnVuSWQsIHBhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgZmluYWxFeHRyYVBhcmFtcyA9IG1ldGFkYXRhXG4gICAgICAgICAgICA/IHsgLi4uZXh0cmFQYXJhbXMsIG1ldGFkYXRhIH1cbiAgICAgICAgICAgIDogZXh0cmFQYXJhbXM7XG4gICAgICAgIGNvbnN0IHJ1biA9IHtcbiAgICAgICAgICAgIGlkOiBydW5JZCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUgPz8gbGxtLmlkW2xsbS5pZC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudFJ1bklkLFxuICAgICAgICAgICAgc3RhcnRfdGltZSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IGxsbSxcbiAgICAgICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShzdGFydF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaW5wdXRzOiB7IHByb21wdHMgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBydW5fdHlwZTogXCJsbG1cIixcbiAgICAgICAgICAgIGV4dHJhOiBmaW5hbEV4dHJhUGFyYW1zID8/IHt9LFxuICAgICAgICAgICAgdGFnczogdGFncyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJ1blRvUnVuTWFwKHJ1bik7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTVN0YXJ0KGxsbSwgcHJvbXB0cywgcnVuSWQsIHBhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKSA/P1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUnVuRm9yTExNU3RhcnQobGxtLCBwcm9tcHRzLCBydW5JZCwgcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SdW5DcmVhdGU/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uTExNU3RhcnQ/LihydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIGFkZCBhIHJ1biB0byB0aGUgcnVuIG1hcCBmb3IgY2hhdCBtb2RlbCBzdGFydCBldmVudHMuXG4gICAgICogVGhpcyBtdXN0IHNvbWV0aW1lcyBiZSBkb25lIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICogd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZCwgc28gd2UgZXhwb3NlIGl0IGFzIGEgc2VwYXJhdGUgbWV0aG9kIGhlcmUuXG4gICAgICovXG4gICAgX2NyZWF0ZVJ1bkZvckNoYXRNb2RlbFN0YXJ0KGxsbSwgbWVzc2FnZXMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvbl9vcmRlciA9IHRoaXMuX2dldEV4ZWN1dGlvbk9yZGVyKHBhcmVudFJ1bklkKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGZpbmFsRXh0cmFQYXJhbXMgPSBtZXRhZGF0YVxuICAgICAgICAgICAgPyB7IC4uLmV4dHJhUGFyYW1zLCBtZXRhZGF0YSB9XG4gICAgICAgICAgICA6IGV4dHJhUGFyYW1zO1xuICAgICAgICBjb25zdCBydW4gPSB7XG4gICAgICAgICAgICBpZDogcnVuSWQsXG4gICAgICAgICAgICBuYW1lOiBuYW1lID8/IGxsbS5pZFtsbG0uaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiBsbG0sXG4gICAgICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoc3RhcnRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGlucHV0czogeyBtZXNzYWdlcyB9LFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIHJ1bl90eXBlOiBcImxsbVwiLFxuICAgICAgICAgICAgZXh0cmE6IGZpbmFsRXh0cmFQYXJhbXMgPz8ge30sXG4gICAgICAgICAgICB0YWdzOiB0YWdzIHx8IFtdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkUnVuVG9SdW5NYXAocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhdE1vZGVsU3RhcnQobGxtLCBtZXNzYWdlcywgcnVuSWQsIHBhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKSA/P1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUnVuRm9yQ2hhdE1vZGVsU3RhcnQobGxtLCBtZXNzYWdlcywgcnVuSWQsIHBhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGFncywgbWV0YWRhdGEsIG5hbWUpO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUnVuQ3JlYXRlPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkxMTVN0YXJ0Py4ocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNRW5kKG91dHB1dCwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJsbG1cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gTExNIHJ1biB0byBlbmQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5vdXRwdXRzID0gb3V0cHV0O1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlbmRcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25MTE1FbmQ/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVMTE1FcnJvcihlcnJvciwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJsbG1cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gTExNIHJ1biB0byBlbmQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5lcnJvciA9IHRoaXMuc3RyaW5naWZ5RXJyb3IoZXJyb3IpO1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkxMTUVycm9yPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5kVHJhY2UocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBhZGQgYSBydW4gdG8gdGhlIHJ1biBtYXAgZm9yIGNoYWluIHN0YXJ0IGV2ZW50cy5cbiAgICAgKiBUaGlzIG11c3Qgc29tZXRpbWVzIGJlIGRvbmUgc3luY2hyb25vdXNseSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICAgKiB3aGVuIGNhbGxiYWNrcyBhcmUgYmFja2dyb3VuZGVkLCBzbyB3ZSBleHBvc2UgaXQgYXMgYSBzZXBhcmF0ZSBtZXRob2QgaGVyZS5cbiAgICAgKi9cbiAgICBfY3JlYXRlUnVuRm9yQ2hhaW5TdGFydChjaGFpbiwgaW5wdXRzLCBydW5JZCwgcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBydW5UeXBlLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvbl9vcmRlciA9IHRoaXMuX2dldEV4ZWN1dGlvbk9yZGVyKHBhcmVudFJ1bklkKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHJ1biA9IHtcbiAgICAgICAgICAgIGlkOiBydW5JZCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUgPz8gY2hhaW4uaWRbY2hhaW4uaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiBjaGFpbixcbiAgICAgICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShzdGFydF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaW5wdXRzLFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBydW5fdHlwZTogcnVuVHlwZSA/PyBcImNoYWluXCIsXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBbXSxcbiAgICAgICAgICAgIGV4dHJhOiBtZXRhZGF0YSA/IHsgbWV0YWRhdGEgfSA6IHt9LFxuICAgICAgICAgICAgdGFnczogdGFncyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJ1blRvUnVuTWFwKHJ1bik7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluU3RhcnQoY2hhaW4sIGlucHV0cywgcnVuSWQsIHBhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgcnVuVHlwZSwgbmFtZSkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpID8/XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVSdW5Gb3JDaGFpblN0YXJ0KGNoYWluLCBpbnB1dHMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIHJ1blR5cGUsIG5hbWUpO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUnVuQ3JlYXRlPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkNoYWluU3RhcnQ/LihydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpbkVuZChvdXRwdXRzLCBydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywga3dhcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaGFpbiBydW4gdG8gZW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4ub3V0cHV0cyA9IF9jb2VyY2VUb0RpY3Qob3V0cHV0cywgXCJvdXRwdXRcIik7XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGt3YXJncz8uaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1bi5pbnB1dHMgPSBfY29lcmNlVG9EaWN0KGt3YXJncy5pbnB1dHMsIFwiaW5wdXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5vbkNoYWluRW5kPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5kVHJhY2UocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhaW5FcnJvcihlcnJvciwgcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGt3YXJncykge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1bikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hhaW4gcnVuIHRvIGVuZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLmVycm9yID0gdGhpcy5zdHJpbmdpZnlFcnJvcihlcnJvcik7XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVycm9yXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa3dhcmdzPy5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVuLmlucHV0cyA9IF9jb2VyY2VUb0RpY3Qoa3dhcmdzLmlucHV0cywgXCJpbnB1dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLm9uQ2hhaW5FcnJvcj8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgYWRkIGEgcnVuIHRvIHRoZSBydW4gbWFwIGZvciB0b29sIHN0YXJ0IGV2ZW50cy5cbiAgICAgKiBUaGlzIG11c3Qgc29tZXRpbWVzIGJlIGRvbmUgc3luY2hyb25vdXNseSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICAgKiB3aGVuIGNhbGxiYWNrcyBhcmUgYmFja2dyb3VuZGVkLCBzbyB3ZSBleHBvc2UgaXQgYXMgYSBzZXBhcmF0ZSBtZXRob2QgaGVyZS5cbiAgICAgKi9cbiAgICBfY3JlYXRlUnVuRm9yVG9vbFN0YXJ0KHRvb2wsIGlucHV0LCBydW5JZCwgcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvbl9vcmRlciA9IHRoaXMuX2dldEV4ZWN1dGlvbk9yZGVyKHBhcmVudFJ1bklkKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHJ1biA9IHtcbiAgICAgICAgICAgIGlkOiBydW5JZCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUgPz8gdG9vbC5pZFt0b29sLmlkLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lLFxuICAgICAgICAgICAgc2VyaWFsaXplZDogdG9vbCxcbiAgICAgICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShzdGFydF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaW5wdXRzOiB7IGlucHV0IH0sXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIHJ1bl90eXBlOiBcInRvb2xcIixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgZXh0cmE6IG1ldGFkYXRhID8geyBtZXRhZGF0YSB9IDoge30sXG4gICAgICAgICAgICB0YWdzOiB0YWdzIHx8IFtdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkUnVuVG9SdW5NYXAocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVG9vbFN0YXJ0KHRvb2wsIGlucHV0LCBydW5JZCwgcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCkgPz9cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJ1bkZvclRvb2xTdGFydCh0b29sLCBpbnB1dCwgcnVuSWQsIHBhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SdW5DcmVhdGU/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uVG9vbFN0YXJ0Py4ocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyBoYW5kbGVUb29sRW5kKG91dHB1dCwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJ0b29sXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRvb2wgcnVuIHRvIGVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4ub3V0cHV0cyA9IHsgb3V0cHV0IH07XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblRvb2xFbmQ/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUb29sRXJyb3IoZXJyb3IsIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwidG9vbFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB0b29sIHJ1biB0byBlbmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLmVycm9yID0gdGhpcy5zdHJpbmdpZnlFcnJvcihlcnJvcik7XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVycm9yXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uVG9vbEVycm9yPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5kVHJhY2UocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQWdlbnRBY3Rpb24oYWN0aW9uLCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImNoYWluXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZ2VudFJ1biA9IHJ1bjtcbiAgICAgICAgYWdlbnRSdW4uYWN0aW9ucyA9IGFnZW50UnVuLmFjdGlvbnMgfHwgW107XG4gICAgICAgIGFnZW50UnVuLmFjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgICAgICBhZ2VudFJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImFnZW50X2FjdGlvblwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAga3dhcmdzOiB7IGFjdGlvbiB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkFnZW50QWN0aW9uPy4ocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQWdlbnRFbmQoYWN0aW9uLCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImNoYWluXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJhZ2VudF9lbmRcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGt3YXJnczogeyBhY3Rpb24gfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25BZ2VudEVuZD8uKHJ1bik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgYWRkIGEgcnVuIHRvIHRoZSBydW4gbWFwIGZvciByZXRyaWV2ZXIgc3RhcnQgZXZlbnRzLlxuICAgICAqIFRoaXMgbXVzdCBzb21ldGltZXMgYmUgZG9uZSBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAqIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQsIHNvIHdlIGV4cG9zZSBpdCBhcyBhIHNlcGFyYXRlIG1ldGhvZCBoZXJlLlxuICAgICAqL1xuICAgIF9jcmVhdGVSdW5Gb3JSZXRyaWV2ZXJTdGFydChyZXRyaWV2ZXIsIHF1ZXJ5LCBydW5JZCwgcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvbl9vcmRlciA9IHRoaXMuX2dldEV4ZWN1dGlvbk9yZGVyKHBhcmVudFJ1bklkKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHJ1biA9IHtcbiAgICAgICAgICAgIGlkOiBydW5JZCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUgPz8gcmV0cmlldmVyLmlkW3JldHJpZXZlci5pZC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudFJ1bklkLFxuICAgICAgICAgICAgc3RhcnRfdGltZSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IHJldHJpZXZlcixcbiAgICAgICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShzdGFydF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaW5wdXRzOiB7IHF1ZXJ5IH0sXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIHJ1bl90eXBlOiBcInJldHJpZXZlclwiLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBleHRyYTogbWV0YWRhdGEgPyB7IG1ldGFkYXRhIH0gOiB7fSxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3MgfHwgW10sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSdW5Ub1J1bk1hcChydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJTdGFydChyZXRyaWV2ZXIsIHF1ZXJ5LCBydW5JZCwgcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCkgPz9cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJ1bkZvclJldHJpZXZlclN0YXJ0KHJldHJpZXZlciwgcXVlcnksIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUnVuQ3JlYXRlPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJldHJpZXZlclN0YXJ0Py4ocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmV0cmlldmVyRW5kKGRvY3VtZW50cywgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJyZXRyaWV2ZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmV0cmlldmVyIHJ1biB0byBlbmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLm91dHB1dHMgPSB7IGRvY3VtZW50cyB9O1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlbmRcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SZXRyaWV2ZXJFbmQ/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJFcnJvcihlcnJvciwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJyZXRyaWV2ZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmV0cmlldmVyIHJ1biB0byBlbmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLmVycm9yID0gdGhpcy5zdHJpbmdpZnlFcnJvcihlcnJvcik7XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVycm9yXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUmV0cmlldmVyRXJyb3I/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUZXh0KHRleHQsIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwiY2hhaW5cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcInRleHRcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGt3YXJnczogeyB0ZXh0IH0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uVGV4dD8uKHJ1bik7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTU5ld1Rva2VuKHRva2VuLCBpZHgsIHJ1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJsbG1cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwicnVuSWRcIiBwcm92aWRlZCB0byBcImhhbmRsZUxMTU5ld1Rva2VuXCIgY2FsbGJhY2suYCk7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwibmV3X3Rva2VuXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBrd2FyZ3M6IHsgdG9rZW4sIGlkeCwgY2h1bms6IGZpZWxkcz8uY2h1bmsgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25MTE1OZXdUb2tlbj8uKHJ1biwgdG9rZW4sIHsgY2h1bms6IGZpZWxkcz8uY2h1bmsgfSk7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/base.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/console.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/console.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConsoleCallbackHandler: () => (/* binding */ ConsoleCallbackHandler)\n/* harmony export */ });\n/* harmony import */ var ansi_styles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ansi-styles */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/ansi-styles/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/base.js\");\n\n\nfunction wrap(style, text) {\n    return `${style.open}${text}${style.close}`;\n}\nfunction tryJsonStringify(obj, fallback) {\n    try {\n        return JSON.stringify(obj, null, 2);\n    }\n    catch (err) {\n        return fallback;\n    }\n}\nfunction formatKVMapItem(value) {\n    if (typeof value === \"string\") {\n        return value.trim();\n    }\n    if (value === null || value === undefined) {\n        return value;\n    }\n    return tryJsonStringify(value, value.toString());\n}\nfunction elapsed(run) {\n    if (!run.end_time)\n        return \"\";\n    const elapsed = run.end_time - run.start_time;\n    if (elapsed < 1000) {\n        return `${elapsed}ms`;\n    }\n    return `${(elapsed / 1000).toFixed(2)}s`;\n}\nconst { color } = ansi_styles__WEBPACK_IMPORTED_MODULE_0__;\n/**\n * A tracer that logs all events to the console. It extends from the\n * `BaseTracer` class and overrides its methods to provide custom logging\n * functionality.\n * @example\n * ```typescript\n *\n * const llm = new ChatAnthropic({\n *   temperature: 0,\n *   tags: [\"example\", \"callbacks\", \"constructor\"],\n *   callbacks: [new ConsoleCallbackHandler()],\n * });\n *\n * ```\n */\nclass ConsoleCallbackHandler extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseTracer {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"console_callback_handler\"\n        });\n    }\n    /**\n     * Method used to persist the run. In this case, it simply returns a\n     * resolved promise as there's no persistence logic.\n     * @param _run The run to persist.\n     * @returns A resolved promise.\n     */\n    persistRun(_run) {\n        return Promise.resolve();\n    }\n    // utility methods\n    /**\n     * Method used to get all the parent runs of a given run.\n     * @param run The run whose parents are to be retrieved.\n     * @returns An array of parent runs.\n     */\n    getParents(run) {\n        const parents = [];\n        let currentRun = run;\n        while (currentRun.parent_run_id) {\n            const parent = this.runMap.get(currentRun.parent_run_id);\n            if (parent) {\n                parents.push(parent);\n                currentRun = parent;\n            }\n            else {\n                break;\n            }\n        }\n        return parents;\n    }\n    /**\n     * Method used to get a string representation of the run's lineage, which\n     * is used in logging.\n     * @param run The run whose lineage is to be retrieved.\n     * @returns A string representation of the run's lineage.\n     */\n    getBreadcrumbs(run) {\n        const parents = this.getParents(run).reverse();\n        const string = [...parents, run]\n            .map((parent, i, arr) => {\n            const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;\n            return i === arr.length - 1 ? wrap(ansi_styles__WEBPACK_IMPORTED_MODULE_0__.bold, name) : name;\n        })\n            .join(\" > \");\n        return wrap(color.grey, string);\n    }\n    // logging methods\n    /**\n     * Method used to log the start of a chain run.\n     * @param run The chain run that has started.\n     * @returns void\n     */\n    onChainStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[chain/start]\")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(run.inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of a chain run.\n     * @param run The chain run that has ended.\n     * @returns void\n     */\n    onChainEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[chain/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Chain run with output: ${tryJsonStringify(run.outputs, \"[outputs]\")}`);\n    }\n    /**\n     * Method used to log any errors of a chain run.\n     * @param run The chain run that has errored.\n     * @returns void\n     */\n    onChainError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[chain/error]\")} [${crumbs}] [${elapsed(run)}] Chain run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of an LLM run.\n     * @param run The LLM run that has started.\n     * @returns void\n     */\n    onLLMStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        const inputs = \"prompts\" in run.inputs\n            ? { prompts: run.inputs.prompts.map((p) => p.trim()) }\n            : run.inputs;\n        console.log(`${wrap(color.green, \"[llm/start]\")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of an LLM run.\n     * @param run The LLM run that has ended.\n     * @returns void\n     */\n    onLLMEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[llm/end]\")} [${crumbs}] [${elapsed(run)}] Exiting LLM run with output: ${tryJsonStringify(run.outputs, \"[response]\")}`);\n    }\n    /**\n     * Method used to log any errors of an LLM run.\n     * @param run The LLM run that has errored.\n     * @returns void\n     */\n    onLLMError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[llm/error]\")} [${crumbs}] [${elapsed(run)}] LLM run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of a tool run.\n     * @param run The tool run that has started.\n     * @returns void\n     */\n    onToolStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[tool/start]\")} [${crumbs}] Entering Tool run with input: \"${formatKVMapItem(run.inputs.input)}\"`);\n    }\n    /**\n     * Method used to log the end of a tool run.\n     * @param run The tool run that has ended.\n     * @returns void\n     */\n    onToolEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[tool/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Tool run with output: \"${formatKVMapItem(run.outputs?.output)}\"`);\n    }\n    /**\n     * Method used to log any errors of a tool run.\n     * @param run The tool run that has errored.\n     * @returns void\n     */\n    onToolError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[tool/error]\")} [${crumbs}] [${elapsed(run)}] Tool run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of a retriever run.\n     * @param run The retriever run that has started.\n     * @returns void\n     */\n    onRetrieverStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[retriever/start]\")} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(run.inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of a retriever run.\n     * @param run The retriever run that has ended.\n     * @returns void\n     */\n    onRetrieverEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[retriever/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Retriever run with output: ${tryJsonStringify(run.outputs, \"[outputs]\")}`);\n    }\n    /**\n     * Method used to log any errors of a retriever run.\n     * @param run The retriever run that has errored.\n     * @returns void\n     */\n    onRetrieverError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[retriever/error]\")} [${crumbs}] [${elapsed(run)}] Retriever run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the action selected by the agent.\n     * @param run The run in which the agent action occurred.\n     * @returns void\n     */\n    onAgentAction(run) {\n        const agentRun = run;\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.blue, \"[agent/action]\")} [${crumbs}] Agent selected action: ${tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], \"[action]\")}`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3RyYWNlcnMvY29uc29sZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUM7QUFDTTtBQUN2QztBQUNBLGNBQWMsV0FBVyxFQUFFLEtBQUssRUFBRSxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0EsUUFBUSxRQUFRLEVBQUUsd0NBQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDTyxxQ0FBcUMsZ0RBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUIsR0FBRyxnQkFBZ0IsR0FBRyxZQUFZO0FBQ3JGLCtDQUErQyw2Q0FBVztBQUMxRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQ0FBb0MsR0FBRyxPQUFPLG1DQUFtQyx5Q0FBeUM7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQ0FBaUMsR0FBRyxPQUFPLEtBQUssYUFBYSxtQ0FBbUMsMkNBQTJDO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0NBQWtDLEdBQUcsT0FBTyxLQUFLLGFBQWEsa0NBQWtDLHVDQUF1QztBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSx1QkFBdUIsa0NBQWtDLEdBQUcsT0FBTyxpQ0FBaUMscUNBQXFDO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCLEdBQUcsT0FBTyxLQUFLLGFBQWEsaUNBQWlDLDRDQUE0QztBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQyxHQUFHLE9BQU8sS0FBSyxhQUFhLGdDQUFnQyx1Q0FBdUM7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQ0FBbUMsR0FBRyxPQUFPLG1DQUFtQyxrQ0FBa0M7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0MsR0FBRyxPQUFPLEtBQUssYUFBYSxtQ0FBbUMscUNBQXFDO0FBQzNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDLEdBQUcsT0FBTyxLQUFLLGFBQWEsaUNBQWlDLHVDQUF1QztBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdDQUF3QyxHQUFHLE9BQU8sdUNBQXVDLHlDQUF5QztBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFDQUFxQyxHQUFHLE9BQU8sS0FBSyxhQUFhLHVDQUF1QywyQ0FBMkM7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQ0FBc0MsR0FBRyxPQUFPLEtBQUssYUFBYSxzQ0FBc0MsdUNBQXVDO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQ0FBb0MsR0FBRyxPQUFPLDJCQUEyQiw0RUFBNEU7QUFDNUs7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXHRleHRzcGxpdHRlcnNcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdHJhY2Vyc1xcY29uc29sZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3R5bGVzIGZyb20gXCJhbnNpLXN0eWxlc1wiO1xuaW1wb3J0IHsgQmFzZVRyYWNlciB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbmZ1bmN0aW9uIHdyYXAoc3R5bGUsIHRleHQpIHtcbiAgICByZXR1cm4gYCR7c3R5bGUub3Blbn0ke3RleHR9JHtzdHlsZS5jbG9zZX1gO1xufVxuZnVuY3Rpb24gdHJ5SnNvblN0cmluZ2lmeShvYmosIGZhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdEtWTWFwSXRlbSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ5SnNvblN0cmluZ2lmeSh2YWx1ZSwgdmFsdWUudG9TdHJpbmcoKSk7XG59XG5mdW5jdGlvbiBlbGFwc2VkKHJ1bikge1xuICAgIGlmICghcnVuLmVuZF90aW1lKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICBjb25zdCBlbGFwc2VkID0gcnVuLmVuZF90aW1lIC0gcnVuLnN0YXJ0X3RpbWU7XG4gICAgaWYgKGVsYXBzZWQgPCAxMDAwKSB7XG4gICAgICAgIHJldHVybiBgJHtlbGFwc2VkfW1zYDtcbiAgICB9XG4gICAgcmV0dXJuIGAkeyhlbGFwc2VkIC8gMTAwMCkudG9GaXhlZCgyKX1zYDtcbn1cbmNvbnN0IHsgY29sb3IgfSA9IHN0eWxlcztcbi8qKlxuICogQSB0cmFjZXIgdGhhdCBsb2dzIGFsbCBldmVudHMgdG8gdGhlIGNvbnNvbGUuIEl0IGV4dGVuZHMgZnJvbSB0aGVcbiAqIGBCYXNlVHJhY2VyYCBjbGFzcyBhbmQgb3ZlcnJpZGVzIGl0cyBtZXRob2RzIHRvIHByb3ZpZGUgY3VzdG9tIGxvZ2dpbmdcbiAqIGZ1bmN0aW9uYWxpdHkuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICpcbiAqIGNvbnN0IGxsbSA9IG5ldyBDaGF0QW50aHJvcGljKHtcbiAqICAgdGVtcGVyYXR1cmU6IDAsXG4gKiAgIHRhZ3M6IFtcImV4YW1wbGVcIiwgXCJjYWxsYmFja3NcIiwgXCJjb25zdHJ1Y3RvclwiXSxcbiAqICAgY2FsbGJhY2tzOiBbbmV3IENvbnNvbGVDYWxsYmFja0hhbmRsZXIoKV0sXG4gKiB9KTtcbiAqXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIENvbnNvbGVDYWxsYmFja0hhbmRsZXIgZXh0ZW5kcyBCYXNlVHJhY2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJjb25zb2xlX2NhbGxiYWNrX2hhbmRsZXJcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcGVyc2lzdCB0aGUgcnVuLiBJbiB0aGlzIGNhc2UsIGl0IHNpbXBseSByZXR1cm5zIGFcbiAgICAgKiByZXNvbHZlZCBwcm9taXNlIGFzIHRoZXJlJ3Mgbm8gcGVyc2lzdGVuY2UgbG9naWMuXG4gICAgICogQHBhcmFtIF9ydW4gVGhlIHJ1biB0byBwZXJzaXN0LlxuICAgICAqIEByZXR1cm5zIEEgcmVzb2x2ZWQgcHJvbWlzZS5cbiAgICAgKi9cbiAgICBwZXJzaXN0UnVuKF9ydW4pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICAvLyB1dGlsaXR5IG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBnZXQgYWxsIHRoZSBwYXJlbnQgcnVucyBvZiBhIGdpdmVuIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBydW4gd2hvc2UgcGFyZW50cyBhcmUgdG8gYmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHBhcmVudCBydW5zLlxuICAgICAqL1xuICAgIGdldFBhcmVudHMocnVuKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRSdW4gPSBydW47XG4gICAgICAgIHdoaWxlIChjdXJyZW50UnVuLnBhcmVudF9ydW5faWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucnVuTWFwLmdldChjdXJyZW50UnVuLnBhcmVudF9ydW5faWQpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSdW4gPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gZ2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBydW4ncyBsaW5lYWdlLCB3aGljaFxuICAgICAqIGlzIHVzZWQgaW4gbG9nZ2luZy5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBydW4gd2hvc2UgbGluZWFnZSBpcyB0byBiZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJ1bidzIGxpbmVhZ2UuXG4gICAgICovXG4gICAgZ2V0QnJlYWRjcnVtYnMocnVuKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSB0aGlzLmdldFBhcmVudHMocnVuKS5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IHN0cmluZyA9IFsuLi5wYXJlbnRzLCBydW5dXG4gICAgICAgICAgICAubWFwKChwYXJlbnQsIGksIGFycikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGAke3BhcmVudC5leGVjdXRpb25fb3JkZXJ9OiR7cGFyZW50LnJ1bl90eXBlfToke3BhcmVudC5uYW1lfWA7XG4gICAgICAgICAgICByZXR1cm4gaSA9PT0gYXJyLmxlbmd0aCAtIDEgPyB3cmFwKHN0eWxlcy5ib2xkLCBuYW1lKSA6IG5hbWU7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbihcIiA+IFwiKTtcbiAgICAgICAgcmV0dXJuIHdyYXAoY29sb3IuZ3JleSwgc3RyaW5nKTtcbiAgICB9XG4gICAgLy8gbG9nZ2luZyBtZXRob2RzXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBzdGFydCBvZiBhIGNoYWluIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBjaGFpbiBydW4gdGhhdCBoYXMgc3RhcnRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25DaGFpblN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuZ3JlZW4sIFwiW2NoYWluL3N0YXJ0XVwiKX0gWyR7Y3J1bWJzfV0gRW50ZXJpbmcgQ2hhaW4gcnVuIHdpdGggaW5wdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uaW5wdXRzLCBcIltpbnB1dHNdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIGVuZCBvZiBhIGNoYWluIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBjaGFpbiBydW4gdGhhdCBoYXMgZW5kZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uQ2hhaW5FbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5jeWFuLCBcIltjaGFpbi9lbmRdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBFeGl0aW5nIENoYWluIHJ1biB3aXRoIG91dHB1dDogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5vdXRwdXRzLCBcIltvdXRwdXRzXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIGFueSBlcnJvcnMgb2YgYSBjaGFpbiBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgY2hhaW4gcnVuIHRoYXQgaGFzIGVycm9yZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uQ2hhaW5FcnJvcihydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLnJlZCwgXCJbY2hhaW4vZXJyb3JdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBDaGFpbiBydW4gZXJyb3JlZCB3aXRoIGVycm9yOiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmVycm9yLCBcIltlcnJvcl1cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgc3RhcnQgb2YgYW4gTExNIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBMTE0gcnVuIHRoYXQgaGFzIHN0YXJ0ZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uTExNU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gXCJwcm9tcHRzXCIgaW4gcnVuLmlucHV0c1xuICAgICAgICAgICAgPyB7IHByb21wdHM6IHJ1bi5pbnB1dHMucHJvbXB0cy5tYXAoKHApID0+IHAudHJpbSgpKSB9XG4gICAgICAgICAgICA6IHJ1bi5pbnB1dHM7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuZ3JlZW4sIFwiW2xsbS9zdGFydF1cIil9IFske2NydW1ic31dIEVudGVyaW5nIExMTSBydW4gd2l0aCBpbnB1dDogJHt0cnlKc29uU3RyaW5naWZ5KGlucHV0cywgXCJbaW5wdXRzXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBlbmQgb2YgYW4gTExNIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBMTE0gcnVuIHRoYXQgaGFzIGVuZGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkxMTUVuZChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmN5YW4sIFwiW2xsbS9lbmRdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBFeGl0aW5nIExMTSBydW4gd2l0aCBvdXRwdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4ub3V0cHV0cywgXCJbcmVzcG9uc2VdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgYW55IGVycm9ycyBvZiBhbiBMTE0gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIExMTSBydW4gdGhhdCBoYXMgZXJyb3JlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25MTE1FcnJvcihydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLnJlZCwgXCJbbGxtL2Vycm9yXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gTExNIHJ1biBlcnJvcmVkIHdpdGggZXJyb3I6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uZXJyb3IsIFwiW2Vycm9yXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBzdGFydCBvZiBhIHRvb2wgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHRvb2wgcnVuIHRoYXQgaGFzIHN0YXJ0ZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uVG9vbFN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuZ3JlZW4sIFwiW3Rvb2wvc3RhcnRdXCIpfSBbJHtjcnVtYnN9XSBFbnRlcmluZyBUb29sIHJ1biB3aXRoIGlucHV0OiBcIiR7Zm9ybWF0S1ZNYXBJdGVtKHJ1bi5pbnB1dHMuaW5wdXQpfVwiYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgZW5kIG9mIGEgdG9vbCBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgdG9vbCBydW4gdGhhdCBoYXMgZW5kZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uVG9vbEVuZChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmN5YW4sIFwiW3Rvb2wvZW5kXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gRXhpdGluZyBUb29sIHJ1biB3aXRoIG91dHB1dDogXCIke2Zvcm1hdEtWTWFwSXRlbShydW4ub3V0cHV0cz8ub3V0cHV0KX1cImApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgYW55IGVycm9ycyBvZiBhIHRvb2wgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHRvb2wgcnVuIHRoYXQgaGFzIGVycm9yZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uVG9vbEVycm9yKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IucmVkLCBcIlt0b29sL2Vycm9yXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gVG9vbCBydW4gZXJyb3JlZCB3aXRoIGVycm9yOiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmVycm9yLCBcIltlcnJvcl1cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgc3RhcnQgb2YgYSByZXRyaWV2ZXIgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJldHJpZXZlciBydW4gdGhhdCBoYXMgc3RhcnRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25SZXRyaWV2ZXJTdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmdyZWVuLCBcIltyZXRyaWV2ZXIvc3RhcnRdXCIpfSBbJHtjcnVtYnN9XSBFbnRlcmluZyBSZXRyaWV2ZXIgcnVuIHdpdGggaW5wdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uaW5wdXRzLCBcIltpbnB1dHNdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIGVuZCBvZiBhIHJldHJpZXZlciBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcmV0cmlldmVyIHJ1biB0aGF0IGhhcyBlbmRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25SZXRyaWV2ZXJFbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5jeWFuLCBcIltyZXRyaWV2ZXIvZW5kXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gRXhpdGluZyBSZXRyaWV2ZXIgcnVuIHdpdGggb3V0cHV0OiAke3RyeUpzb25TdHJpbmdpZnkocnVuLm91dHB1dHMsIFwiW291dHB1dHNdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgYW55IGVycm9ycyBvZiBhIHJldHJpZXZlciBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcmV0cmlldmVyIHJ1biB0aGF0IGhhcyBlcnJvcmVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblJldHJpZXZlckVycm9yKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IucmVkLCBcIltyZXRyaWV2ZXIvZXJyb3JdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBSZXRyaWV2ZXIgcnVuIGVycm9yZWQgd2l0aCBlcnJvcjogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5lcnJvciwgXCJbZXJyb3JdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIGFjdGlvbiBzZWxlY3RlZCBieSB0aGUgYWdlbnQuXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcnVuIGluIHdoaWNoIHRoZSBhZ2VudCBhY3Rpb24gb2NjdXJyZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uQWdlbnRBY3Rpb24ocnVuKSB7XG4gICAgICAgIGNvbnN0IGFnZW50UnVuID0gcnVuO1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuYmx1ZSwgXCJbYWdlbnQvYWN0aW9uXVwiKX0gWyR7Y3J1bWJzfV0gQWdlbnQgc2VsZWN0ZWQgYWN0aW9uOiAke3RyeUpzb25TdHJpbmdpZnkoYWdlbnRSdW4uYWN0aW9uc1thZ2VudFJ1bi5hY3Rpb25zLmxlbmd0aCAtIDFdLCBcIlthY3Rpb25dXCIpfWApO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/console.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/event_stream.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/event_stream.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventStreamCallbackHandler: () => (/* binding */ EventStreamCallbackHandler),\n/* harmony export */   isStreamEventsHandler: () => (/* binding */ isStreamEventsHandler)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/base.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/stream.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/stream.js\");\n/* harmony import */ var _messages_ai_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../messages/ai.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/ai.js\");\n/* harmony import */ var _outputs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../outputs.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/outputs.js\");\n\n\n\n\nfunction assignName({ name, serialized, }) {\n    if (name !== undefined) {\n        return name;\n    }\n    if (serialized?.name !== undefined) {\n        return serialized.name;\n    }\n    else if (serialized?.id !== undefined && Array.isArray(serialized?.id)) {\n        return serialized.id[serialized.id.length - 1];\n    }\n    return \"Unnamed\";\n}\nconst isStreamEventsHandler = (handler) => handler.name === \"event_stream_tracer\";\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nclass EventStreamCallbackHandler extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseTracer {\n    constructor(fields) {\n        super({ _awaitHandler: true, ...fields });\n        Object.defineProperty(this, \"autoClose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"runInfoMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"tappedPromises\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"transformStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"writer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"receiveStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"event_stream_tracer\"\n        });\n        this.autoClose = fields?.autoClose ?? true;\n        this.includeNames = fields?.includeNames;\n        this.includeTypes = fields?.includeTypes;\n        this.includeTags = fields?.includeTags;\n        this.excludeNames = fields?.excludeNames;\n        this.excludeTypes = fields?.excludeTypes;\n        this.excludeTags = fields?.excludeTags;\n        this.transformStream = new TransformStream();\n        this.writer = this.transformStream.writable.getWriter();\n        this.receiveStream = _utils_stream_js__WEBPACK_IMPORTED_MODULE_1__.IterableReadableStream.fromReadableStream(this.transformStream.readable);\n    }\n    [Symbol.asyncIterator]() {\n        return this.receiveStream;\n    }\n    async persistRun(_run) {\n        // This is a legacy method only called once for an entire run tree\n        // and is therefore not useful here\n    }\n    _includeRun(run) {\n        const runTags = run.tags ?? [];\n        let include = this.includeNames === undefined &&\n            this.includeTags === undefined &&\n            this.includeTypes === undefined;\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(run.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(run.runType);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include ||\n                    runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(run.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(run.runType);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n    async *tapOutputIterable(runId, outputStream) {\n        const firstChunk = await outputStream.next();\n        if (firstChunk.done) {\n            return;\n        }\n        const runInfo = this.runInfoMap.get(runId);\n        // Run has finished, don't issue any stream events.\n        // An example of this is for runnables that use the default\n        // implementation of .stream(), which delegates to .invoke()\n        // and calls .onChainEnd() before passing it to the iterator.\n        if (runInfo === undefined) {\n            yield firstChunk.value;\n            return;\n        }\n        // Match format from handlers below\n        function _formatOutputChunk(eventType, data) {\n            if (eventType === \"llm\" && typeof data === \"string\") {\n                return new _outputs_js__WEBPACK_IMPORTED_MODULE_3__.GenerationChunk({ text: data });\n            }\n            return data;\n        }\n        let tappedPromise = this.tappedPromises.get(runId);\n        // if we are the first to tap, issue stream events\n        if (tappedPromise === undefined) {\n            let tappedPromiseResolver;\n            tappedPromise = new Promise((resolve) => {\n                tappedPromiseResolver = resolve;\n            });\n            this.tappedPromises.set(runId, tappedPromise);\n            try {\n                const event = {\n                    event: `on_${runInfo.runType}_stream`,\n                    run_id: runId,\n                    name: runInfo.name,\n                    tags: runInfo.tags,\n                    metadata: runInfo.metadata,\n                    data: {},\n                };\n                await this.send({\n                    ...event,\n                    data: {\n                        chunk: _formatOutputChunk(runInfo.runType, firstChunk.value),\n                    },\n                }, runInfo);\n                yield firstChunk.value;\n                for await (const chunk of outputStream) {\n                    // Don't yield tool and retriever stream events\n                    if (runInfo.runType !== \"tool\" && runInfo.runType !== \"retriever\") {\n                        await this.send({\n                            ...event,\n                            data: {\n                                chunk: _formatOutputChunk(runInfo.runType, chunk),\n                            },\n                        }, runInfo);\n                    }\n                    yield chunk;\n                }\n            }\n            finally {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tappedPromiseResolver();\n                // Don't delete from the promises map to keep track of which runs have been tapped.\n            }\n        }\n        else {\n            // otherwise just pass through\n            yield firstChunk.value;\n            for await (const chunk of outputStream) {\n                yield chunk;\n            }\n        }\n    }\n    async send(payload, run) {\n        if (this._includeRun(run)) {\n            await this.writer.write(payload);\n        }\n    }\n    async sendEndEvent(payload, run) {\n        const tappedPromise = this.tappedPromises.get(payload.run_id);\n        if (tappedPromise !== undefined) {\n            void tappedPromise.then(() => {\n                void this.send(payload, run);\n            });\n        }\n        else {\n            await this.send(payload, run);\n        }\n    }\n    async onLLMStart(run) {\n        const runName = assignName(run);\n        const runType = run.inputs.messages !== undefined ? \"chat_model\" : \"llm\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType,\n            inputs: run.inputs,\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        const eventName = `on_${runType}_start`;\n        await this.send({\n            event: eventName,\n            data: {\n                input: run.inputs,\n            },\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onLLMNewToken(run, token, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    kwargs) {\n        const runInfo = this.runInfoMap.get(run.id);\n        let chunk;\n        let eventName;\n        if (runInfo === undefined) {\n            throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);\n        }\n        // Top-level streaming events are covered by tapOutputIterable\n        if (this.runInfoMap.size === 1) {\n            return;\n        }\n        if (runInfo.runType === \"chat_model\") {\n            eventName = \"on_chat_model_stream\";\n            if (kwargs?.chunk === undefined) {\n                chunk = new _messages_ai_js__WEBPACK_IMPORTED_MODULE_2__.AIMessageChunk({ content: token, id: `run-${run.id}` });\n            }\n            else {\n                chunk = kwargs.chunk.message;\n            }\n        }\n        else if (runInfo.runType === \"llm\") {\n            eventName = \"on_llm_stream\";\n            if (kwargs?.chunk === undefined) {\n                chunk = new _outputs_js__WEBPACK_IMPORTED_MODULE_3__.GenerationChunk({ text: token });\n            }\n            else {\n                chunk = kwargs.chunk;\n            }\n        }\n        else {\n            throw new Error(`Unexpected run type ${runInfo.runType}`);\n        }\n        await this.send({\n            event: eventName,\n            data: {\n                chunk,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onLLMEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        let eventName;\n        if (runInfo === undefined) {\n            throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);\n        }\n        const generations = run.outputs?.generations;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let output;\n        if (runInfo.runType === \"chat_model\") {\n            for (const generation of generations ?? []) {\n                if (output !== undefined) {\n                    break;\n                }\n                output = generation[0]?.message;\n            }\n            eventName = \"on_chat_model_end\";\n        }\n        else if (runInfo.runType === \"llm\") {\n            output = {\n                generations: generations?.map((generation) => {\n                    return generation.map((chunk) => {\n                        return {\n                            text: chunk.text,\n                            generationInfo: chunk.generationInfo,\n                        };\n                    });\n                }),\n                llmOutput: run.outputs?.llmOutput ?? {},\n            };\n            eventName = \"on_llm_end\";\n        }\n        else {\n            throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);\n        }\n        await this.sendEndEvent({\n            event: eventName,\n            data: {\n                output,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onChainStart(run) {\n        const runName = assignName(run);\n        const runType = run.run_type ?? \"chain\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType: run.run_type,\n        };\n        let eventData = {};\n        // Workaround Runnable core code not sending input when transform streaming.\n        if (run.inputs.input === \"\" && Object.keys(run.inputs).length === 1) {\n            eventData = {};\n            runInfo.inputs = {};\n        }\n        else if (run.inputs.input !== undefined) {\n            eventData.input = run.inputs.input;\n            runInfo.inputs = run.inputs.input;\n        }\n        else {\n            eventData.input = run.inputs;\n            runInfo.inputs = run.inputs;\n        }\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: `on_${runType}_start`,\n            data: eventData,\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onChainEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);\n        }\n        const eventName = `on_${run.run_type}_end`;\n        const inputs = run.inputs ?? runInfo.inputs ?? {};\n        const outputs = run.outputs?.output ?? run.outputs;\n        const data = {\n            output: outputs,\n            input: inputs,\n        };\n        if (inputs.input && Object.keys(inputs).length === 1) {\n            data.input = inputs.input;\n            runInfo.inputs = inputs.input;\n        }\n        await this.sendEndEvent({\n            event: eventName,\n            data,\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata ?? {},\n        }, runInfo);\n    }\n    async onToolStart(run) {\n        const runName = assignName(run);\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType: \"tool\",\n            inputs: run.inputs ?? {},\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: \"on_tool_start\",\n            data: {\n                input: run.inputs ?? {},\n            },\n            name: runName,\n            run_id: run.id,\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onToolEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);\n        }\n        if (runInfo.inputs === undefined) {\n            throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);\n        }\n        const output = run.outputs?.output === undefined ? run.outputs : run.outputs.output;\n        await this.sendEndEvent({\n            event: \"on_tool_end\",\n            data: {\n                output,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onRetrieverStart(run) {\n        const runName = assignName(run);\n        const runType = \"retriever\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType,\n            inputs: {\n                query: run.inputs.query,\n            },\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: \"on_retriever_start\",\n            data: {\n                input: {\n                    query: run.inputs.query,\n                },\n            },\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onRetrieverEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);\n        }\n        await this.sendEndEvent({\n            event: \"on_retriever_end\",\n            data: {\n                output: run.outputs?.documents ?? run.outputs,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleCustomEvent(eventName, data, runId) {\n        const runInfo = this.runInfoMap.get(runId);\n        if (runInfo === undefined) {\n            throw new Error(`handleCustomEvent: Run ID ${runId} not found in run map.`);\n        }\n        await this.send({\n            event: \"on_custom_event\",\n            run_id: runId,\n            name: eventName,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n            data,\n        }, runInfo);\n    }\n    async finish() {\n        const pendingPromises = [...this.tappedPromises.values()];\n        void Promise.all(pendingPromises).finally(() => {\n            void this.writer.close();\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3RyYWNlcnMvZXZlbnRfc3RyZWFtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF1QztBQUNxQjtBQUNUO0FBQ0g7QUFDaEQsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5Q0FBeUMsZ0RBQVU7QUFDMUQ7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9FQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFlLEdBQUcsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFFBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyREFBYyxHQUFHLDJCQUEyQixPQUFPLEdBQUc7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3REFBZSxHQUFHLGFBQWE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdCQUFnQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXHRleHRzcGxpdHRlcnNcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdHJhY2Vyc1xcZXZlbnRfc3RyZWFtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VUcmFjZXIgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIH0gZnJvbSBcIi4uL3V0aWxzL3N0cmVhbS5qc1wiO1xuaW1wb3J0IHsgQUlNZXNzYWdlQ2h1bmsgfSBmcm9tIFwiLi4vbWVzc2FnZXMvYWkuanNcIjtcbmltcG9ydCB7IEdlbmVyYXRpb25DaHVuayB9IGZyb20gXCIuLi9vdXRwdXRzLmpzXCI7XG5mdW5jdGlvbiBhc3NpZ25OYW1lKHsgbmFtZSwgc2VyaWFsaXplZCwgfSkge1xuICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGlmIChzZXJpYWxpemVkPy5uYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQubmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VyaWFsaXplZD8uaWQgIT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KHNlcmlhbGl6ZWQ/LmlkKSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplZC5pZFtzZXJpYWxpemVkLmlkLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gXCJVbm5hbWVkXCI7XG59XG5leHBvcnQgY29uc3QgaXNTdHJlYW1FdmVudHNIYW5kbGVyID0gKGhhbmRsZXIpID0+IGhhbmRsZXIubmFtZSA9PT0gXCJldmVudF9zdHJlYW1fdHJhY2VyXCI7XG4vKipcbiAqIENsYXNzIHRoYXQgZXh0ZW5kcyB0aGUgYEJhc2VUcmFjZXJgIGNsYXNzIGZyb20gdGhlXG4gKiBgbGFuZ2NoYWluLmNhbGxiYWNrcy50cmFjZXJzLmJhc2VgIG1vZHVsZS4gSXQgcmVwcmVzZW50cyBhIGNhbGxiYWNrXG4gKiBoYW5kbGVyIHRoYXQgbG9ncyB0aGUgZXhlY3V0aW9uIG9mIHJ1bnMgYW5kIGVtaXRzIGBSdW5Mb2dgIGluc3RhbmNlcyB0byBhXG4gKiBgUnVuTG9nU3RyZWFtYC5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50U3RyZWFtQ2FsbGJhY2tIYW5kbGVyIGV4dGVuZHMgQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKHsgX2F3YWl0SGFuZGxlcjogdHJ1ZSwgLi4uZmllbGRzIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQ2xvc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVOYW1lc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlVHlwZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZU5hbWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVUeXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5JbmZvTWFwXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhcHBlZFByb21pc2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zZm9ybVN0cmVhbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3cml0ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVjZWl2ZVN0cmVhbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImV2ZW50X3N0cmVhbV90cmFjZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdXRvQ2xvc2UgPSBmaWVsZHM/LmF1dG9DbG9zZSA/PyB0cnVlO1xuICAgICAgICB0aGlzLmluY2x1ZGVOYW1lcyA9IGZpZWxkcz8uaW5jbHVkZU5hbWVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUeXBlcyA9IGZpZWxkcz8uaW5jbHVkZVR5cGVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID0gZmllbGRzPy5pbmNsdWRlVGFncztcbiAgICAgICAgdGhpcy5leGNsdWRlTmFtZXMgPSBmaWVsZHM/LmV4Y2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5leGNsdWRlVHlwZXMgPSBmaWVsZHM/LmV4Y2x1ZGVUeXBlcztcbiAgICAgICAgdGhpcy5leGNsdWRlVGFncyA9IGZpZWxkcz8uZXhjbHVkZVRhZ3M7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpO1xuICAgICAgICB0aGlzLndyaXRlciA9IHRoaXMudHJhbnNmb3JtU3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgICB0aGlzLnJlY2VpdmVTdHJlYW0gPSBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbSh0aGlzLnRyYW5zZm9ybVN0cmVhbS5yZWFkYWJsZSk7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVTdHJlYW07XG4gICAgfVxuICAgIGFzeW5jIHBlcnNpc3RSdW4oX3J1bikge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbGVnYWN5IG1ldGhvZCBvbmx5IGNhbGxlZCBvbmNlIGZvciBhbiBlbnRpcmUgcnVuIHRyZWVcbiAgICAgICAgLy8gYW5kIGlzIHRoZXJlZm9yZSBub3QgdXNlZnVsIGhlcmVcbiAgICB9XG4gICAgX2luY2x1ZGVSdW4ocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1blRhZ3MgPSBydW4udGFncyA/PyBbXTtcbiAgICAgICAgbGV0IGluY2x1ZGUgPSB0aGlzLmluY2x1ZGVOYW1lcyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVR5cGVzID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSB8fCB0aGlzLmluY2x1ZGVOYW1lcy5pbmNsdWRlcyhydW4ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZVR5cGVzLmluY2x1ZGVzKHJ1bi5ydW5UeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlIHx8XG4gICAgICAgICAgICAgICAgICAgIHJ1blRhZ3MuZmluZCgodGFnKSA9PiB0aGlzLmluY2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlTmFtZXMuaW5jbHVkZXMocnVuLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlVHlwZXMuaW5jbHVkZXMocnVuLnJ1blR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUYWdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgJiYgcnVuVGFncy5ldmVyeSgodGFnKSA9PiAhdGhpcy5leGNsdWRlVGFncz8uaW5jbHVkZXModGFnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgfVxuICAgIGFzeW5jICp0YXBPdXRwdXRJdGVyYWJsZShydW5JZCwgb3V0cHV0U3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2h1bmsgPSBhd2FpdCBvdXRwdXRTdHJlYW0ubmV4dCgpO1xuICAgICAgICBpZiAoZmlyc3RDaHVuay5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuSWQpO1xuICAgICAgICAvLyBSdW4gaGFzIGZpbmlzaGVkLCBkb24ndCBpc3N1ZSBhbnkgc3RyZWFtIGV2ZW50cy5cbiAgICAgICAgLy8gQW4gZXhhbXBsZSBvZiB0aGlzIGlzIGZvciBydW5uYWJsZXMgdGhhdCB1c2UgdGhlIGRlZmF1bHRcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gb2YgLnN0cmVhbSgpLCB3aGljaCBkZWxlZ2F0ZXMgdG8gLmludm9rZSgpXG4gICAgICAgIC8vIGFuZCBjYWxscyAub25DaGFpbkVuZCgpIGJlZm9yZSBwYXNzaW5nIGl0IHRvIHRoZSBpdGVyYXRvci5cbiAgICAgICAgaWYgKHJ1bkluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgeWllbGQgZmlyc3RDaHVuay52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXRjaCBmb3JtYXQgZnJvbSBoYW5kbGVycyBiZWxvd1xuICAgICAgICBmdW5jdGlvbiBfZm9ybWF0T3V0cHV0Q2h1bmsoZXZlbnRUeXBlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnRUeXBlID09PSBcImxsbVwiICYmIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmF0aW9uQ2h1bmsoeyB0ZXh0OiBkYXRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhcHBlZFByb21pc2UgPSB0aGlzLnRhcHBlZFByb21pc2VzLmdldChydW5JZCk7XG4gICAgICAgIC8vIGlmIHdlIGFyZSB0aGUgZmlyc3QgdG8gdGFwLCBpc3N1ZSBzdHJlYW0gZXZlbnRzXG4gICAgICAgIGlmICh0YXBwZWRQcm9taXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCB0YXBwZWRQcm9taXNlUmVzb2x2ZXI7XG4gICAgICAgICAgICB0YXBwZWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB0YXBwZWRQcm9taXNlUmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRhcHBlZFByb21pc2VzLnNldChydW5JZCwgdGFwcGVkUHJvbWlzZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogYG9uXyR7cnVuSW5mby5ydW5UeXBlfV9zdHJlYW1gLFxuICAgICAgICAgICAgICAgICAgICBydW5faWQ6IHJ1bklkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IHJ1bkluZm8udGFncyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bkluZm8ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBfZm9ybWF0T3V0cHV0Q2h1bmsocnVuSW5mby5ydW5UeXBlLCBmaXJzdENodW5rLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LCBydW5JbmZvKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBmaXJzdENodW5rLnZhbHVlO1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygb3V0cHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHlpZWxkIHRvb2wgYW5kIHJldHJpZXZlciBzdHJlYW0gZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChydW5JbmZvLnJ1blR5cGUgIT09IFwidG9vbFwiICYmIHJ1bkluZm8ucnVuVHlwZSAhPT0gXCJyZXRyaWV2ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBfZm9ybWF0T3V0cHV0Q2h1bmsocnVuSW5mby5ydW5UeXBlLCBjaHVuayksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJ1bkluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgdGFwcGVkUHJvbWlzZVJlc29sdmVyKCk7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgZGVsZXRlIGZyb20gdGhlIHByb21pc2VzIG1hcCB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIHJ1bnMgaGF2ZSBiZWVuIHRhcHBlZC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHBhc3MgdGhyb3VnaFxuICAgICAgICAgICAgeWllbGQgZmlyc3RDaHVuay52YWx1ZTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygb3V0cHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZChwYXlsb2FkLCBydW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2luY2x1ZGVSdW4ocnVuKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUocGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZEVuZEV2ZW50KHBheWxvYWQsIHJ1bikge1xuICAgICAgICBjb25zdCB0YXBwZWRQcm9taXNlID0gdGhpcy50YXBwZWRQcm9taXNlcy5nZXQocGF5bG9hZC5ydW5faWQpO1xuICAgICAgICBpZiAodGFwcGVkUHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2b2lkIHRhcHBlZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLnNlbmQocGF5bG9hZCwgcnVuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHBheWxvYWQsIHJ1bik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25MTE1TdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuTmFtZSA9IGFzc2lnbk5hbWUocnVuKTtcbiAgICAgICAgY29uc3QgcnVuVHlwZSA9IHJ1bi5pbnB1dHMubWVzc2FnZXMgIT09IHVuZGVmaW5lZCA/IFwiY2hhdF9tb2RlbFwiIDogXCJsbG1cIjtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHtcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgICAgICBuYW1lOiBydW5OYW1lLFxuICAgICAgICAgICAgcnVuVHlwZSxcbiAgICAgICAgICAgIGlucHV0czogcnVuLmlucHV0cyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLnNldChydW4uaWQsIHJ1bkluZm8pO1xuICAgICAgICBjb25zdCBldmVudE5hbWUgPSBgb25fJHtydW5UeXBlfV9zdGFydGA7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBldmVudDogZXZlbnROYW1lLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGlucHV0OiBydW4uaW5wdXRzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvbkxMTU5ld1Rva2VuKHJ1biwgdG9rZW4sIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAga3dhcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB0aGlzLnJ1bkluZm9NYXAuZ2V0KHJ1bi5pZCk7XG4gICAgICAgIGxldCBjaHVuaztcbiAgICAgICAgbGV0IGV2ZW50TmFtZTtcbiAgICAgICAgaWYgKHJ1bkluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvbkxMTU5ld1Rva2VuOiBSdW4gSUQgJHtydW4uaWR9IG5vdCBmb3VuZCBpbiBydW4gbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvcC1sZXZlbCBzdHJlYW1pbmcgZXZlbnRzIGFyZSBjb3ZlcmVkIGJ5IHRhcE91dHB1dEl0ZXJhYmxlXG4gICAgICAgIGlmICh0aGlzLnJ1bkluZm9NYXAuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5JbmZvLnJ1blR5cGUgPT09IFwiY2hhdF9tb2RlbFwiKSB7XG4gICAgICAgICAgICBldmVudE5hbWUgPSBcIm9uX2NoYXRfbW9kZWxfc3RyZWFtXCI7XG4gICAgICAgICAgICBpZiAoa3dhcmdzPy5jaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBuZXcgQUlNZXNzYWdlQ2h1bmsoeyBjb250ZW50OiB0b2tlbiwgaWQ6IGBydW4tJHtydW4uaWR9YCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rID0ga3dhcmdzLmNodW5rLm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVuSW5mby5ydW5UeXBlID09PSBcImxsbVwiKSB7XG4gICAgICAgICAgICBldmVudE5hbWUgPSBcIm9uX2xsbV9zdHJlYW1cIjtcbiAgICAgICAgICAgIGlmIChrd2FyZ3M/LmNodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyBHZW5lcmF0aW9uQ2h1bmsoeyB0ZXh0OiB0b2tlbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rID0ga3dhcmdzLmNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHJ1biB0eXBlICR7cnVuSW5mby5ydW5UeXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBldmVudDogZXZlbnROYW1lLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuSW5mby5uYW1lLFxuICAgICAgICAgICAgdGFnczogcnVuSW5mby50YWdzLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bkluZm8ubWV0YWRhdGEsXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvbkxMTUVuZChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuLmlkKTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICBsZXQgZXZlbnROYW1lO1xuICAgICAgICBpZiAocnVuSW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9uTExNRW5kOiBSdW4gSUQgJHtydW4uaWR9IG5vdCBmb3VuZCBpbiBydW4gbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25zID0gcnVuLm91dHB1dHM/LmdlbmVyYXRpb25zO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICBpZiAocnVuSW5mby5ydW5UeXBlID09PSBcImNoYXRfbW9kZWxcIikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBnZW5lcmF0aW9uIG9mIGdlbmVyYXRpb25zID8/IFtdKSB7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBnZW5lcmF0aW9uWzBdPy5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnROYW1lID0gXCJvbl9jaGF0X21vZGVsX2VuZFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bkluZm8ucnVuVHlwZSA9PT0gXCJsbG1cIikge1xuICAgICAgICAgICAgb3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBnZW5lcmF0aW9ucz8ubWFwKChnZW5lcmF0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0aW9uLm1hcCgoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2h1bmsudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uSW5mbzogY2h1bmsuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBsbG1PdXRwdXQ6IHJ1bi5vdXRwdXRzPy5sbG1PdXRwdXQgPz8ge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXZlbnROYW1lID0gXCJvbl9sbG1fZW5kXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9uTExNRW5kOiBVbmV4cGVjdGVkIHJ1biB0eXBlOiAke3J1bkluZm8ucnVuVHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFbmRFdmVudCh7XG4gICAgICAgICAgICBldmVudDogZXZlbnROYW1lLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dDogcnVuSW5mby5pbnB1dHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW5JbmZvLnRhZ3MsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuSW5mby5tZXRhZGF0YSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIG9uQ2hhaW5TdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuTmFtZSA9IGFzc2lnbk5hbWUocnVuKTtcbiAgICAgICAgY29uc3QgcnVuVHlwZSA9IHJ1bi5ydW5fdHlwZSA/PyBcImNoYWluXCI7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB7XG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW4uZXh0cmE/Lm1ldGFkYXRhID8/IHt9LFxuICAgICAgICAgICAgbmFtZTogcnVuTmFtZSxcbiAgICAgICAgICAgIHJ1blR5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGV2ZW50RGF0YSA9IHt9O1xuICAgICAgICAvLyBXb3JrYXJvdW5kIFJ1bm5hYmxlIGNvcmUgY29kZSBub3Qgc2VuZGluZyBpbnB1dCB3aGVuIHRyYW5zZm9ybSBzdHJlYW1pbmcuXG4gICAgICAgIGlmIChydW4uaW5wdXRzLmlucHV0ID09PSBcIlwiICYmIE9iamVjdC5rZXlzKHJ1bi5pbnB1dHMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZXZlbnREYXRhID0ge307XG4gICAgICAgICAgICBydW5JbmZvLmlucHV0cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bi5pbnB1dHMuaW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXZlbnREYXRhLmlucHV0ID0gcnVuLmlucHV0cy5pbnB1dDtcbiAgICAgICAgICAgIHJ1bkluZm8uaW5wdXRzID0gcnVuLmlucHV0cy5pbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50RGF0YS5pbnB1dCA9IHJ1bi5pbnB1dHM7XG4gICAgICAgICAgICBydW5JbmZvLmlucHV0cyA9IHJ1bi5pbnB1dHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLnNldChydW4uaWQsIHJ1bkluZm8pO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgZXZlbnQ6IGBvbl8ke3J1blR5cGV9X3N0YXJ0YCxcbiAgICAgICAgICAgIGRhdGE6IGV2ZW50RGF0YSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvbkNoYWluRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBydW5JbmZvID0gdGhpcy5ydW5JbmZvTWFwLmdldChydW4uaWQpO1xuICAgICAgICB0aGlzLnJ1bkluZm9NYXAuZGVsZXRlKHJ1bi5pZCk7XG4gICAgICAgIGlmIChydW5JbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25DaGFpbkVuZDogUnVuIElEICR7cnVuLmlkfSBub3QgZm91bmQgaW4gcnVuIG1hcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudE5hbWUgPSBgb25fJHtydW4ucnVuX3R5cGV9X2VuZGA7XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHJ1bi5pbnB1dHMgPz8gcnVuSW5mby5pbnB1dHMgPz8ge307XG4gICAgICAgIGNvbnN0IG91dHB1dHMgPSBydW4ub3V0cHV0cz8ub3V0cHV0ID8/IHJ1bi5vdXRwdXRzO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgb3V0cHV0OiBvdXRwdXRzLFxuICAgICAgICAgICAgaW5wdXQ6IGlucHV0cyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlucHV0cy5pbnB1dCAmJiBPYmplY3Qua2V5cyhpbnB1dHMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZGF0YS5pbnB1dCA9IGlucHV0cy5pbnB1dDtcbiAgICAgICAgICAgIHJ1bkluZm8uaW5wdXRzID0gaW5wdXRzLmlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVuZEV2ZW50KHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudE5hbWUsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW5JbmZvLnRhZ3MsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuSW5mby5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIG9uVG9vbFN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBydW5OYW1lID0gYXNzaWduTmFtZShydW4pO1xuICAgICAgICBjb25zdCBydW5JbmZvID0ge1xuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MgPz8gW10sXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuLmV4dHJhPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICBydW5UeXBlOiBcInRvb2xcIixcbiAgICAgICAgICAgIGlucHV0czogcnVuLmlucHV0cyA/PyB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLnNldChydW4uaWQsIHJ1bkluZm8pO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgZXZlbnQ6IFwib25fdG9vbF9zdGFydFwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGlucHV0OiBydW4uaW5wdXRzID8/IHt9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICBydW5faWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvblRvb2xFbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB0aGlzLnJ1bkluZm9NYXAuZ2V0KHJ1bi5pZCk7XG4gICAgICAgIHRoaXMucnVuSW5mb01hcC5kZWxldGUocnVuLmlkKTtcbiAgICAgICAgaWYgKHJ1bkluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvblRvb2xFbmQ6IFJ1biBJRCAke3J1bi5pZH0gbm90IGZvdW5kIGluIHJ1biBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bkluZm8uaW5wdXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25Ub29sRW5kOiBSdW4gSUQgJHtydW4uaWR9IGlzIGEgdG9vbCBjYWxsLCBhbmQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0cmFjZWQgaW5wdXRzLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHJ1bi5vdXRwdXRzPy5vdXRwdXQgPT09IHVuZGVmaW5lZCA/IHJ1bi5vdXRwdXRzIDogcnVuLm91dHB1dHMub3V0cHV0O1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFbmRFdmVudCh7XG4gICAgICAgICAgICBldmVudDogXCJvbl90b29sX2VuZFwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dDogcnVuSW5mby5pbnB1dHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW5JbmZvLnRhZ3MsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuSW5mby5tZXRhZGF0YSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIG9uUmV0cmlldmVyU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1bk5hbWUgPSBhc3NpZ25OYW1lKHJ1bik7XG4gICAgICAgIGNvbnN0IHJ1blR5cGUgPSBcInJldHJpZXZlclwiO1xuICAgICAgICBjb25zdCBydW5JbmZvID0ge1xuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MgPz8gW10sXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuLmV4dHJhPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICBydW5UeXBlLFxuICAgICAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IHJ1bi5pbnB1dHMucXVlcnksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkluZm9NYXAuc2V0KHJ1bi5pZCwgcnVuSW5mbyk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBldmVudDogXCJvbl9yZXRyaWV2ZXJfc3RhcnRcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeTogcnVuLmlucHV0cy5xdWVyeSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvblJldHJpZXZlckVuZChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuLmlkKTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICBpZiAocnVuSW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9uUmV0cmlldmVyRW5kOiBSdW4gSUQgJHtydW4uaWR9IG5vdCBmb3VuZCBpbiBydW4gbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVuZEV2ZW50KHtcbiAgICAgICAgICAgIGV2ZW50OiBcIm9uX3JldHJpZXZlcl9lbmRcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHJ1bi5vdXRwdXRzPy5kb2N1bWVudHMgPz8gcnVuLm91dHB1dHMsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHJ1bkluZm8uaW5wdXRzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuSW5mby5uYW1lLFxuICAgICAgICAgICAgdGFnczogcnVuSW5mby50YWdzLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bkluZm8ubWV0YWRhdGEsXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIGhhbmRsZUN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZGF0YSwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAocnVuSW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhbmRsZUN1c3RvbUV2ZW50OiBSdW4gSUQgJHtydW5JZH0gbm90IGZvdW5kIGluIHJ1biBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgIGV2ZW50OiBcIm9uX2N1c3RvbV9ldmVudFwiLFxuICAgICAgICAgICAgcnVuX2lkOiBydW5JZCxcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bkluZm8udGFncyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW5JbmZvLm1ldGFkYXRhLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIGZpbmlzaCgpIHtcbiAgICAgICAgY29uc3QgcGVuZGluZ1Byb21pc2VzID0gWy4uLnRoaXMudGFwcGVkUHJvbWlzZXMudmFsdWVzKCldO1xuICAgICAgICB2b2lkIFByb21pc2UuYWxsKHBlbmRpbmdQcm9taXNlcykuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICB2b2lkIHRoaXMud3JpdGVyLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/event_stream.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/log_stream.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/log_stream.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogStreamCallbackHandler: () => (/* binding */ LogStreamCallbackHandler),\n/* harmony export */   RunLog: () => (/* binding */ RunLog),\n/* harmony export */   RunLogPatch: () => (/* binding */ RunLogPatch),\n/* harmony export */   isLogStreamHandler: () => (/* binding */ isLogStreamHandler)\n/* harmony export */ });\n/* harmony import */ var _utils_fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/fast-json-patch/index.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/base.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/stream.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/stream.js\");\n/* harmony import */ var _messages_ai_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../messages/ai.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/messages/ai.js\");\n\n\n\n\n/**\n * List of jsonpatch JSONPatchOperations, which describe how to create the run state\n * from an empty dict. This is the minimal representation of the log, designed to\n * be serialized as JSON and sent over the wire to reconstruct the log on the other\n * side. Reconstruction of the state can be done with any jsonpatch-compliant library,\n * see https://jsonpatch.com for more information.\n */\nclass RunLogPatch {\n    constructor(fields) {\n        Object.defineProperty(this, \"ops\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.ops = fields.ops ?? [];\n    }\n    concat(other) {\n        const ops = this.ops.concat(other.ops);\n        const states = (0,_utils_fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__.applyPatch)({}, ops);\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunLog({\n            ops,\n            state: states[states.length - 1].newDocument,\n        });\n    }\n}\nclass RunLog extends RunLogPatch {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"state\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.state = fields.state;\n    }\n    concat(other) {\n        const ops = this.ops.concat(other.ops);\n        const states = (0,_utils_fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__.applyPatch)(this.state, other.ops);\n        return new RunLog({ ops, state: states[states.length - 1].newDocument });\n    }\n    static fromRunLogPatch(patch) {\n        const states = (0,_utils_fast_json_patch_index_js__WEBPACK_IMPORTED_MODULE_0__.applyPatch)({}, patch.ops);\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunLog({\n            ops: patch.ops,\n            state: states[states.length - 1].newDocument,\n        });\n    }\n}\nconst isLogStreamHandler = (handler) => handler.name === \"log_stream_tracer\";\n/**\n * Extract standardized inputs from a run.\n *\n * Standardizes the inputs based on the type of the runnable used.\n *\n * @param run - Run object\n * @param schemaFormat - The schema format to use.\n *\n * @returns Valid inputs are only dict. By conventions, inputs always represented\n * invocation using named arguments.\n * A null means that the input is not yet known!\n */\nasync function _getStandardizedInputs(run, schemaFormat) {\n    if (schemaFormat === \"original\") {\n        throw new Error(\"Do not assign inputs with original schema drop the key for now. \" +\n            \"When inputs are added to streamLog they should be added with \" +\n            \"standardized schema for streaming events.\");\n    }\n    const { inputs } = run;\n    if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n        return inputs;\n    }\n    if (Object.keys(inputs).length === 1 && inputs?.input === \"\") {\n        return undefined;\n    }\n    // new style chains\n    // These nest an additional 'input' key inside the 'inputs' to make sure\n    // the input is always a dict. We need to unpack and user the inner value.\n    // We should try to fix this in Runnables and callbacks/tracers\n    // Runnables should be using a null type here not a placeholder\n    // dict.\n    return inputs.input;\n}\nasync function _getStandardizedOutputs(run, schemaFormat) {\n    const { outputs } = run;\n    if (schemaFormat === \"original\") {\n        // Return the old schema, without standardizing anything\n        return outputs;\n    }\n    if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n        return outputs;\n    }\n    // TODO: Remove this hacky check\n    if (outputs !== undefined &&\n        Object.keys(outputs).length === 1 &&\n        outputs?.output !== undefined) {\n        return outputs.output;\n    }\n    return outputs;\n}\nfunction isChatGenerationChunk(x) {\n    return x !== undefined && x.message !== undefined;\n}\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nclass LogStreamCallbackHandler extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseTracer {\n    constructor(fields) {\n        super({ _awaitHandler: true, ...fields });\n        Object.defineProperty(this, \"autoClose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_schemaFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"original\"\n        });\n        Object.defineProperty(this, \"rootId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"keyMapByRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"counterMapByRunName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"transformStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"writer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"receiveStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"log_stream_tracer\"\n        });\n        this.autoClose = fields?.autoClose ?? true;\n        this.includeNames = fields?.includeNames;\n        this.includeTypes = fields?.includeTypes;\n        this.includeTags = fields?.includeTags;\n        this.excludeNames = fields?.excludeNames;\n        this.excludeTypes = fields?.excludeTypes;\n        this.excludeTags = fields?.excludeTags;\n        this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;\n        this.transformStream = new TransformStream();\n        this.writer = this.transformStream.writable.getWriter();\n        this.receiveStream = _utils_stream_js__WEBPACK_IMPORTED_MODULE_2__.IterableReadableStream.fromReadableStream(this.transformStream.readable);\n    }\n    [Symbol.asyncIterator]() {\n        return this.receiveStream;\n    }\n    async persistRun(_run) {\n        // This is a legacy method only called once for an entire run tree\n        // and is therefore not useful here\n    }\n    _includeRun(run) {\n        if (run.id === this.rootId) {\n            return false;\n        }\n        const runTags = run.tags ?? [];\n        let include = this.includeNames === undefined &&\n            this.includeTags === undefined &&\n            this.includeTypes === undefined;\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(run.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(run.run_type);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include ||\n                    runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(run.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(run.run_type);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n    async *tapOutputIterable(runId, output) {\n        // Tap an output async iterator to stream its values to the log.\n        for await (const chunk of output) {\n            // root run is handled in .streamLog()\n            if (runId !== this.rootId) {\n                // if we can't find the run silently ignore\n                // eg. because this run wasn't included in the log\n                const key = this.keyMapByRunId[runId];\n                if (key) {\n                    await this.writer.write(new RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: `/logs/${key}/streamed_output/-`,\n                                value: chunk,\n                            },\n                        ],\n                    }));\n                }\n            }\n            yield chunk;\n        }\n    }\n    async onRunCreate(run) {\n        if (this.rootId === undefined) {\n            this.rootId = run.id;\n            await this.writer.write(new RunLogPatch({\n                ops: [\n                    {\n                        op: \"replace\",\n                        path: \"\",\n                        value: {\n                            id: run.id,\n                            name: run.name,\n                            type: run.run_type,\n                            streamed_output: [],\n                            final_output: undefined,\n                            logs: {},\n                        },\n                    },\n                ],\n            }));\n        }\n        if (!this._includeRun(run)) {\n            return;\n        }\n        if (this.counterMapByRunName[run.name] === undefined) {\n            this.counterMapByRunName[run.name] = 0;\n        }\n        this.counterMapByRunName[run.name] += 1;\n        const count = this.counterMapByRunName[run.name];\n        this.keyMapByRunId[run.id] =\n            count === 1 ? run.name : `${run.name}:${count}`;\n        const logEntry = {\n            id: run.id,\n            name: run.name,\n            type: run.run_type,\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            start_time: new Date(run.start_time).toISOString(),\n            streamed_output: [],\n            streamed_output_str: [],\n            final_output: undefined,\n            end_time: undefined,\n        };\n        if (this._schemaFormat === \"streaming_events\") {\n            logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);\n        }\n        await this.writer.write(new RunLogPatch({\n            ops: [\n                {\n                    op: \"add\",\n                    path: `/logs/${this.keyMapByRunId[run.id]}`,\n                    value: logEntry,\n                },\n            ],\n        }));\n    }\n    async onRunUpdate(run) {\n        try {\n            const runName = this.keyMapByRunId[run.id];\n            if (runName === undefined) {\n                return;\n            }\n            const ops = [];\n            if (this._schemaFormat === \"streaming_events\") {\n                ops.push({\n                    op: \"replace\",\n                    path: `/logs/${runName}/inputs`,\n                    value: await _getStandardizedInputs(run, this._schemaFormat),\n                });\n            }\n            ops.push({\n                op: \"add\",\n                path: `/logs/${runName}/final_output`,\n                value: await _getStandardizedOutputs(run, this._schemaFormat),\n            });\n            if (run.end_time !== undefined) {\n                ops.push({\n                    op: \"add\",\n                    path: `/logs/${runName}/end_time`,\n                    value: new Date(run.end_time).toISOString(),\n                });\n            }\n            const patch = new RunLogPatch({ ops });\n            await this.writer.write(patch);\n        }\n        finally {\n            if (run.id === this.rootId) {\n                const patch = new RunLogPatch({\n                    ops: [\n                        {\n                            op: \"replace\",\n                            path: \"/final_output\",\n                            value: await _getStandardizedOutputs(run, this._schemaFormat),\n                        },\n                    ],\n                });\n                await this.writer.write(patch);\n                if (this.autoClose) {\n                    await this.writer.close();\n                }\n            }\n        }\n    }\n    async onLLMNewToken(run, token, kwargs) {\n        const runName = this.keyMapByRunId[run.id];\n        if (runName === undefined) {\n            return;\n        }\n        // TODO: Remove hack\n        const isChatModel = run.inputs.messages !== undefined;\n        let streamedOutputValue;\n        if (isChatModel) {\n            if (isChatGenerationChunk(kwargs?.chunk)) {\n                streamedOutputValue = kwargs?.chunk;\n            }\n            else {\n                streamedOutputValue = new _messages_ai_js__WEBPACK_IMPORTED_MODULE_3__.AIMessageChunk({\n                    id: `run-${run.id}`,\n                    content: token,\n                });\n            }\n        }\n        else {\n            streamedOutputValue = token;\n        }\n        const patch = new RunLogPatch({\n            ops: [\n                {\n                    op: \"add\",\n                    path: `/logs/${runName}/streamed_output_str/-`,\n                    value: token,\n                },\n                {\n                    op: \"add\",\n                    path: `/logs/${runName}/streamed_output/-`,\n                    value: streamedOutputValue,\n                },\n            ],\n        });\n        await this.writer.write(patch);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3RyYWNlcnMvbG9nX3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFnRTtBQUN6QjtBQUNxQjtBQUNUO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkVBQVUsR0FBRztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyRUFBVTtBQUNqQyw0QkFBNEIsbURBQW1EO0FBQy9FO0FBQ0E7QUFDQSx1QkFBdUIsMkVBQVUsR0FBRztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVDQUF1QyxnREFBVTtBQUN4RDtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0VBQXNCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLElBQUk7QUFDbkQ7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTLEdBQUcsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJCQUEyQjtBQUM5RDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJEQUFjO0FBQ3hELCtCQUErQixPQUFPO0FBQ3RDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFx0ZXh0c3BsaXR0ZXJzXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHRyYWNlcnNcXGxvZ19zdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXBwbHlQYXRjaCwgfSBmcm9tIFwiLi4vdXRpbHMvZmFzdC1qc29uLXBhdGNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBCYXNlVHJhY2VyIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSB9IGZyb20gXCIuLi91dGlscy9zdHJlYW0uanNcIjtcbmltcG9ydCB7IEFJTWVzc2FnZUNodW5rIH0gZnJvbSBcIi4uL21lc3NhZ2VzL2FpLmpzXCI7XG4vKipcbiAqIExpc3Qgb2YganNvbnBhdGNoIEpTT05QYXRjaE9wZXJhdGlvbnMsIHdoaWNoIGRlc2NyaWJlIGhvdyB0byBjcmVhdGUgdGhlIHJ1biBzdGF0ZVxuICogZnJvbSBhbiBlbXB0eSBkaWN0LiBUaGlzIGlzIHRoZSBtaW5pbWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsb2csIGRlc2lnbmVkIHRvXG4gKiBiZSBzZXJpYWxpemVkIGFzIEpTT04gYW5kIHNlbnQgb3ZlciB0aGUgd2lyZSB0byByZWNvbnN0cnVjdCB0aGUgbG9nIG9uIHRoZSBvdGhlclxuICogc2lkZS4gUmVjb25zdHJ1Y3Rpb24gb2YgdGhlIHN0YXRlIGNhbiBiZSBkb25lIHdpdGggYW55IGpzb25wYXRjaC1jb21wbGlhbnQgbGlicmFyeSxcbiAqIHNlZSBodHRwczovL2pzb25wYXRjaC5jb20gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5Mb2dQYXRjaCB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9wc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wcyA9IGZpZWxkcy5vcHMgPz8gW107XG4gICAgfVxuICAgIGNvbmNhdChvdGhlcikge1xuICAgICAgICBjb25zdCBvcHMgPSB0aGlzLm9wcy5jb25jYXQob3RoZXIub3BzKTtcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gYXBwbHlQYXRjaCh7fSwgb3BzKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bkxvZyh7XG4gICAgICAgICAgICBvcHMsXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGVzW3N0YXRlcy5sZW5ndGggLSAxXS5uZXdEb2N1bWVudCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJ1bkxvZyBleHRlbmRzIFJ1bkxvZ1BhdGNoIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGZpZWxkcy5zdGF0ZTtcbiAgICB9XG4gICAgY29uY2F0KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IG9wcyA9IHRoaXMub3BzLmNvbmNhdChvdGhlci5vcHMpO1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSBhcHBseVBhdGNoKHRoaXMuc3RhdGUsIG90aGVyLm9wcyk7XG4gICAgICAgIHJldHVybiBuZXcgUnVuTG9nKHsgb3BzLCBzdGF0ZTogc3RhdGVzW3N0YXRlcy5sZW5ndGggLSAxXS5uZXdEb2N1bWVudCB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21SdW5Mb2dQYXRjaChwYXRjaCkge1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSBhcHBseVBhdGNoKHt9LCBwYXRjaC5vcHMpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVuTG9nKHtcbiAgICAgICAgICAgIG9wczogcGF0Y2gub3BzLFxuICAgICAgICAgICAgc3RhdGU6IHN0YXRlc1tzdGF0ZXMubGVuZ3RoIC0gMV0ubmV3RG9jdW1lbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBpc0xvZ1N0cmVhbUhhbmRsZXIgPSAoaGFuZGxlcikgPT4gaGFuZGxlci5uYW1lID09PSBcImxvZ19zdHJlYW1fdHJhY2VyXCI7XG4vKipcbiAqIEV4dHJhY3Qgc3RhbmRhcmRpemVkIGlucHV0cyBmcm9tIGEgcnVuLlxuICpcbiAqIFN0YW5kYXJkaXplcyB0aGUgaW5wdXRzIGJhc2VkIG9uIHRoZSB0eXBlIG9mIHRoZSBydW5uYWJsZSB1c2VkLlxuICpcbiAqIEBwYXJhbSBydW4gLSBSdW4gb2JqZWN0XG4gKiBAcGFyYW0gc2NoZW1hRm9ybWF0IC0gVGhlIHNjaGVtYSBmb3JtYXQgdG8gdXNlLlxuICpcbiAqIEByZXR1cm5zIFZhbGlkIGlucHV0cyBhcmUgb25seSBkaWN0LiBCeSBjb252ZW50aW9ucywgaW5wdXRzIGFsd2F5cyByZXByZXNlbnRlZFxuICogaW52b2NhdGlvbiB1c2luZyBuYW1lZCBhcmd1bWVudHMuXG4gKiBBIG51bGwgbWVhbnMgdGhhdCB0aGUgaW5wdXQgaXMgbm90IHlldCBrbm93biFcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2dldFN0YW5kYXJkaXplZElucHV0cyhydW4sIHNjaGVtYUZvcm1hdCkge1xuICAgIGlmIChzY2hlbWFGb3JtYXQgPT09IFwib3JpZ2luYWxcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEbyBub3QgYXNzaWduIGlucHV0cyB3aXRoIG9yaWdpbmFsIHNjaGVtYSBkcm9wIHRoZSBrZXkgZm9yIG5vdy4gXCIgK1xuICAgICAgICAgICAgXCJXaGVuIGlucHV0cyBhcmUgYWRkZWQgdG8gc3RyZWFtTG9nIHRoZXkgc2hvdWxkIGJlIGFkZGVkIHdpdGggXCIgK1xuICAgICAgICAgICAgXCJzdGFuZGFyZGl6ZWQgc2NoZW1hIGZvciBzdHJlYW1pbmcgZXZlbnRzLlwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpbnB1dHMgfSA9IHJ1bjtcbiAgICBpZiAoW1wicmV0cmlldmVyXCIsIFwibGxtXCIsIFwicHJvbXB0XCJdLmluY2x1ZGVzKHJ1bi5ydW5fdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0cztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKGlucHV0cykubGVuZ3RoID09PSAxICYmIGlucHV0cz8uaW5wdXQgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gbmV3IHN0eWxlIGNoYWluc1xuICAgIC8vIFRoZXNlIG5lc3QgYW4gYWRkaXRpb25hbCAnaW5wdXQnIGtleSBpbnNpZGUgdGhlICdpbnB1dHMnIHRvIG1ha2Ugc3VyZVxuICAgIC8vIHRoZSBpbnB1dCBpcyBhbHdheXMgYSBkaWN0LiBXZSBuZWVkIHRvIHVucGFjayBhbmQgdXNlciB0aGUgaW5uZXIgdmFsdWUuXG4gICAgLy8gV2Ugc2hvdWxkIHRyeSB0byBmaXggdGhpcyBpbiBSdW5uYWJsZXMgYW5kIGNhbGxiYWNrcy90cmFjZXJzXG4gICAgLy8gUnVubmFibGVzIHNob3VsZCBiZSB1c2luZyBhIG51bGwgdHlwZSBoZXJlIG5vdCBhIHBsYWNlaG9sZGVyXG4gICAgLy8gZGljdC5cbiAgICByZXR1cm4gaW5wdXRzLmlucHV0O1xufVxuYXN5bmMgZnVuY3Rpb24gX2dldFN0YW5kYXJkaXplZE91dHB1dHMocnVuLCBzY2hlbWFGb3JtYXQpIHtcbiAgICBjb25zdCB7IG91dHB1dHMgfSA9IHJ1bjtcbiAgICBpZiAoc2NoZW1hRm9ybWF0ID09PSBcIm9yaWdpbmFsXCIpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBvbGQgc2NoZW1hLCB3aXRob3V0IHN0YW5kYXJkaXppbmcgYW55dGhpbmdcbiAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfVxuICAgIGlmIChbXCJyZXRyaWV2ZXJcIiwgXCJsbG1cIiwgXCJwcm9tcHRcIl0uaW5jbHVkZXMocnVuLnJ1bl90eXBlKSkge1xuICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICB9XG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgaGFja3kgY2hlY2tcbiAgICBpZiAob3V0cHV0cyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIE9iamVjdC5rZXlzKG91dHB1dHMpLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBvdXRwdXRzPy5vdXRwdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gb3V0cHV0cy5vdXRwdXQ7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXRzO1xufVxuZnVuY3Rpb24gaXNDaGF0R2VuZXJhdGlvbkNodW5rKHgpIHtcbiAgICByZXR1cm4geCAhPT0gdW5kZWZpbmVkICYmIHgubWVzc2FnZSAhPT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBDbGFzcyB0aGF0IGV4dGVuZHMgdGhlIGBCYXNlVHJhY2VyYCBjbGFzcyBmcm9tIHRoZVxuICogYGxhbmdjaGFpbi5jYWxsYmFja3MudHJhY2Vycy5iYXNlYCBtb2R1bGUuIEl0IHJlcHJlc2VudHMgYSBjYWxsYmFja1xuICogaGFuZGxlciB0aGF0IGxvZ3MgdGhlIGV4ZWN1dGlvbiBvZiBydW5zIGFuZCBlbWl0cyBgUnVuTG9nYCBpbnN0YW5jZXMgdG8gYVxuICogYFJ1bkxvZ1N0cmVhbWAuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIgZXh0ZW5kcyBCYXNlVHJhY2VyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoeyBfYXdhaXRIYW5kbGVyOiB0cnVlLCAuLi5maWVsZHMgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9DbG9zZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZU5hbWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVUeXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlTmFtZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZVR5cGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVUYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zY2hlbWFGb3JtYXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwib3JpZ2luYWxcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicm9vdElkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImtleU1hcEJ5UnVuSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb3VudGVyTWFwQnlSdW5OYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNmb3JtU3RyZWFtXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndyaXRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWNlaXZlU3RyZWFtXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwibG9nX3N0cmVhbV90cmFjZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdXRvQ2xvc2UgPSBmaWVsZHM/LmF1dG9DbG9zZSA/PyB0cnVlO1xuICAgICAgICB0aGlzLmluY2x1ZGVOYW1lcyA9IGZpZWxkcz8uaW5jbHVkZU5hbWVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUeXBlcyA9IGZpZWxkcz8uaW5jbHVkZVR5cGVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID0gZmllbGRzPy5pbmNsdWRlVGFncztcbiAgICAgICAgdGhpcy5leGNsdWRlTmFtZXMgPSBmaWVsZHM/LmV4Y2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5leGNsdWRlVHlwZXMgPSBmaWVsZHM/LmV4Y2x1ZGVUeXBlcztcbiAgICAgICAgdGhpcy5leGNsdWRlVGFncyA9IGZpZWxkcz8uZXhjbHVkZVRhZ3M7XG4gICAgICAgIHRoaXMuX3NjaGVtYUZvcm1hdCA9IGZpZWxkcz8uX3NjaGVtYUZvcm1hdCA/PyB0aGlzLl9zY2hlbWFGb3JtYXQ7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpO1xuICAgICAgICB0aGlzLndyaXRlciA9IHRoaXMudHJhbnNmb3JtU3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgICB0aGlzLnJlY2VpdmVTdHJlYW0gPSBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbSh0aGlzLnRyYW5zZm9ybVN0cmVhbS5yZWFkYWJsZSk7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVTdHJlYW07XG4gICAgfVxuICAgIGFzeW5jIHBlcnNpc3RSdW4oX3J1bikge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbGVnYWN5IG1ldGhvZCBvbmx5IGNhbGxlZCBvbmNlIGZvciBhbiBlbnRpcmUgcnVuIHRyZWVcbiAgICAgICAgLy8gYW5kIGlzIHRoZXJlZm9yZSBub3QgdXNlZnVsIGhlcmVcbiAgICB9XG4gICAgX2luY2x1ZGVSdW4ocnVuKSB7XG4gICAgICAgIGlmIChydW4uaWQgPT09IHRoaXMucm9vdElkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVuVGFncyA9IHJ1bi50YWdzID8/IFtdO1xuICAgICAgICBsZXQgaW5jbHVkZSA9IHRoaXMuaW5jbHVkZU5hbWVzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVRhZ3MgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5pbmNsdWRlVHlwZXMgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZU5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZU5hbWVzLmluY2x1ZGVzKHJ1bi5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgfHwgdGhpcy5pbmNsdWRlVHlwZXMuaW5jbHVkZXMocnVuLnJ1bl90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlIHx8XG4gICAgICAgICAgICAgICAgICAgIHJ1blRhZ3MuZmluZCgodGFnKSA9PiB0aGlzLmluY2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlTmFtZXMuaW5jbHVkZXMocnVuLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlVHlwZXMuaW5jbHVkZXMocnVuLnJ1bl90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlICYmIHJ1blRhZ3MuZXZlcnkoKHRhZykgPT4gIXRoaXMuZXhjbHVkZVRhZ3M/LmluY2x1ZGVzKHRhZykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgIH1cbiAgICBhc3luYyAqdGFwT3V0cHV0SXRlcmFibGUocnVuSWQsIG91dHB1dCkge1xuICAgICAgICAvLyBUYXAgYW4gb3V0cHV0IGFzeW5jIGl0ZXJhdG9yIHRvIHN0cmVhbSBpdHMgdmFsdWVzIHRvIHRoZSBsb2cuXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygb3V0cHV0KSB7XG4gICAgICAgICAgICAvLyByb290IHJ1biBpcyBoYW5kbGVkIGluIC5zdHJlYW1Mb2coKVxuICAgICAgICAgICAgaWYgKHJ1bklkICE9PSB0aGlzLnJvb3RJZCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGZpbmQgdGhlIHJ1biBzaWxlbnRseSBpZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBlZy4gYmVjYXVzZSB0aGlzIHJ1biB3YXNuJ3QgaW5jbHVkZWQgaW4gdGhlIGxvZ1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMua2V5TWFwQnlSdW5JZFtydW5JZF07XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7a2V5fS9zdHJlYW1lZF9vdXRwdXQvLWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG9uUnVuQ3JlYXRlKHJ1bikge1xuICAgICAgICBpZiAodGhpcy5yb290SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yb290SWQgPSBydW4uaWQ7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcnVuLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHJ1bi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1lZF9vdXRwdXQ6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsX291dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3M6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5jbHVkZVJ1bihydW4pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY291bnRlck1hcEJ5UnVuTmFtZVtydW4ubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudGVyTWFwQnlSdW5OYW1lW3J1bi5uYW1lXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb3VudGVyTWFwQnlSdW5OYW1lW3J1bi5uYW1lXSArPSAxO1xuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuY291bnRlck1hcEJ5UnVuTmFtZVtydW4ubmFtZV07XG4gICAgICAgIHRoaXMua2V5TWFwQnlSdW5JZFtydW4uaWRdID1cbiAgICAgICAgICAgIGNvdW50ID09PSAxID8gcnVuLm5hbWUgOiBgJHtydW4ubmFtZX06JHtjb3VudH1gO1xuICAgICAgICBjb25zdCBsb2dFbnRyeSA9IHtcbiAgICAgICAgICAgIGlkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW4ubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgICAgICBzdGFydF90aW1lOiBuZXcgRGF0ZShydW4uc3RhcnRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHN0cmVhbWVkX291dHB1dDogW10sXG4gICAgICAgICAgICBzdHJlYW1lZF9vdXRwdXRfc3RyOiBbXSxcbiAgICAgICAgICAgIGZpbmFsX291dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW5kX3RpbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX3NjaGVtYUZvcm1hdCA9PT0gXCJzdHJlYW1pbmdfZXZlbnRzXCIpIHtcbiAgICAgICAgICAgIGxvZ0VudHJ5LmlucHV0cyA9IGF3YWl0IF9nZXRTdGFuZGFyZGl6ZWRJbnB1dHMocnVuLCB0aGlzLl9zY2hlbWFGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKG5ldyBSdW5Mb2dQYXRjaCh7XG4gICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHt0aGlzLmtleU1hcEJ5UnVuSWRbcnVuLmlkXX1gLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbG9nRW50cnksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgb25SdW5VcGRhdGUocnVuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBydW5OYW1lID0gdGhpcy5rZXlNYXBCeVJ1bklkW3J1bi5pZF07XG4gICAgICAgICAgICBpZiAocnVuTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3BzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5fc2NoZW1hRm9ybWF0ID09PSBcInN0cmVhbWluZ19ldmVudHNcIikge1xuICAgICAgICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHtydW5OYW1lfS9pbnB1dHNgLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXdhaXQgX2dldFN0YW5kYXJkaXplZElucHV0cyhydW4sIHRoaXMuX3NjaGVtYUZvcm1hdCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7cnVuTmFtZX0vZmluYWxfb3V0cHV0YCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXdhaXQgX2dldFN0YW5kYXJkaXplZE91dHB1dHMocnVuLCB0aGlzLl9zY2hlbWFGb3JtYXQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocnVuLmVuZF90aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHtydW5OYW1lfS9lbmRfdGltZWAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRjaCA9IG5ldyBSdW5Mb2dQYXRjaCh7IG9wcyB9KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKHBhdGNoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChydW4uaWQgPT09IHRoaXMucm9vdElkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0Y2ggPSBuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogXCIvZmluYWxfb3V0cHV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF3YWl0IF9nZXRTdGFuZGFyZGl6ZWRPdXRwdXRzKHJ1biwgdGhpcy5fc2NoZW1hRm9ybWF0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUocGF0Y2gpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dG9DbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBvbkxMTU5ld1Rva2VuKHJ1biwgdG9rZW4sIGt3YXJncykge1xuICAgICAgICBjb25zdCBydW5OYW1lID0gdGhpcy5rZXlNYXBCeVJ1bklkW3J1bi5pZF07XG4gICAgICAgIGlmIChydW5OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgaGFja1xuICAgICAgICBjb25zdCBpc0NoYXRNb2RlbCA9IHJ1bi5pbnB1dHMubWVzc2FnZXMgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHN0cmVhbWVkT3V0cHV0VmFsdWU7XG4gICAgICAgIGlmIChpc0NoYXRNb2RlbCkge1xuICAgICAgICAgICAgaWYgKGlzQ2hhdEdlbmVyYXRpb25DaHVuayhrd2FyZ3M/LmNodW5rKSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbWVkT3V0cHV0VmFsdWUgPSBrd2FyZ3M/LmNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtZWRPdXRwdXRWYWx1ZSA9IG5ldyBBSU1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBgcnVuLSR7cnVuLmlkfWAsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtZWRPdXRwdXRWYWx1ZSA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGNoID0gbmV3IFJ1bkxvZ1BhdGNoKHtcbiAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3J1bk5hbWV9L3N0cmVhbWVkX291dHB1dF9zdHIvLWAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0b2tlbixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3J1bk5hbWV9L3N0cmVhbWVkX291dHB1dC8tYCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0cmVhbWVkT3V0cHV0VmFsdWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShwYXRjaCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/log_stream.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/root_listener.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/root_listener.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RootListenersTracer: () => (/* binding */ RootListenersTracer)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/base.js\");\n\nclass RootListenersTracer extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseTracer {\n    constructor({ config, onStart, onEnd, onError, }) {\n        super({ _awaitHandler: true });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"RootListenersTracer\"\n        });\n        /** The Run's ID. Type UUID */\n        Object.defineProperty(this, \"rootId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnStart\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnEnd\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnError\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.config = config;\n        this.argOnStart = onStart;\n        this.argOnEnd = onEnd;\n        this.argOnError = onError;\n    }\n    /**\n     * This is a legacy method only called once for an entire run tree\n     * therefore not useful here\n     * @param {Run} _ Not used\n     */\n    persistRun(_) {\n        return Promise.resolve();\n    }\n    async onRunCreate(run) {\n        if (this.rootId) {\n            return;\n        }\n        this.rootId = run.id;\n        if (this.argOnStart) {\n            if (this.argOnStart.length === 1) {\n                await this.argOnStart(run);\n            }\n            else if (this.argOnStart.length === 2) {\n                await this.argOnStart(run, this.config);\n            }\n        }\n    }\n    async onRunUpdate(run) {\n        if (run.id !== this.rootId) {\n            return;\n        }\n        if (!run.error) {\n            if (this.argOnEnd) {\n                if (this.argOnEnd.length === 1) {\n                    await this.argOnEnd(run);\n                }\n                else if (this.argOnEnd.length === 2) {\n                    await this.argOnEnd(run, this.config);\n                }\n            }\n        }\n        else if (this.argOnError) {\n            if (this.argOnError.length === 1) {\n                await this.argOnError(run);\n            }\n            else if (this.argOnError.length === 2) {\n                await this.argOnError(run, this.config);\n            }\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3RyYWNlcnMvcm9vdF9saXN0ZW5lci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1QztBQUNoQyxrQ0FBa0MsZ0RBQVU7QUFDbkQsa0JBQWtCLGtDQUFrQztBQUNwRCxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFx0ZXh0c3BsaXR0ZXJzXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHRyYWNlcnNcXHJvb3RfbGlzdGVuZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZVRyYWNlciB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbmV4cG9ydCBjbGFzcyBSb290TGlzdGVuZXJzVHJhY2VyIGV4dGVuZHMgQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoeyBjb25maWcsIG9uU3RhcnQsIG9uRW5kLCBvbkVycm9yLCB9KSB7XG4gICAgICAgIHN1cGVyKHsgX2F3YWl0SGFuZGxlcjogdHJ1ZSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJSb290TGlzdGVuZXJzVHJhY2VyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgUnVuJ3MgSUQuIFR5cGUgVVVJRCAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb290SWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZmlnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFyZ09uU3RhcnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJnT25FbmRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJnT25FcnJvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5hcmdPblN0YXJ0ID0gb25TdGFydDtcbiAgICAgICAgdGhpcy5hcmdPbkVuZCA9IG9uRW5kO1xuICAgICAgICB0aGlzLmFyZ09uRXJyb3IgPSBvbkVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgbGVnYWN5IG1ldGhvZCBvbmx5IGNhbGxlZCBvbmNlIGZvciBhbiBlbnRpcmUgcnVuIHRyZWVcbiAgICAgKiB0aGVyZWZvcmUgbm90IHVzZWZ1bCBoZXJlXG4gICAgICogQHBhcmFtIHtSdW59IF8gTm90IHVzZWRcbiAgICAgKi9cbiAgICBwZXJzaXN0UnVuKF8pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBhc3luYyBvblJ1bkNyZWF0ZShydW4pIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdElkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290SWQgPSBydW4uaWQ7XG4gICAgICAgIGlmICh0aGlzLmFyZ09uU3RhcnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFyZ09uU3RhcnQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcmdPblN0YXJ0KHJ1bik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFyZ09uU3RhcnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcmdPblN0YXJ0KHJ1biwgdGhpcy5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG9uUnVuVXBkYXRlKHJ1bikge1xuICAgICAgICBpZiAocnVuLmlkICE9PSB0aGlzLnJvb3RJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcnVuLmVycm9yKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcmdPbkVuZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFyZ09uRW5kLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFyZ09uRW5kKHJ1bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYXJnT25FbmQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXJnT25FbmQocnVuLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXJnT25FcnJvcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJnT25FcnJvci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFyZ09uRXJyb3IocnVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYXJnT25FcnJvci5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFyZ09uRXJyb3IocnVuLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/root_listener.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/tracer_langchain.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/tracer_langchain.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LangChainTracer: () => (/* binding */ LangChainTracer)\n/* harmony export */ });\n/* harmony import */ var langsmith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! langsmith */ \"(action-browser)/./node_modules/langsmith/index.js\");\n/* harmony import */ var langsmith_run_trees__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! langsmith/run_trees */ \"(action-browser)/./node_modules/langsmith/run_trees.js\");\n/* harmony import */ var langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! langsmith/singletons/traceable */ \"(action-browser)/./node_modules/langsmith/singletons/traceable.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/env.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/env.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/base.js\");\n\n\n\n\n\nclass LangChainTracer extends _base_js__WEBPACK_IMPORTED_MODULE_4__.BaseTracer {\n    constructor(fields = {}) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"langchain_tracer\"\n        });\n        Object.defineProperty(this, \"projectName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"exampleId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const { exampleId, projectName, client } = fields;\n        this.projectName =\n            projectName ??\n                (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_3__.getEnvironmentVariable)(\"LANGCHAIN_PROJECT\") ??\n                (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_3__.getEnvironmentVariable)(\"LANGCHAIN_SESSION\");\n        this.exampleId = exampleId;\n        this.client = client ?? new langsmith__WEBPACK_IMPORTED_MODULE_0__.Client({});\n        const traceableTree = LangChainTracer.getTraceableRunTree();\n        if (traceableTree) {\n            this.updateFromRunTree(traceableTree);\n        }\n    }\n    async _convertToCreate(run, example_id = undefined) {\n        return {\n            ...run,\n            extra: {\n                ...run.extra,\n                runtime: await (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_3__.getRuntimeEnvironment)(),\n            },\n            child_runs: undefined,\n            session_name: this.projectName,\n            reference_example_id: run.parent_run_id ? undefined : example_id,\n        };\n    }\n    async persistRun(_run) { }\n    async onRunCreate(run) {\n        const persistedRun = await this._convertToCreate(run, this.exampleId);\n        await this.client.createRun(persistedRun);\n    }\n    async onRunUpdate(run) {\n        const runUpdate = {\n            end_time: run.end_time,\n            error: run.error,\n            outputs: run.outputs,\n            events: run.events,\n            inputs: run.inputs,\n            trace_id: run.trace_id,\n            dotted_order: run.dotted_order,\n            parent_run_id: run.parent_run_id,\n        };\n        await this.client.updateRun(run.id, runUpdate);\n    }\n    getRun(id) {\n        return this.runMap.get(id);\n    }\n    updateFromRunTree(runTree) {\n        let rootRun = runTree;\n        const visited = new Set();\n        while (rootRun.parent_run) {\n            if (visited.has(rootRun.id))\n                break;\n            visited.add(rootRun.id);\n            if (!rootRun.parent_run)\n                break;\n            rootRun = rootRun.parent_run;\n        }\n        visited.clear();\n        const queue = [rootRun];\n        while (queue.length > 0) {\n            const current = queue.shift();\n            if (!current || visited.has(current.id))\n                continue;\n            visited.add(current.id);\n            // @ts-expect-error Types of property 'events' are incompatible.\n            this.runMap.set(current.id, current);\n            if (current.child_runs) {\n                queue.push(...current.child_runs);\n            }\n        }\n        this.client = runTree.client ?? this.client;\n        this.projectName = runTree.project_name ?? this.projectName;\n        this.exampleId = runTree.reference_example_id ?? this.exampleId;\n    }\n    convertToRunTree(id) {\n        const runTreeMap = {};\n        const runTreeList = [];\n        for (const [id, run] of this.runMap) {\n            // by converting the run map to a run tree, we are doing a copy\n            // thus, any mutation performed on the run tree will not be reflected\n            // back in the run map\n            // TODO: Stop using `this.runMap` in favour of LangSmith's `RunTree`\n            const runTree = new langsmith_run_trees__WEBPACK_IMPORTED_MODULE_1__.RunTree({\n                ...run,\n                child_runs: [],\n                parent_run: undefined,\n                // inherited properties\n                client: this.client,\n                project_name: this.projectName,\n                reference_example_id: this.exampleId,\n                tracingEnabled: true,\n            });\n            runTreeMap[id] = runTree;\n            runTreeList.push([id, run.dotted_order]);\n        }\n        runTreeList.sort((a, b) => {\n            if (!a[1] || !b[1])\n                return 0;\n            return a[1].localeCompare(b[1]);\n        });\n        for (const [id] of runTreeList) {\n            const run = this.runMap.get(id);\n            const runTree = runTreeMap[id];\n            if (!run || !runTree)\n                continue;\n            if (run.parent_run_id) {\n                const parentRunTree = runTreeMap[run.parent_run_id];\n                if (parentRunTree) {\n                    parentRunTree.child_runs.push(runTree);\n                    runTree.parent_run = parentRunTree;\n                }\n            }\n        }\n        return runTreeMap[id];\n    }\n    static getTraceableRunTree() {\n        try {\n            return (0,langsmith_singletons_traceable__WEBPACK_IMPORTED_MODULE_2__.getCurrentRunTree)();\n        }\n        catch {\n            return undefined;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3RyYWNlcnMvdHJhY2VyX2xhbmdjaGFpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBbUM7QUFDVztBQUNxQjtBQUNhO0FBQ3pDO0FBQ2hDLDhCQUE4QixnREFBVTtBQUMvQywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQixpQ0FBaUM7QUFDakQ7QUFDQTtBQUNBLGdCQUFnQixxRUFBc0I7QUFDdEMsZ0JBQWdCLHFFQUFzQjtBQUN0QztBQUNBLG9DQUFvQyw2Q0FBTSxHQUFHO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9FQUFxQjtBQUNwRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3REFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUZBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXHRleHRzcGxpdHRlcnNcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdHJhY2Vyc1xcdHJhY2VyX2xhbmdjaGFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDbGllbnQgfSBmcm9tIFwibGFuZ3NtaXRoXCI7XG5pbXBvcnQgeyBSdW5UcmVlIH0gZnJvbSBcImxhbmdzbWl0aC9ydW5fdHJlZXNcIjtcbmltcG9ydCB7IGdldEN1cnJlbnRSdW5UcmVlIH0gZnJvbSBcImxhbmdzbWl0aC9zaW5nbGV0b25zL3RyYWNlYWJsZVwiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSwgZ2V0UnVudGltZUVudmlyb25tZW50IH0gZnJvbSBcIi4uL3V0aWxzL2Vudi5qc1wiO1xuaW1wb3J0IHsgQmFzZVRyYWNlciB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbmV4cG9ydCBjbGFzcyBMYW5nQ2hhaW5UcmFjZXIgZXh0ZW5kcyBCYXNlVHJhY2VyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMgPSB7fSkge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImxhbmdjaGFpbl90cmFjZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvamVjdE5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhhbXBsZUlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNsaWVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGV4YW1wbGVJZCwgcHJvamVjdE5hbWUsIGNsaWVudCB9ID0gZmllbGRzO1xuICAgICAgICB0aGlzLnByb2plY3ROYW1lID1cbiAgICAgICAgICAgIHByb2plY3ROYW1lID8/XG4gICAgICAgICAgICAgICAgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9QUk9KRUNUXCIpID8/XG4gICAgICAgICAgICAgICAgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9TRVNTSU9OXCIpO1xuICAgICAgICB0aGlzLmV4YW1wbGVJZCA9IGV4YW1wbGVJZDtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQgPz8gbmV3IENsaWVudCh7fSk7XG4gICAgICAgIGNvbnN0IHRyYWNlYWJsZVRyZWUgPSBMYW5nQ2hhaW5UcmFjZXIuZ2V0VHJhY2VhYmxlUnVuVHJlZSgpO1xuICAgICAgICBpZiAodHJhY2VhYmxlVHJlZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9tUnVuVHJlZSh0cmFjZWFibGVUcmVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfY29udmVydFRvQ3JlYXRlKHJ1biwgZXhhbXBsZV9pZCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucnVuLFxuICAgICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgICAgICAuLi5ydW4uZXh0cmEsXG4gICAgICAgICAgICAgICAgcnVudGltZTogYXdhaXQgZ2V0UnVudGltZUVudmlyb25tZW50KCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRfcnVuczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2Vzc2lvbl9uYW1lOiB0aGlzLnByb2plY3ROYW1lLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHJ1bi5wYXJlbnRfcnVuX2lkID8gdW5kZWZpbmVkIDogZXhhbXBsZV9pZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgcGVyc2lzdFJ1bihfcnVuKSB7IH1cbiAgICBhc3luYyBvblJ1bkNyZWF0ZShydW4pIHtcbiAgICAgICAgY29uc3QgcGVyc2lzdGVkUnVuID0gYXdhaXQgdGhpcy5fY29udmVydFRvQ3JlYXRlKHJ1biwgdGhpcy5leGFtcGxlSWQpO1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5jcmVhdGVSdW4ocGVyc2lzdGVkUnVuKTtcbiAgICB9XG4gICAgYXN5bmMgb25SdW5VcGRhdGUocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1blVwZGF0ZSA9IHtcbiAgICAgICAgICAgIGVuZF90aW1lOiBydW4uZW5kX3RpbWUsXG4gICAgICAgICAgICBlcnJvcjogcnVuLmVycm9yLFxuICAgICAgICAgICAgb3V0cHV0czogcnVuLm91dHB1dHMsXG4gICAgICAgICAgICBldmVudHM6IHJ1bi5ldmVudHMsXG4gICAgICAgICAgICBpbnB1dHM6IHJ1bi5pbnB1dHMsXG4gICAgICAgICAgICB0cmFjZV9pZDogcnVuLnRyYWNlX2lkLFxuICAgICAgICAgICAgZG90dGVkX29yZGVyOiBydW4uZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcnVuLnBhcmVudF9ydW5faWQsXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnVwZGF0ZVJ1bihydW4uaWQsIHJ1blVwZGF0ZSk7XG4gICAgfVxuICAgIGdldFJ1bihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5NYXAuZ2V0KGlkKTtcbiAgICB9XG4gICAgdXBkYXRlRnJvbVJ1blRyZWUocnVuVHJlZSkge1xuICAgICAgICBsZXQgcm9vdFJ1biA9IHJ1blRyZWU7XG4gICAgICAgIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHdoaWxlIChyb290UnVuLnBhcmVudF9ydW4pIHtcbiAgICAgICAgICAgIGlmICh2aXNpdGVkLmhhcyhyb290UnVuLmlkKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHZpc2l0ZWQuYWRkKHJvb3RSdW4uaWQpO1xuICAgICAgICAgICAgaWYgKCFyb290UnVuLnBhcmVudF9ydW4pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICByb290UnVuID0gcm9vdFJ1bi5wYXJlbnRfcnVuO1xuICAgICAgICB9XG4gICAgICAgIHZpc2l0ZWQuY2xlYXIoKTtcbiAgICAgICAgY29uc3QgcXVldWUgPSBbcm9vdFJ1bl07XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICghY3VycmVudCB8fCB2aXNpdGVkLmhhcyhjdXJyZW50LmlkKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHZpc2l0ZWQuYWRkKGN1cnJlbnQuaWQpO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUeXBlcyBvZiBwcm9wZXJ0eSAnZXZlbnRzJyBhcmUgaW5jb21wYXRpYmxlLlxuICAgICAgICAgICAgdGhpcy5ydW5NYXAuc2V0KGN1cnJlbnQuaWQsIGN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuY2hpbGRfcnVucykge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goLi4uY3VycmVudC5jaGlsZF9ydW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsaWVudCA9IHJ1blRyZWUuY2xpZW50ID8/IHRoaXMuY2xpZW50O1xuICAgICAgICB0aGlzLnByb2plY3ROYW1lID0gcnVuVHJlZS5wcm9qZWN0X25hbWUgPz8gdGhpcy5wcm9qZWN0TmFtZTtcbiAgICAgICAgdGhpcy5leGFtcGxlSWQgPSBydW5UcmVlLnJlZmVyZW5jZV9leGFtcGxlX2lkID8/IHRoaXMuZXhhbXBsZUlkO1xuICAgIH1cbiAgICBjb252ZXJ0VG9SdW5UcmVlKGlkKSB7XG4gICAgICAgIGNvbnN0IHJ1blRyZWVNYXAgPSB7fTtcbiAgICAgICAgY29uc3QgcnVuVHJlZUxpc3QgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbaWQsIHJ1bl0gb2YgdGhpcy5ydW5NYXApIHtcbiAgICAgICAgICAgIC8vIGJ5IGNvbnZlcnRpbmcgdGhlIHJ1biBtYXAgdG8gYSBydW4gdHJlZSwgd2UgYXJlIGRvaW5nIGEgY29weVxuICAgICAgICAgICAgLy8gdGh1cywgYW55IG11dGF0aW9uIHBlcmZvcm1lZCBvbiB0aGUgcnVuIHRyZWUgd2lsbCBub3QgYmUgcmVmbGVjdGVkXG4gICAgICAgICAgICAvLyBiYWNrIGluIHRoZSBydW4gbWFwXG4gICAgICAgICAgICAvLyBUT0RPOiBTdG9wIHVzaW5nIGB0aGlzLnJ1bk1hcGAgaW4gZmF2b3VyIG9mIExhbmdTbWl0aCdzIGBSdW5UcmVlYFxuICAgICAgICAgICAgY29uc3QgcnVuVHJlZSA9IG5ldyBSdW5UcmVlKHtcbiAgICAgICAgICAgICAgICAuLi5ydW4sXG4gICAgICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICAgICAgcGFyZW50X3J1bjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIC8vIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBwcm9qZWN0X25hbWU6IHRoaXMucHJvamVjdE5hbWUsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHRoaXMuZXhhbXBsZUlkLFxuICAgICAgICAgICAgICAgIHRyYWNpbmdFbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBydW5UcmVlTWFwW2lkXSA9IHJ1blRyZWU7XG4gICAgICAgICAgICBydW5UcmVlTGlzdC5wdXNoKFtpZCwgcnVuLmRvdHRlZF9vcmRlcl0pO1xuICAgICAgICB9XG4gICAgICAgIHJ1blRyZWVMaXN0LnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGlmICghYVsxXSB8fCAhYlsxXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIHJldHVybiBhWzFdLmxvY2FsZUNvbXBhcmUoYlsxXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IFtpZF0gb2YgcnVuVHJlZUxpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChpZCk7XG4gICAgICAgICAgICBjb25zdCBydW5UcmVlID0gcnVuVHJlZU1hcFtpZF07XG4gICAgICAgICAgICBpZiAoIXJ1biB8fCAhcnVuVHJlZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChydW4ucGFyZW50X3J1bl9pZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFJ1blRyZWUgPSBydW5UcmVlTWFwW3J1bi5wYXJlbnRfcnVuX2lkXTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50UnVuVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRSdW5UcmVlLmNoaWxkX3J1bnMucHVzaChydW5UcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgcnVuVHJlZS5wYXJlbnRfcnVuID0gcGFyZW50UnVuVHJlZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1blRyZWVNYXBbaWRdO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VHJhY2VhYmxlUnVuVHJlZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDdXJyZW50UnVuVHJlZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/tracers/tracer_langchain.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/async_caller.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/async_caller.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(action-browser)/./node_modules/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(action-browser)/./node_modules/p-queue/dist/index.js\");\n\n\nconst STATUS_NO_RETRY = [\n    400,\n    401,\n    402,\n    403,\n    404,\n    405,\n    406,\n    407,\n    409, // Conflict\n];\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst defaultFailedAttemptHandler = (error) => {\n    if (error.message.startsWith(\"Cancel\") ||\n        error.message.startsWith(\"AbortError\") ||\n        error.name === \"AbortError\") {\n        throw error;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (error?.code === \"ECONNABORTED\") {\n        throw error;\n    }\n    const status = \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    error?.response?.status ?? error?.status;\n    if (status && STATUS_NO_RETRY.includes(+status)) {\n        throw error;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (error?.error?.code === \"insufficient_quota\") {\n        const err = new Error(error?.message);\n        err.name = \"InsufficientQuotaError\";\n        throw err;\n    }\n};\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */\nclass AsyncCaller {\n    constructor(params) {\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedAttempt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        this.onFailedAttempt =\n            params.onFailedAttempt ?? defaultFailedAttemptHandler;\n        const PQueue =  true ? p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"] : p_queue__WEBPACK_IMPORTED_MODULE_1__;\n        this.queue = new PQueue({ concurrency: this.maxConcurrency });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        return this.queue.add(() => p_retry__WEBPACK_IMPORTED_MODULE_0__(() => callable(...args).catch((error) => {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (error instanceof Error) {\n                throw error;\n            }\n            else {\n                throw new Error(error);\n            }\n        }), {\n            onFailedAttempt: this.onFailedAttempt,\n            retries: this.maxRetries,\n            randomize: true,\n            // If needed we can change some of the defaults here,\n            // but they're quite sensible.\n        }), { throwOnTimeout: true });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject) => {\n                    options.signal?.addEventListener(\"abort\", () => {\n                        reject(new Error(\"AbortError\"));\n                    });\n                }),\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        return this.call(() => fetch(...args).then((res) => (res.ok ? res : Promise.reject(res))));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2FzeW5jX2NhbGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkI7QUFDRztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixLQUFzQixHQUFHLCtDQUFpQixHQUFHLG9DQUFTO0FBQzdFLGtDQUFrQyxrQ0FBa0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9DQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUssc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFx0ZXh0c3BsaXR0ZXJzXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHV0aWxzXFxhc3luY19jYWxsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBSZXRyeSBmcm9tIFwicC1yZXRyeVwiO1xuaW1wb3J0IFBRdWV1ZU1vZCBmcm9tIFwicC1xdWV1ZVwiO1xuY29uc3QgU1RBVFVTX05PX1JFVFJZID0gW1xuICAgIDQwMCxcbiAgICA0MDEsXG4gICAgNDAyLFxuICAgIDQwMyxcbiAgICA0MDQsXG4gICAgNDA1LFxuICAgIDQwNixcbiAgICA0MDcsXG4gICAgNDA5LCAvLyBDb25mbGljdFxuXTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBkZWZhdWx0RmFpbGVkQXR0ZW1wdEhhbmRsZXIgPSAoZXJyb3IpID0+IHtcbiAgICBpZiAoZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQ2FuY2VsXCIpIHx8XG4gICAgICAgIGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkFib3J0RXJyb3JcIikgfHxcbiAgICAgICAgZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaWYgKGVycm9yPy5jb2RlID09PSBcIkVDT05OQUJPUlRFRFwiKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBzdGF0dXMgPSBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGVycm9yPy5yZXNwb25zZT8uc3RhdHVzID8/IGVycm9yPy5zdGF0dXM7XG4gICAgaWYgKHN0YXR1cyAmJiBTVEFUVVNfTk9fUkVUUlkuaW5jbHVkZXMoK3N0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaWYgKGVycm9yPy5lcnJvcj8uY29kZSA9PT0gXCJpbnN1ZmZpY2llbnRfcXVvdGFcIikge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoZXJyb3I/Lm1lc3NhZ2UpO1xuICAgICAgICBlcnIubmFtZSA9IFwiSW5zdWZmaWNpZW50UXVvdGFFcnJvclwiO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgYXN5bmMgY2FsbHMgd2l0aCBjb25jdXJyZW5jeSBhbmQgcmV0cnkgbG9naWMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIG1ha2luZyBjYWxscyB0byBhbnkga2luZCBvZiBcImV4cGVuc2l2ZVwiIGV4dGVybmFsIHJlc291cmNlLFxuICogYmUgaXQgYmVjYXVzZSBpdCdzIHJhdGUtbGltaXRlZCwgc3ViamVjdCB0byBuZXR3b3JrIGlzc3VlcywgZXRjLlxuICpcbiAqIENvbmN1cnJlbnQgY2FsbHMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhDb25jdXJyZW5jeWAgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0c1xuICogdG8gYEluZmluaXR5YC4gVGhpcyBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGFsbCBjYWxscyB3aWxsIGJlIG1hZGUgaW4gcGFyYWxsZWwuXG4gKlxuICogUmV0cmllcyBhcmUgbGltaXRlZCBieSB0aGUgYG1heFJldHJpZXNgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHMgdG8gNi4gVGhpc1xuICogbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBlYWNoIGNhbGwgd2lsbCBiZSByZXRyaWVkIHVwIHRvIDYgdGltZXMsIHdpdGggYW5cbiAqIGV4cG9uZW50aWFsIGJhY2tvZmYgYmV0d2VlbiBlYWNoIGF0dGVtcHQuXG4gKi9cbmV4cG9ydCBjbGFzcyBBc3luY0NhbGxlciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heENvbmN1cnJlbmN5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFJldHJpZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib25GYWlsZWRBdHRlbXB0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInF1ZXVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4Q29uY3VycmVuY3kgPSBwYXJhbXMubWF4Q29uY3VycmVuY3kgPz8gSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IHBhcmFtcy5tYXhSZXRyaWVzID8/IDY7XG4gICAgICAgIHRoaXMub25GYWlsZWRBdHRlbXB0ID1cbiAgICAgICAgICAgIHBhcmFtcy5vbkZhaWxlZEF0dGVtcHQgPz8gZGVmYXVsdEZhaWxlZEF0dGVtcHRIYW5kbGVyO1xuICAgICAgICBjb25zdCBQUXVldWUgPSBcImRlZmF1bHRcIiBpbiBQUXVldWVNb2QgPyBQUXVldWVNb2QuZGVmYXVsdCA6IFBRdWV1ZU1vZDtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQUXVldWUoeyBjb25jdXJyZW5jeTogdGhpcy5tYXhDb25jdXJyZW5jeSB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLmFkZCgoKSA9PiBwUmV0cnkoKCkgPT4gY2FsbGFibGUoLi4uYXJncykuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgIG9uRmFpbGVkQXR0ZW1wdDogdGhpcy5vbkZhaWxlZEF0dGVtcHQsXG4gICAgICAgICAgICByZXRyaWVzOiB0aGlzLm1heFJldHJpZXMsXG4gICAgICAgICAgICByYW5kb21pemU6IHRydWUsXG4gICAgICAgICAgICAvLyBJZiBuZWVkZWQgd2UgY2FuIGNoYW5nZSBzb21lIG9mIHRoZSBkZWZhdWx0cyBoZXJlLFxuICAgICAgICAgICAgLy8gYnV0IHRoZXkncmUgcXVpdGUgc2Vuc2libGUuXG4gICAgICAgIH0pLCB7IHRocm93T25UaW1lb3V0OiB0cnVlIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGxXaXRoT3B0aW9ucyhvcHRpb25zLCBjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICAvLyBOb3RlIHRoaXMgZG9lc24ndCBjYW5jZWwgdGhlIHVuZGVybHlpbmcgcmVxdWVzdCxcbiAgICAgICAgLy8gd2hlbiBhdmFpbGFibGUgcHJlZmVyIHRvIHVzZSB0aGUgc2lnbmFsIG9wdGlvbiBvZiB0aGUgdW5kZXJseWluZyBjYWxsXG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSxcbiAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsPy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFib3J0RXJyb3JcIikpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmZXRjaCguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoKCkgPT4gZmV0Y2goLi4uYXJncykudGhlbigocmVzKSA9PiAocmVzLm9rID8gcmVzIDogUHJvbWlzZS5yZWplY3QocmVzKSkpKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/async_caller.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/callbacks.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/callbacks.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isTracingEnabled: () => (/* binding */ isTracingEnabled)\n/* harmony export */ });\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/env.js\");\n\nconst isTracingEnabled = (tracingEnabled) => {\n    if (tracingEnabled !== undefined) {\n        return tracingEnabled;\n    }\n    const envVars = [\n        \"LANGSMITH_TRACING_V2\",\n        \"LANGCHAIN_TRACING_V2\",\n        \"LANGSMITH_TRACING\",\n        \"LANGCHAIN_TRACING\",\n    ];\n    return !!envVars.find((envVar) => (0,_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(envVar) === \"true\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2NhbGxiYWNrcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrRDtBQUMzQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywrREFBc0I7QUFDNUQiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFx0ZXh0c3BsaXR0ZXJzXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHV0aWxzXFxjYWxsYmFja3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSB9IGZyb20gXCIuL2Vudi5qc1wiO1xuZXhwb3J0IGNvbnN0IGlzVHJhY2luZ0VuYWJsZWQgPSAodHJhY2luZ0VuYWJsZWQpID0+IHtcbiAgICBpZiAodHJhY2luZ0VuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJhY2luZ0VuYWJsZWQ7XG4gICAgfVxuICAgIGNvbnN0IGVudlZhcnMgPSBbXG4gICAgICAgIFwiTEFOR1NNSVRIX1RSQUNJTkdfVjJcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fVFJBQ0lOR19WMlwiLFxuICAgICAgICBcIkxBTkdTTUlUSF9UUkFDSU5HXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX1RSQUNJTkdcIixcbiAgICBdO1xuICAgIHJldHVybiAhIWVudlZhcnMuZmluZCgoZW52VmFyKSA9PiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKGVudlZhcikgPT09IFwidHJ1ZVwiKTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/callbacks.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/env.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/env.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnv: () => (/* binding */ getEnv),\n/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable),\n/* harmony export */   getRuntimeEnvironment: () => (/* binding */ getRuntimeEnvironment),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isDeno: () => (/* binding */ isDeno),\n/* harmony export */   isJsDom: () => (/* binding */ isJsDom),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker)\n/* harmony export */ });\nconst isBrowser = () => typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nconst isWebWorker = () => typeof globalThis === \"object\" &&\n    globalThis.constructor &&\n    globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nconst isJsDom = () => (typeof window !== \"undefined\" && window.name === \"nodejs\") ||\n    (typeof navigator !== \"undefined\" &&\n        (navigator.userAgent.includes(\"Node.js\") ||\n            navigator.userAgent.includes(\"jsdom\")));\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nconst isDeno = () => typeof Deno !== \"undefined\";\n// Mark not-as-node if in Supabase Edge Function\nconst isNode = () => typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\" &&\n    !isDeno();\nconst getEnv = () => {\n    let env;\n    if (isBrowser()) {\n        env = \"browser\";\n    }\n    else if (isNode()) {\n        env = \"node\";\n    }\n    else if (isWebWorker()) {\n        env = \"webworker\";\n    }\n    else if (isJsDom()) {\n        env = \"jsdom\";\n    }\n    else if (isDeno()) {\n        env = \"deno\";\n    }\n    else {\n        env = \"other\";\n    }\n    return env;\n};\nlet runtimeEnvironment;\nasync function getRuntimeEnvironment() {\n    if (runtimeEnvironment === undefined) {\n        const env = getEnv();\n        runtimeEnvironment = {\n            library: \"langchain-js\",\n            runtime: env,\n        };\n    }\n    return runtimeEnvironment;\n}\nfunction getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/langchain-ai/langchainjs/issues/1412\n    try {\n        return typeof process !== \"undefined\"\n            ? // eslint-disable-next-line no-process-env\n                process.env?.[name]\n            : undefined;\n    }\n    catch (e) {\n        return undefined;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2Vudi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFx0ZXh0c3BsaXR0ZXJzXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHV0aWxzXFxlbnYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbmV4cG9ydCBjb25zdCBpc1dlYldvcmtlciA9ICgpID0+IHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiICYmXG4gICAgZ2xvYmFsVGhpcy5jb25zdHJ1Y3RvciAmJlxuICAgIGdsb2JhbFRoaXMuY29uc3RydWN0b3IubmFtZSA9PT0gXCJEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZVwiO1xuZXhwb3J0IGNvbnN0IGlzSnNEb20gPSAoKSA9PiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubmFtZSA9PT0gXCJub2RlanNcIikgfHxcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcIk5vZGUuanNcIikgfHxcbiAgICAgICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJqc2RvbVwiKSkpO1xuLy8gU3VwYWJhc2UgRWRnZSBGdW5jdGlvbiBwcm92aWRlcyBhIGBEZW5vYCBnbG9iYWwgb2JqZWN0XG4vLyB3aXRob3V0IGB2ZXJzaW9uYCBwcm9wZXJ0eVxuZXhwb3J0IGNvbnN0IGlzRGVubyA9ICgpID0+IHR5cGVvZiBEZW5vICE9PSBcInVuZGVmaW5lZFwiO1xuLy8gTWFyayBub3QtYXMtbm9kZSBpZiBpbiBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9uXG5leHBvcnQgY29uc3QgaXNOb2RlID0gKCkgPT4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAhaXNEZW5vKCk7XG5leHBvcnQgY29uc3QgZ2V0RW52ID0gKCkgPT4ge1xuICAgIGxldCBlbnY7XG4gICAgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgICAgIGVudiA9IFwiYnJvd3NlclwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc05vZGUoKSkge1xuICAgICAgICBlbnYgPSBcIm5vZGVcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNXZWJXb3JrZXIoKSkge1xuICAgICAgICBlbnYgPSBcIndlYndvcmtlclwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0pzRG9tKCkpIHtcbiAgICAgICAgZW52ID0gXCJqc2RvbVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Rlbm8oKSkge1xuICAgICAgICBlbnYgPSBcImRlbm9cIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVudiA9IFwib3RoZXJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGVudjtcbn07XG5sZXQgcnVudGltZUVudmlyb25tZW50O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFJ1bnRpbWVFbnZpcm9ubWVudCgpIHtcbiAgICBpZiAocnVudGltZUVudmlyb25tZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZW52ID0gZ2V0RW52KCk7XG4gICAgICAgIHJ1bnRpbWVFbnZpcm9ubWVudCA9IHtcbiAgICAgICAgICAgIGxpYnJhcnk6IFwibGFuZ2NoYWluLWpzXCIsXG4gICAgICAgICAgICBydW50aW1lOiBlbnYsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBydW50aW1lRW52aXJvbm1lbnQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShuYW1lKSB7XG4gICAgLy8gQ2VydGFpbiBEZW5vIHNldHVwcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSB0cnkgdG8gYWNjZXNzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9sYW5nY2hhaW4tYWkvbGFuZ2NoYWluanMvaXNzdWVzLzE0MTJcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnY/LltuYW1lXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/env.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/index.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/index.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonPatchError: () => (/* reexport safe */ _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.PatchError),\n/* harmony export */   _areEquals: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__._areEquals),\n/* harmony export */   applyOperation: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.applyOperation),\n/* harmony export */   applyPatch: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.applyPatch),\n/* harmony export */   applyReducer: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.applyReducer),\n/* harmony export */   compare: () => (/* reexport safe */ _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__.compare),\n/* harmony export */   deepClone: () => (/* reexport safe */ _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__._deepClone),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   escapePathComponent: () => (/* reexport safe */ _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.escapePathComponent),\n/* harmony export */   generate: () => (/* reexport safe */ _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__.generate),\n/* harmony export */   getValueByPointer: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.getValueByPointer),\n/* harmony export */   observe: () => (/* reexport safe */ _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__.observe),\n/* harmony export */   unescapePathComponent: () => (/* reexport safe */ _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.unescapePathComponent),\n/* harmony export */   unobserve: () => (/* reexport safe */ _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__.unobserve),\n/* harmony export */   validate: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.validate),\n/* harmony export */   validator: () => (/* reexport safe */ _src_core_js__WEBPACK_IMPORTED_MODULE_0__.validator)\n/* harmony export */ });\n/* harmony import */ var _src_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/core.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js\");\n/* harmony import */ var _src_duplex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/duplex.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js\");\n/* harmony import */ var _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/helpers.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js\");\n\n\n\n/**\n * Default export for backwards compat\n */\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    ..._src_core_js__WEBPACK_IMPORTED_MODULE_0__,\n    // ...duplex,\n    JsonPatchError: _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.PatchError,\n    deepClone: _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__._deepClone,\n    escapePathComponent: _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.escapePathComponent,\n    unescapePathComponent: _src_helpers_js__WEBPACK_IMPORTED_MODULE_2__.unescapePathComponent,\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2Zhc3QtanNvbi1wYXRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThCO0FBQ0U7QUFDc0c7QUFDdEk7QUFDQTtBQUNBO0FBQ3NDO0FBQ2dHO0FBQ3RJLGlFQUFlO0FBQ2YsT0FBTyx5Q0FBSTtBQUNYO0FBQ0Esa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLENBQUMsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXHRleHRzcGxpdHRlcnNcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdXRpbHNcXGZhc3QtanNvbi1wYXRjaFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4vc3JjL2NvcmUuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3NyYy9kdXBsZXguanNcIjtcbmV4cG9ydCB7IFBhdGNoRXJyb3IgYXMgSnNvblBhdGNoRXJyb3IsIF9kZWVwQ2xvbmUgYXMgZGVlcENsb25lLCBlc2NhcGVQYXRoQ29tcG9uZW50LCB1bmVzY2FwZVBhdGhDb21wb25lbnQsIH0gZnJvbSBcIi4vc3JjL2hlbHBlcnMuanNcIjtcbi8qKlxuICogRGVmYXVsdCBleHBvcnQgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi9zcmMvY29yZS5qc1wiO1xuaW1wb3J0IHsgUGF0Y2hFcnJvciBhcyBKc29uUGF0Y2hFcnJvciwgX2RlZXBDbG9uZSBhcyBkZWVwQ2xvbmUsIGVzY2FwZVBhdGhDb21wb25lbnQsIHVuZXNjYXBlUGF0aENvbXBvbmVudCwgfSBmcm9tIFwiLi9zcmMvaGVscGVycy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIC4uLmNvcmUsXG4gICAgLy8gLi4uZHVwbGV4LFxuICAgIEpzb25QYXRjaEVycm9yLFxuICAgIGRlZXBDbG9uZSxcbiAgICBlc2NhcGVQYXRoQ29tcG9uZW50LFxuICAgIHVuZXNjYXBlUGF0aENvbXBvbmVudCxcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonPatchError: () => (/* binding */ JsonPatchError),\n/* harmony export */   _areEquals: () => (/* binding */ _areEquals),\n/* harmony export */   applyOperation: () => (/* binding */ applyOperation),\n/* harmony export */   applyPatch: () => (/* binding */ applyPatch),\n/* harmony export */   applyReducer: () => (/* binding */ applyReducer),\n/* harmony export */   deepClone: () => (/* binding */ deepClone),\n/* harmony export */   getValueByPointer: () => (/* binding */ getValueByPointer),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   validator: () => (/* binding */ validator)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js\");\n// @ts-nocheck\n\nconst JsonPatchError = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.PatchError;\nconst deepClone = _helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone;\n/* We use a Javascript hash to store each\n function. Each hash entry (property) uses\n the operation identifiers specified in rfc6902.\n In this way, we can map each patch operation\n to its dedicated function in efficient way.\n */\n/* The operations applicable to an object */\nconst objOps = {\n    add: function (obj, key, document) {\n        obj[key] = this.value;\n        return { newDocument: document };\n    },\n    remove: function (obj, key, document) {\n        var removed = obj[key];\n        delete obj[key];\n        return { newDocument: document, removed };\n    },\n    replace: function (obj, key, document) {\n        var removed = obj[key];\n        obj[key] = this.value;\n        return { newDocument: document, removed };\n    },\n    move: function (obj, key, document) {\n        /* in case move target overwrites an existing value,\n        return the removed value, this can be taxing performance-wise,\n        and is potentially unneeded */\n        let removed = getValueByPointer(document, this.path);\n        if (removed) {\n            removed = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(removed);\n        }\n        const originalValue = applyOperation(document, {\n            op: \"remove\",\n            path: this.from,\n        }).removed;\n        applyOperation(document, {\n            op: \"add\",\n            path: this.path,\n            value: originalValue,\n        });\n        return { newDocument: document, removed };\n    },\n    copy: function (obj, key, document) {\n        const valueToCopy = getValueByPointer(document, this.from);\n        // enforce copy by value so further operations don't affect source (see issue #177)\n        applyOperation(document, {\n            op: \"add\",\n            path: this.path,\n            value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(valueToCopy),\n        });\n        return { newDocument: document };\n    },\n    test: function (obj, key, document) {\n        return { newDocument: document, test: _areEquals(obj[key], this.value) };\n    },\n    _get: function (obj, key, document) {\n        this.value = obj[key];\n        return { newDocument: document };\n    },\n};\n/* The operations applicable to an array. Many are the same as for the object */\nvar arrOps = {\n    add: function (arr, i, document) {\n        if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(i)) {\n            arr.splice(i, 0, this.value);\n        }\n        else {\n            // array props\n            arr[i] = this.value;\n        }\n        // this may be needed when using '-' in an array\n        return { newDocument: document, index: i };\n    },\n    remove: function (arr, i, document) {\n        var removedList = arr.splice(i, 1);\n        return { newDocument: document, removed: removedList[0] };\n    },\n    replace: function (arr, i, document) {\n        var removed = arr[i];\n        arr[i] = this.value;\n        return { newDocument: document, removed };\n    },\n    move: objOps.move,\n    copy: objOps.copy,\n    test: objOps.test,\n    _get: objOps._get,\n};\n/**\n * Retrieves a value from a JSON document by a JSON pointer.\n * Returns the value.\n *\n * @param document The document to get the value from\n * @param pointer an escaped JSON pointer\n * @return The retrieved value\n */\nfunction getValueByPointer(document, pointer) {\n    if (pointer == \"\") {\n        return document;\n    }\n    var getOriginalDestination = { op: \"_get\", path: pointer };\n    applyOperation(document, getOriginalDestination);\n    return getOriginalDestination.value;\n}\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the {newDocument, result} of the operation.\n * It modifies the `document` and `operation` objects - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return `{newDocument, result}` after the operation\n */\nfunction applyOperation(document, operation, validateOperation = false, mutateDocument = true, banPrototypeModifications = true, index = 0) {\n    if (validateOperation) {\n        if (typeof validateOperation == \"function\") {\n            validateOperation(operation, 0, document, operation.path);\n        }\n        else {\n            validator(operation, 0);\n        }\n    }\n    /* ROOT OPERATIONS */\n    if (operation.path === \"\") {\n        let returnValue = { newDocument: document };\n        if (operation.op === \"add\") {\n            returnValue.newDocument = operation.value;\n            return returnValue;\n        }\n        else if (operation.op === \"replace\") {\n            returnValue.newDocument = operation.value;\n            returnValue.removed = document; //document we removed\n            return returnValue;\n        }\n        else if (operation.op === \"move\" || operation.op === \"copy\") {\n            // it's a move or copy to root\n            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field\n            if (operation.op === \"move\") {\n                // report removed item\n                returnValue.removed = document;\n            }\n            return returnValue;\n        }\n        else if (operation.op === \"test\") {\n            returnValue.test = _areEquals(document, operation.value);\n            if (returnValue.test === false) {\n                throw new JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n            }\n            returnValue.newDocument = document;\n            return returnValue;\n        }\n        else if (operation.op === \"remove\") {\n            // a remove on root\n            returnValue.removed = document;\n            returnValue.newDocument = null;\n            return returnValue;\n        }\n        else if (operation.op === \"_get\") {\n            operation.value = document;\n            return returnValue;\n        }\n        else {\n            /* bad operation */\n            if (validateOperation) {\n                throw new JsonPatchError(\"Operation `op` property is not one of operations defined in RFC-6902\", \"OPERATION_OP_INVALID\", index, operation, document);\n            }\n            else {\n                return returnValue;\n            }\n        }\n    } /* END ROOT OPERATIONS */\n    else {\n        if (!mutateDocument) {\n            document = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document);\n        }\n        const path = operation.path || \"\";\n        const keys = path.split(\"/\");\n        let obj = document;\n        let t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift\n        let len = keys.length;\n        let existingPathFragment = undefined;\n        let key;\n        let validateFunction;\n        if (typeof validateOperation == \"function\") {\n            validateFunction = validateOperation;\n        }\n        else {\n            validateFunction = validator;\n        }\n        while (true) {\n            key = keys[t];\n            if (key && key.indexOf(\"~\") != -1) {\n                key = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.unescapePathComponent)(key);\n            }\n            if (banPrototypeModifications &&\n                (key == \"__proto__\" ||\n                    (key == \"prototype\" && t > 0 && keys[t - 1] == \"constructor\"))) {\n                throw new TypeError(\"JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README\");\n            }\n            if (validateOperation) {\n                if (existingPathFragment === undefined) {\n                    if (obj[key] === undefined) {\n                        existingPathFragment = keys.slice(0, t).join(\"/\");\n                    }\n                    else if (t == len - 1) {\n                        existingPathFragment = operation.path;\n                    }\n                    if (existingPathFragment !== undefined) {\n                        validateFunction(operation, 0, document, existingPathFragment);\n                    }\n                }\n            }\n            t++;\n            if (Array.isArray(obj)) {\n                if (key === \"-\") {\n                    key = obj.length;\n                }\n                else {\n                    if (validateOperation && !(0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(key)) {\n                        throw new JsonPatchError(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\", \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\", index, operation, document);\n                    } // only parse key when it's an integer for `arr.prop` to work\n                    else if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(key)) {\n                        key = ~~key;\n                    }\n                }\n                if (t >= len) {\n                    if (validateOperation && operation.op === \"add\" && key > obj.length) {\n                        throw new JsonPatchError(\"The specified index MUST NOT be greater than the number of elements in the array\", \"OPERATION_VALUE_OUT_OF_BOUNDS\", index, operation, document);\n                    }\n                    const returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        throw new JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n            else {\n                if (t >= len) {\n                    const returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        throw new JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n            obj = obj[key];\n            // If we have more keys in the path, but the next value isn't a non-null object,\n            // throw an OPERATION_PATH_UNRESOLVABLE error instead of iterating again.\n            if (validateOperation && t < len && (!obj || typeof obj !== \"object\")) {\n                throw new JsonPatchError(\"Cannot perform operation at the desired path\", \"OPERATION_PATH_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n    }\n}\n/**\n * Apply a full JSON Patch array on a JSON document.\n * Returns the {newDocument, result} of the patch.\n * It modifies the `document` object and `patch` - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.\n *\n * @param document The document to patch\n * @param patch The patch to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return An array of `{newDocument, result}` after the patch\n */\nfunction applyPatch(document, patch, validateOperation, mutateDocument = true, banPrototypeModifications = true) {\n    if (validateOperation) {\n        if (!Array.isArray(patch)) {\n            throw new JsonPatchError(\"Patch sequence must be an array\", \"SEQUENCE_NOT_AN_ARRAY\");\n        }\n    }\n    if (!mutateDocument) {\n        document = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document);\n    }\n    const results = new Array(patch.length);\n    for (let i = 0, length = patch.length; i < length; i++) {\n        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`\n        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);\n        document = results[i].newDocument; // in case root was replaced\n    }\n    results.newDocument = document;\n    return results;\n}\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the updated document.\n * Suitable as a reducer.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @return The updated document\n */\nfunction applyReducer(document, operation, index) {\n    const operationResult = applyOperation(document, operation);\n    if (operationResult.test === false) {\n        // failed test\n        throw new JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n    }\n    return operationResult.newDocument;\n}\n/**\n * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.\n * @param {object} operation - operation object (patch)\n * @param {number} index - index of operation in the sequence\n * @param {object} [document] - object where the operation is supposed to be applied\n * @param {string} [existingPathFragment] - comes along with `document`\n */\nfunction validator(operation, index, document, existingPathFragment) {\n    if (typeof operation !== \"object\" ||\n        operation === null ||\n        Array.isArray(operation)) {\n        throw new JsonPatchError(\"Operation is not an object\", \"OPERATION_NOT_AN_OBJECT\", index, operation, document);\n    }\n    else if (!objOps[operation.op]) {\n        throw new JsonPatchError(\"Operation `op` property is not one of operations defined in RFC-6902\", \"OPERATION_OP_INVALID\", index, operation, document);\n    }\n    else if (typeof operation.path !== \"string\") {\n        throw new JsonPatchError(\"Operation `path` property is not a string\", \"OPERATION_PATH_INVALID\", index, operation, document);\n    }\n    else if (operation.path.indexOf(\"/\") !== 0 && operation.path.length > 0) {\n        // paths that aren't empty string should start with \"/\"\n        throw new JsonPatchError('Operation `path` property must start with \"/\"', \"OPERATION_PATH_INVALID\", index, operation, document);\n    }\n    else if ((operation.op === \"move\" || operation.op === \"copy\") &&\n        typeof operation.from !== \"string\") {\n        throw new JsonPatchError(\"Operation `from` property is not present (applicable in `move` and `copy` operations)\", \"OPERATION_FROM_REQUIRED\", index, operation, document);\n    }\n    else if ((operation.op === \"add\" ||\n        operation.op === \"replace\" ||\n        operation.op === \"test\") &&\n        operation.value === undefined) {\n        throw new JsonPatchError(\"Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)\", \"OPERATION_VALUE_REQUIRED\", index, operation, document);\n    }\n    else if ((operation.op === \"add\" ||\n        operation.op === \"replace\" ||\n        operation.op === \"test\") &&\n        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.hasUndefined)(operation.value)) {\n        throw new JsonPatchError(\"Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)\", \"OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED\", index, operation, document);\n    }\n    else if (document) {\n        if (operation.op == \"add\") {\n            var pathLen = operation.path.split(\"/\").length;\n            var existingPathLen = existingPathFragment.split(\"/\").length;\n            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {\n                throw new JsonPatchError(\"Cannot perform an `add` operation at the desired path\", \"OPERATION_PATH_CANNOT_ADD\", index, operation, document);\n            }\n        }\n        else if (operation.op === \"replace\" ||\n            operation.op === \"remove\" ||\n            operation.op === \"_get\") {\n            if (operation.path !== existingPathFragment) {\n                throw new JsonPatchError(\"Cannot perform the operation at a path that does not exist\", \"OPERATION_PATH_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n        else if (operation.op === \"move\" || operation.op === \"copy\") {\n            var existingValue = {\n                op: \"_get\",\n                path: operation.from,\n                value: undefined,\n            };\n            var error = validate([existingValue], document);\n            if (error && error.name === \"OPERATION_PATH_UNRESOLVABLE\") {\n                throw new JsonPatchError(\"Cannot perform the operation from a path that does not exist\", \"OPERATION_FROM_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n    }\n}\n/**\n * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.\n * If error is encountered, returns a JsonPatchError object\n * @param sequence\n * @param document\n * @returns {JsonPatchError|undefined}\n */\nfunction validate(sequence, document, externalValidator) {\n    try {\n        if (!Array.isArray(sequence)) {\n            throw new JsonPatchError(\"Patch sequence must be an array\", \"SEQUENCE_NOT_AN_ARRAY\");\n        }\n        if (document) {\n            //clone document and sequence so that we can safely try applying operations\n            applyPatch((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document), (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(sequence), externalValidator || true);\n        }\n        else {\n            externalValidator = externalValidator || validator;\n            for (var i = 0; i < sequence.length; i++) {\n                externalValidator(sequence[i], i, document, undefined);\n            }\n        }\n    }\n    catch (e) {\n        if (e instanceof JsonPatchError) {\n            return e;\n        }\n        else {\n            throw e;\n        }\n    }\n}\n// based on https://github.com/epoberezkin/fast-deep-equal\n// MIT License\n// Copyright (c) 2017 Evgeny Poberezkin\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nfunction _areEquals(a, b) {\n    if (a === b)\n        return true;\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;\n        if (arrA && arrB) {\n            length = a.length;\n            if (length != b.length)\n                return false;\n            for (i = length; i-- !== 0;)\n                if (!_areEquals(a[i], b[i]))\n                    return false;\n            return true;\n        }\n        if (arrA != arrB)\n            return false;\n        var keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length)\n            return false;\n        for (i = length; i-- !== 0;)\n            if (!b.hasOwnProperty(keys[i]))\n                return false;\n        for (i = length; i-- !== 0;) {\n            key = keys[i];\n            if (!_areEquals(a[key], b[key]))\n                return false;\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2Zhc3QtanNvbi1wYXRjaC9zcmMvY29yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDdUc7QUFDaEcsdUJBQXVCLG1EQUFVO0FBQ2pDLGtCQUFrQixtREFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1REFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1REFBVTtBQUM3QixTQUFTO0FBQ1QsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHVCQUF1Qix1REFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrRUFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0RBQVM7QUFDdkQ7QUFDQSxzQkFBc0I7QUFDdEIsNkJBQTZCLHNEQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVEQUFVO0FBQzdCO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQVUsWUFBWSx1REFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXHRleHRzcGxpdHRlcnNcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdXRpbHNcXGZhc3QtanNvbi1wYXRjaFxcc3JjXFxjb3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1ub2NoZWNrXG5pbXBvcnQgeyBQYXRjaEVycm9yLCBfZGVlcENsb25lLCBpc0ludGVnZXIsIHVuZXNjYXBlUGF0aENvbXBvbmVudCwgaGFzVW5kZWZpbmVkLCB9IGZyb20gXCIuL2hlbHBlcnMuanNcIjtcbmV4cG9ydCBjb25zdCBKc29uUGF0Y2hFcnJvciA9IFBhdGNoRXJyb3I7XG5leHBvcnQgY29uc3QgZGVlcENsb25lID0gX2RlZXBDbG9uZTtcbi8qIFdlIHVzZSBhIEphdmFzY3JpcHQgaGFzaCB0byBzdG9yZSBlYWNoXG4gZnVuY3Rpb24uIEVhY2ggaGFzaCBlbnRyeSAocHJvcGVydHkpIHVzZXNcbiB0aGUgb3BlcmF0aW9uIGlkZW50aWZpZXJzIHNwZWNpZmllZCBpbiByZmM2OTAyLlxuIEluIHRoaXMgd2F5LCB3ZSBjYW4gbWFwIGVhY2ggcGF0Y2ggb3BlcmF0aW9uXG4gdG8gaXRzIGRlZGljYXRlZCBmdW5jdGlvbiBpbiBlZmZpY2llbnQgd2F5LlxuICovXG4vKiBUaGUgb3BlcmF0aW9ucyBhcHBsaWNhYmxlIHRvIGFuIG9iamVjdCAqL1xuY29uc3Qgb2JqT3BzID0ge1xuICAgIGFkZDogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICBvYmpba2V5XSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gb2JqW2tleV07XG4gICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkIH07XG4gICAgfSxcbiAgICByZXBsYWNlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gb2JqW2tleV07XG4gICAgICAgIG9ialtrZXldID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkIH07XG4gICAgfSxcbiAgICBtb3ZlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIC8qIGluIGNhc2UgbW92ZSB0YXJnZXQgb3ZlcndyaXRlcyBhbiBleGlzdGluZyB2YWx1ZSxcbiAgICAgICAgcmV0dXJuIHRoZSByZW1vdmVkIHZhbHVlLCB0aGlzIGNhbiBiZSB0YXhpbmcgcGVyZm9ybWFuY2Utd2lzZSxcbiAgICAgICAgYW5kIGlzIHBvdGVudGlhbGx5IHVubmVlZGVkICovXG4gICAgICAgIGxldCByZW1vdmVkID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIHRoaXMucGF0aCk7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICByZW1vdmVkID0gX2RlZXBDbG9uZShyZW1vdmVkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbFZhbHVlID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHtcbiAgICAgICAgICAgIG9wOiBcInJlbW92ZVwiLFxuICAgICAgICAgICAgcGF0aDogdGhpcy5mcm9tLFxuICAgICAgICB9KS5yZW1vdmVkO1xuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwge1xuICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogb3JpZ2luYWxWYWx1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgY29weTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICBjb25zdCB2YWx1ZVRvQ29weSA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCB0aGlzLmZyb20pO1xuICAgICAgICAvLyBlbmZvcmNlIGNvcHkgYnkgdmFsdWUgc28gZnVydGhlciBvcGVyYXRpb25zIGRvbid0IGFmZmVjdCBzb3VyY2UgKHNlZSBpc3N1ZSAjMTc3KVxuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwge1xuICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogX2RlZXBDbG9uZSh2YWx1ZVRvQ29weSksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCB0ZXN0OiBfYXJlRXF1YWxzKG9ialtrZXldLCB0aGlzLnZhbHVlKSB9O1xuICAgIH0sXG4gICAgX2dldDogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgIH0sXG59O1xuLyogVGhlIG9wZXJhdGlvbnMgYXBwbGljYWJsZSB0byBhbiBhcnJheS4gTWFueSBhcmUgdGhlIHNhbWUgYXMgZm9yIHRoZSBvYmplY3QgKi9cbnZhciBhcnJPcHMgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xuICAgICAgICBpZiAoaXNJbnRlZ2VyKGkpKSB7XG4gICAgICAgICAgICBhcnIuc3BsaWNlKGksIDAsIHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYXJyYXkgcHJvcHNcbiAgICAgICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBtYXkgYmUgbmVlZGVkIHdoZW4gdXNpbmcgJy0nIGluIGFuIGFycmF5XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgaW5kZXg6IGkgfTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWRMaXN0ID0gYXJyLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkOiByZW1vdmVkTGlzdFswXSB9O1xuICAgIH0sXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBhcnJbaV07XG4gICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgbW92ZTogb2JqT3BzLm1vdmUsXG4gICAgY29weTogb2JqT3BzLmNvcHksXG4gICAgdGVzdDogb2JqT3BzLnRlc3QsXG4gICAgX2dldDogb2JqT3BzLl9nZXQsXG59O1xuLyoqXG4gKiBSZXRyaWV2ZXMgYSB2YWx1ZSBmcm9tIGEgSlNPTiBkb2N1bWVudCBieSBhIEpTT04gcG9pbnRlci5cbiAqIFJldHVybnMgdGhlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tXG4gKiBAcGFyYW0gcG9pbnRlciBhbiBlc2NhcGVkIEpTT04gcG9pbnRlclxuICogQHJldHVybiBUaGUgcmV0cmlldmVkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgcG9pbnRlcikge1xuICAgIGlmIChwb2ludGVyID09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICB2YXIgZ2V0T3JpZ2luYWxEZXN0aW5hdGlvbiA9IHsgb3A6IFwiX2dldFwiLCBwYXRoOiBwb2ludGVyIH07XG4gICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIGdldE9yaWdpbmFsRGVzdGluYXRpb24pO1xuICAgIHJldHVybiBnZXRPcmlnaW5hbERlc3RpbmF0aW9uLnZhbHVlO1xufVxuLyoqXG4gKiBBcHBseSBhIHNpbmdsZSBKU09OIFBhdGNoIE9wZXJhdGlvbiBvbiBhIEpTT04gZG9jdW1lbnQuXG4gKiBSZXR1cm5zIHRoZSB7bmV3RG9jdW1lbnQsIHJlc3VsdH0gb2YgdGhlIG9wZXJhdGlvbi5cbiAqIEl0IG1vZGlmaWVzIHRoZSBgZG9jdW1lbnRgIGFuZCBgb3BlcmF0aW9uYCBvYmplY3RzIC0gaXQgZ2V0cyB0aGUgdmFsdWVzIGJ5IHJlZmVyZW5jZS5cbiAqIElmIHlvdSB3b3VsZCBsaWtlIHRvIGF2b2lkIHRvdWNoaW5nIHlvdXIgdmFsdWVzLCBjbG9uZSB0aGVtOlxuICogYGpzb25wYXRjaC5hcHBseU9wZXJhdGlvbihkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUob3BlcmF0aW9uKSlgLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBhcHBseVxuICogQHBhcmFtIHZhbGlkYXRlT3BlcmF0aW9uIGBmYWxzZWAgaXMgd2l0aG91dCB2YWxpZGF0aW9uLCBgdHJ1ZWAgdG8gdXNlIGRlZmF1bHQganNvbnBhdGNoJ3MgdmFsaWRhdGlvbiwgb3IgeW91IGNhbiBwYXNzIGEgYHZhbGlkYXRlT3BlcmF0aW9uYCBjYWxsYmFjayB0byBiZSB1c2VkIGZvciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIG11dGF0ZURvY3VtZW50IFdoZXRoZXIgdG8gbXV0YXRlIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBvciBjbG9uZSBpdCBiZWZvcmUgYXBwbHlpbmdcbiAqIEBwYXJhbSBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zIFdoZXRoZXIgdG8gYmFuIG1vZGlmaWNhdGlvbnMgdG8gYF9fcHJvdG9fX2AsIGRlZmF1bHRzIHRvIGB0cnVlYC5cbiAqIEByZXR1cm4gYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIG9wZXJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIG9wZXJhdGlvbiwgdmFsaWRhdGVPcGVyYXRpb24gPSBmYWxzZSwgbXV0YXRlRG9jdW1lbnQgPSB0cnVlLCBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zID0gdHJ1ZSwgaW5kZXggPSAwKSB7XG4gICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVPcGVyYXRpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZU9wZXJhdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBvcGVyYXRpb24ucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0b3Iob3BlcmF0aW9uLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBST09UIE9QRVJBVElPTlMgKi9cbiAgICBpZiAob3BlcmF0aW9uLnBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgbGV0IHJldHVyblZhbHVlID0geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIikge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBvcGVyYXRpb24udmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInJlcGxhY2VcIikge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBvcGVyYXRpb24udmFsdWU7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7IC8vZG9jdW1lbnQgd2UgcmVtb3ZlZFxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJtb3ZlXCIgfHwgb3BlcmF0aW9uLm9wID09PSBcImNvcHlcIikge1xuICAgICAgICAgICAgLy8gaXQncyBhIG1vdmUgb3IgY29weSB0byByb290XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCBvcGVyYXRpb24uZnJvbSk7IC8vIGdldCB0aGUgdmFsdWUgYnkganNvbi1wb2ludGVyIGluIGBmcm9tYCBmaWVsZFxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJtb3ZlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBvcnQgcmVtb3ZlZCBpdGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnRlc3QgPSBfYXJlRXF1YWxzKGRvY3VtZW50LCBvcGVyYXRpb24udmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsIFwiVEVTVF9PUEVSQVRJT05fRkFJTEVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInJlbW92ZVwiKSB7XG4gICAgICAgICAgICAvLyBhIHJlbW92ZSBvbiByb290XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcIl9nZXRcIikge1xuICAgICAgICAgICAgb3BlcmF0aW9uLnZhbHVlID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBiYWQgb3BlcmF0aW9uICovXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMlwiLCBcIk9QRVJBVElPTl9PUF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gLyogRU5EIFJPT1QgT1BFUkFUSU9OUyAqL1xuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudCA9IF9kZWVwQ2xvbmUoZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBvcGVyYXRpb24ucGF0aCB8fCBcIlwiO1xuICAgICAgICBjb25zdCBrZXlzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gICAgICAgIGxldCBvYmogPSBkb2N1bWVudDtcbiAgICAgICAgbGV0IHQgPSAxOyAvL3NraXAgZW1wdHkgZWxlbWVudCAtIGh0dHA6Ly9qc3BlcmYuY29tL3RvLXNoaWZ0LW9yLW5vdC10by1zaGlmdFxuICAgICAgICBsZXQgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGxldCBleGlzdGluZ1BhdGhGcmFnbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGtleTtcbiAgICAgICAgbGV0IHZhbGlkYXRlRnVuY3Rpb247XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVPcGVyYXRpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uID0gdmFsaWRhdGVPcGVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uID0gdmFsaWRhdG9yO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW3RdO1xuICAgICAgICAgICAgaWYgKGtleSAmJiBrZXkuaW5kZXhPZihcIn5cIikgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSB1bmVzY2FwZVBhdGhDb21wb25lbnQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zICYmXG4gICAgICAgICAgICAgICAgKGtleSA9PSBcIl9fcHJvdG9fX1wiIHx8XG4gICAgICAgICAgICAgICAgICAgIChrZXkgPT0gXCJwcm90b3R5cGVcIiAmJiB0ID4gMCAmJiBrZXlzW3QgLSAxXSA9PSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJKU09OLVBhdGNoOiBtb2RpZnlpbmcgYF9fcHJvdG9fX2Agb3IgYGNvbnN0cnVjdG9yL3Byb3RvdHlwZWAgcHJvcCBpcyBiYW5uZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMsIGlmIHRoaXMgd2FzIG9uIHB1cnBvc2UsIHBsZWFzZSBzZXQgYGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnNgIGZsYWcgZmFsc2UgYW5kIHBhc3MgaXQgdG8gdGhpcyBmdW5jdGlvbi4gTW9yZSBpbmZvIGluIGZhc3QtanNvbi1wYXRjaCBSRUFETUVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBrZXlzLnNsaWNlKDAsIHQpLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBvcGVyYXRpb24ucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBleGlzdGluZ1BhdGhGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0Kys7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gb2JqLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiAhaXNJbnRlZ2VyKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIkV4cGVjdGVkIGFuIHVuc2lnbmVkIGJhc2UtMTAgaW50ZWdlciB2YWx1ZSwgbWFraW5nIHRoZSBuZXcgcmVmZXJlbmNlZCB2YWx1ZSB0aGUgYXJyYXkgZWxlbWVudCB3aXRoIHRoZSB6ZXJvLWJhc2VkIGluZGV4XCIsIFwiT1BFUkFUSU9OX1BBVEhfSUxMRUdBTF9BUlJBWV9JTkRFWFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gb25seSBwYXJzZSBrZXkgd2hlbiBpdCdzIGFuIGludGVnZXIgZm9yIGBhcnIucHJvcGAgdG8gd29ya1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0ludGVnZXIoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gfn5rZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQgPj0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiBvcGVyYXRpb24ub3AgPT09IFwiYWRkXCIgJiYga2V5ID4gb2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiVGhlIHNwZWNpZmllZCBpbmRleCBNVVNUIE5PVCBiZSBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXlcIiwgXCJPUEVSQVRJT05fVkFMVUVfT1VUX09GX0JPVU5EU1wiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBhcnJPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgXCJURVNUX09QRVJBVElPTl9GQUlMRURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBvYmpPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgXCJURVNUX09QRVJBVElPTl9GQUlMRURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSBrZXlzIGluIHRoZSBwYXRoLCBidXQgdGhlIG5leHQgdmFsdWUgaXNuJ3QgYSBub24tbnVsbCBvYmplY3QsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUgZXJyb3IgaW5zdGVhZCBvZiBpdGVyYXRpbmcgYWdhaW4uXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gJiYgdCA8IGxlbiAmJiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIkNhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiBhdCB0aGUgZGVzaXJlZCBwYXRoXCIsIFwiT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQXBwbHkgYSBmdWxsIEpTT04gUGF0Y2ggYXJyYXkgb24gYSBKU09OIGRvY3VtZW50LlxuICogUmV0dXJucyB0aGUge25ld0RvY3VtZW50LCByZXN1bHR9IG9mIHRoZSBwYXRjaC5cbiAqIEl0IG1vZGlmaWVzIHRoZSBgZG9jdW1lbnRgIG9iamVjdCBhbmQgYHBhdGNoYCAtIGl0IGdldHMgdGhlIHZhbHVlcyBieSByZWZlcmVuY2UuXG4gKiBJZiB5b3Ugd291bGQgbGlrZSB0byBhdm9pZCB0b3VjaGluZyB5b3VyIHZhbHVlcywgY2xvbmUgdGhlbTpcbiAqIGBqc29ucGF0Y2guYXBwbHlQYXRjaChkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUocGF0Y2gpKWAuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICogQHBhcmFtIHBhdGNoIFRoZSBwYXRjaCB0byBhcHBseVxuICogQHBhcmFtIHZhbGlkYXRlT3BlcmF0aW9uIGBmYWxzZWAgaXMgd2l0aG91dCB2YWxpZGF0aW9uLCBgdHJ1ZWAgdG8gdXNlIGRlZmF1bHQganNvbnBhdGNoJ3MgdmFsaWRhdGlvbiwgb3IgeW91IGNhbiBwYXNzIGEgYHZhbGlkYXRlT3BlcmF0aW9uYCBjYWxsYmFjayB0byBiZSB1c2VkIGZvciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIG11dGF0ZURvY3VtZW50IFdoZXRoZXIgdG8gbXV0YXRlIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBvciBjbG9uZSBpdCBiZWZvcmUgYXBwbHlpbmdcbiAqIEBwYXJhbSBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zIFdoZXRoZXIgdG8gYmFuIG1vZGlmaWNhdGlvbnMgdG8gYF9fcHJvdG9fX2AsIGRlZmF1bHRzIHRvIGB0cnVlYC5cbiAqIEByZXR1cm4gQW4gYXJyYXkgb2YgYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIHBhdGNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoKGRvY3VtZW50LCBwYXRjaCwgdmFsaWRhdGVPcGVyYXRpb24sIG11dGF0ZURvY3VtZW50ID0gdHJ1ZSwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyA9IHRydWUpIHtcbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGNoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheVwiLCBcIlNFUVVFTkNFX05PVF9BTl9BUlJBWVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgIGRvY3VtZW50ID0gX2RlZXBDbG9uZShkb2N1bWVudCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkocGF0Y2gubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gcGF0Y2gubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBwYXNzIG11dGF0ZURvY3VtZW50IGFyZ3VtZW50IGJlY2F1c2UgaWYgaXQgd2FzIHRydWUsIHdlIGFscmVhZHkgZGVlcCBjbG9uZWQgdGhlIG9iamVjdCwgd2UnbGwganVzdCBwYXNzIGB0cnVlYFxuICAgICAgICByZXN1bHRzW2ldID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHBhdGNoW2ldLCB2YWxpZGF0ZU9wZXJhdGlvbiwgdHJ1ZSwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucywgaSk7XG4gICAgICAgIGRvY3VtZW50ID0gcmVzdWx0c1tpXS5uZXdEb2N1bWVudDsgLy8gaW4gY2FzZSByb290IHdhcyByZXBsYWNlZFxuICAgIH1cbiAgICByZXN1bHRzLm5ld0RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG4vKipcbiAqIEFwcGx5IGEgc2luZ2xlIEpTT04gUGF0Y2ggT3BlcmF0aW9uIG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHVwZGF0ZWQgZG9jdW1lbnQuXG4gKiBTdWl0YWJsZSBhcyBhIHJlZHVjZXIuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICogQHBhcmFtIG9wZXJhdGlvbiBUaGUgb3BlcmF0aW9uIHRvIGFwcGx5XG4gKiBAcmV0dXJuIFRoZSB1cGRhdGVkIGRvY3VtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVJlZHVjZXIoZG9jdW1lbnQsIG9wZXJhdGlvbiwgaW5kZXgpIHtcbiAgICBjb25zdCBvcGVyYXRpb25SZXN1bHQgPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgb3BlcmF0aW9uKTtcbiAgICBpZiAob3BlcmF0aW9uUmVzdWx0LnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGZhaWxlZCB0ZXN0XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCBcIlRFU1RfT1BFUkFUSU9OX0ZBSUxFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIHJldHVybiBvcGVyYXRpb25SZXN1bHQubmV3RG9jdW1lbnQ7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHNpbmdsZSBvcGVyYXRpb24uIENhbGxlZCBmcm9tIGBqc29ucGF0Y2gudmFsaWRhdGVgLiBUaHJvd3MgYEpzb25QYXRjaEVycm9yYCBpbiBjYXNlIG9mIGFuIGVycm9yLlxuICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvbiAtIG9wZXJhdGlvbiBvYmplY3QgKHBhdGNoKVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2Ygb3BlcmF0aW9uIGluIHRoZSBzZXF1ZW5jZVxuICogQHBhcmFtIHtvYmplY3R9IFtkb2N1bWVudF0gLSBvYmplY3Qgd2hlcmUgdGhlIG9wZXJhdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBhcHBsaWVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V4aXN0aW5nUGF0aEZyYWdtZW50XSAtIGNvbWVzIGFsb25nIHdpdGggYGRvY3VtZW50YFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdG9yKG9wZXJhdGlvbiwgaW5kZXgsIGRvY3VtZW50LCBleGlzdGluZ1BhdGhGcmFnbWVudCkge1xuICAgIGlmICh0eXBlb2Ygb3BlcmF0aW9uICE9PSBcIm9iamVjdFwiIHx8XG4gICAgICAgIG9wZXJhdGlvbiA9PT0gbnVsbCB8fFxuICAgICAgICBBcnJheS5pc0FycmF5KG9wZXJhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGlzIG5vdCBhbiBvYmplY3RcIiwgXCJPUEVSQVRJT05fTk9UX0FOX09CSkVDVFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvYmpPcHNbb3BlcmF0aW9uLm9wXSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMlwiLCBcIk9QRVJBVElPTl9PUF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wZXJhdGlvbi5wYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIk9wZXJhdGlvbiBgcGF0aGAgcHJvcGVydHkgaXMgbm90IGEgc3RyaW5nXCIsIFwiT1BFUkFUSU9OX1BBVEhfSU5WQUxJRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5wYXRoLmluZGV4T2YoXCIvXCIpICE9PSAwICYmIG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gcGF0aHMgdGhhdCBhcmVuJ3QgZW1wdHkgc3RyaW5nIHNob3VsZCBzdGFydCB3aXRoIFwiL1wiXG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBwYXRoYCBwcm9wZXJ0eSBtdXN0IHN0YXJ0IHdpdGggXCIvXCInLCBcIk9QRVJBVElPTl9QQVRIX0lOVkFMSURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgob3BlcmF0aW9uLm9wID09PSBcIm1vdmVcIiB8fCBvcGVyYXRpb24ub3AgPT09IFwiY29weVwiKSAmJlxuICAgICAgICB0eXBlb2Ygb3BlcmF0aW9uLmZyb20gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGBmcm9tYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgbW92ZWAgYW5kIGBjb3B5YCBvcGVyYXRpb25zKVwiLCBcIk9QRVJBVElPTl9GUk9NX1JFUVVJUkVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIiB8fFxuICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwicmVwbGFjZVwiIHx8XG4gICAgICAgIG9wZXJhdGlvbi5vcCA9PT0gXCJ0ZXN0XCIpICYmXG4gICAgICAgIG9wZXJhdGlvbi52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIk9wZXJhdGlvbiBgdmFsdWVgIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBhZGRgLCBgcmVwbGFjZWAgYW5kIGB0ZXN0YCBvcGVyYXRpb25zKVwiLCBcIk9QRVJBVElPTl9WQUxVRV9SRVFVSVJFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcGVyYXRpb24ub3AgPT09IFwiYWRkXCIgfHxcbiAgICAgICAgb3BlcmF0aW9uLm9wID09PSBcInJlcGxhY2VcIiB8fFxuICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwidGVzdFwiKSAmJlxuICAgICAgICBoYXNVbmRlZmluZWQob3BlcmF0aW9uLnZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYHZhbHVlYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgYWRkYCwgYHJlcGxhY2VgIGFuZCBgdGVzdGAgb3BlcmF0aW9ucylcIiwgXCJPUEVSQVRJT05fVkFMVUVfQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PSBcImFkZFwiKSB7XG4gICAgICAgICAgICB2YXIgcGF0aExlbiA9IG9wZXJhdGlvbi5wYXRoLnNwbGl0KFwiL1wiKS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdQYXRoTGVuID0gZXhpc3RpbmdQYXRoRnJhZ21lbnQuc3BsaXQoXCIvXCIpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwYXRoTGVuICE9PSBleGlzdGluZ1BhdGhMZW4gKyAxICYmIHBhdGhMZW4gIT09IGV4aXN0aW5nUGF0aExlbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIkNhbm5vdCBwZXJmb3JtIGFuIGBhZGRgIG9wZXJhdGlvbiBhdCB0aGUgZGVzaXJlZCBwYXRoXCIsIFwiT1BFUkFUSU9OX1BBVEhfQ0FOTk9UX0FERFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInJlcGxhY2VcIiB8fFxuICAgICAgICAgICAgb3BlcmF0aW9uLm9wID09PSBcInJlbW92ZVwiIHx8XG4gICAgICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwiX2dldFwiKSB7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLnBhdGggIT09IGV4aXN0aW5nUGF0aEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBhdCBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdFwiLCBcIk9QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRVwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcIm1vdmVcIiB8fCBvcGVyYXRpb24ub3AgPT09IFwiY29weVwiKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBvcDogXCJfZ2V0XCIsXG4gICAgICAgICAgICAgICAgcGF0aDogb3BlcmF0aW9uLmZyb20sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB2YWxpZGF0ZShbZXhpc3RpbmdWYWx1ZV0sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lID09PSBcIk9QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRVwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBmcm9tIGEgcGF0aCB0aGF0IGRvZXMgbm90IGV4aXN0XCIsIFwiT1BFUkFUSU9OX0ZST01fVU5SRVNPTFZBQkxFXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgc2VxdWVuY2Ugb2Ygb3BlcmF0aW9ucy4gSWYgYGRvY3VtZW50YCBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHRoZSBzZXF1ZW5jZSBpcyBhZGRpdGlvbmFsbHkgdmFsaWRhdGVkIGFnYWluc3QgdGhlIG9iamVjdCBkb2N1bWVudC5cbiAqIElmIGVycm9yIGlzIGVuY291bnRlcmVkLCByZXR1cm5zIGEgSnNvblBhdGNoRXJyb3Igb2JqZWN0XG4gKiBAcGFyYW0gc2VxdWVuY2VcbiAqIEBwYXJhbSBkb2N1bWVudFxuICogQHJldHVybnMge0pzb25QYXRjaEVycm9yfHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHNlcXVlbmNlLCBkb2N1bWVudCwgZXh0ZXJuYWxWYWxpZGF0b3IpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJQYXRjaCBzZXF1ZW5jZSBtdXN0IGJlIGFuIGFycmF5XCIsIFwiU0VRVUVOQ0VfTk9UX0FOX0FSUkFZXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudCkge1xuICAgICAgICAgICAgLy9jbG9uZSBkb2N1bWVudCBhbmQgc2VxdWVuY2Ugc28gdGhhdCB3ZSBjYW4gc2FmZWx5IHRyeSBhcHBseWluZyBvcGVyYXRpb25zXG4gICAgICAgICAgICBhcHBseVBhdGNoKF9kZWVwQ2xvbmUoZG9jdW1lbnQpLCBfZGVlcENsb25lKHNlcXVlbmNlKSwgZXh0ZXJuYWxWYWxpZGF0b3IgfHwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvciA9IGV4dGVybmFsVmFsaWRhdG9yIHx8IHZhbGlkYXRvcjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvcihzZXF1ZW5jZVtpXSwgaSwgZG9jdW1lbnQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBKc29uUGF0Y2hFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Vwb2JlcmV6a2luL2Zhc3QtZGVlcC1lcXVhbFxuLy8gTUlUIExpY2Vuc2Vcbi8vIENvcHlyaWdodCAoYykgMjAxNyBFdmdlbnkgUG9iZXJlemtpblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuLy8gU09GVFdBUkUuXG5leHBvcnQgZnVuY3Rpb24gX2FyZUVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBhcnJBID0gQXJyYXkuaXNBcnJheShhKSwgYXJyQiA9IEFycmF5LmlzQXJyYXkoYiksIGksIGxlbmd0aCwga2V5O1xuICAgICAgICBpZiAoYXJyQSAmJiBhcnJCKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICAgICAgICAgIGlmICghX2FyZUVxdWFscyhhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyckEgIT0gYXJyQilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICAgICAgaWYgKCFiLmhhc093blByb3BlcnR5KGtleXNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFfYXJlRXF1YWxzKGFba2V5XSwgYltrZXldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compare: () => (/* binding */ compare),\n/* harmony export */   generate: () => (/* binding */ generate),\n/* harmony export */   observe: () => (/* binding */ observe),\n/* harmony export */   unobserve: () => (/* binding */ unobserve)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js\");\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js\");\n// @ts-nocheck\n// Inlined because of ESM import issues\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2013-2021 Joachim Wester\n * MIT license\n */\n\n\nvar beforeDict = new WeakMap();\nclass Mirror {\n    constructor(obj) {\n        Object.defineProperty(this, \"obj\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.obj = obj;\n    }\n}\nclass ObserverInfo {\n    constructor(callback, observer) {\n        Object.defineProperty(this, \"callback\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.callback = callback;\n        this.observer = observer;\n    }\n}\nfunction getMirror(obj) {\n    return beforeDict.get(obj);\n}\nfunction getObserverFromMirror(mirror, callback) {\n    return mirror.observers.get(callback);\n}\nfunction removeObserverFromMirror(mirror, observer) {\n    mirror.observers.delete(observer.callback);\n}\n/**\n * Detach an observer from an object\n */\nfunction unobserve(root, observer) {\n    observer.unobserve();\n}\n/**\n * Observes changes made to an object, which can then be retrieved using generate\n */\nfunction observe(obj, callback) {\n    var patches = [];\n    var observer;\n    var mirror = getMirror(obj);\n    if (!mirror) {\n        mirror = new Mirror(obj);\n        beforeDict.set(obj, mirror);\n    }\n    else {\n        const observerInfo = getObserverFromMirror(mirror, callback);\n        observer = observerInfo && observerInfo.observer;\n    }\n    if (observer) {\n        return observer;\n    }\n    observer = {};\n    mirror.value = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(obj);\n    if (callback) {\n        observer.callback = callback;\n        observer.next = null;\n        var dirtyCheck = () => {\n            generate(observer);\n        };\n        var fastCheck = () => {\n            clearTimeout(observer.next);\n            observer.next = setTimeout(dirtyCheck);\n        };\n        if (typeof window !== \"undefined\") {\n            //not Node\n            window.addEventListener(\"mouseup\", fastCheck);\n            window.addEventListener(\"keyup\", fastCheck);\n            window.addEventListener(\"mousedown\", fastCheck);\n            window.addEventListener(\"keydown\", fastCheck);\n            window.addEventListener(\"change\", fastCheck);\n        }\n    }\n    observer.patches = patches;\n    observer.object = obj;\n    observer.unobserve = () => {\n        generate(observer);\n        clearTimeout(observer.next);\n        removeObserverFromMirror(mirror, observer);\n        if (typeof window !== \"undefined\") {\n            window.removeEventListener(\"mouseup\", fastCheck);\n            window.removeEventListener(\"keyup\", fastCheck);\n            window.removeEventListener(\"mousedown\", fastCheck);\n            window.removeEventListener(\"keydown\", fastCheck);\n            window.removeEventListener(\"change\", fastCheck);\n        }\n    };\n    mirror.observers.set(callback, new ObserverInfo(callback, observer));\n    return observer;\n}\n/**\n * Generate an array of patches from an observer\n */\nfunction generate(observer, invertible = false) {\n    var mirror = beforeDict.get(observer.object);\n    _generate(mirror.value, observer.object, observer.patches, \"\", invertible);\n    if (observer.patches.length) {\n        (0,_core_js__WEBPACK_IMPORTED_MODULE_1__.applyPatch)(mirror.value, observer.patches);\n    }\n    var temp = observer.patches;\n    if (temp.length > 0) {\n        observer.patches = [];\n        if (observer.callback) {\n            observer.callback(temp);\n        }\n    }\n    return temp;\n}\n// Dirty check if obj is different from mirror, generate patches and update mirror\nfunction _generate(mirror, obj, patches, path, invertible) {\n    if (obj === mirror) {\n        return;\n    }\n    if (typeof obj.toJSON === \"function\") {\n        obj = obj.toJSON();\n    }\n    var newKeys = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._objectKeys)(obj);\n    var oldKeys = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._objectKeys)(mirror);\n    var changed = false;\n    var deleted = false;\n    //if ever \"move\" operation is implemented here, make sure this test runs OK: \"should not generate the same patch twice (move)\"\n    for (var t = oldKeys.length - 1; t >= 0; t--) {\n        var key = oldKeys[t];\n        var oldVal = mirror[key];\n        if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(obj, key) &&\n            !(obj[key] === undefined &&\n                oldVal !== undefined &&\n                Array.isArray(obj) === false)) {\n            var newVal = obj[key];\n            if (typeof oldVal == \"object\" &&\n                oldVal != null &&\n                typeof newVal == \"object\" &&\n                newVal != null &&\n                Array.isArray(oldVal) === Array.isArray(newVal)) {\n                _generate(oldVal, newVal, patches, path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), invertible);\n            }\n            else {\n                if (oldVal !== newVal) {\n                    changed = true;\n                    if (invertible) {\n                        patches.push({\n                            op: \"test\",\n                            path: path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),\n                            value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(oldVal),\n                        });\n                    }\n                    patches.push({\n                        op: \"replace\",\n                        path: path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),\n                        value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(newVal),\n                    });\n                }\n            }\n        }\n        else if (Array.isArray(mirror) === Array.isArray(obj)) {\n            if (invertible) {\n                patches.push({\n                    op: \"test\",\n                    path: path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),\n                    value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(oldVal),\n                });\n            }\n            patches.push({\n                op: \"remove\",\n                path: path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),\n            });\n            deleted = true; // property has been deleted\n        }\n        else {\n            if (invertible) {\n                patches.push({ op: \"test\", path, value: mirror });\n            }\n            patches.push({ op: \"replace\", path, value: obj });\n            changed = true;\n        }\n    }\n    if (!deleted && newKeys.length == oldKeys.length) {\n        return;\n    }\n    for (var t = 0; t < newKeys.length; t++) {\n        var key = newKeys[t];\n        if (!(0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(mirror, key) && obj[key] !== undefined) {\n            patches.push({\n                op: \"add\",\n                path: path + \"/\" + (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key),\n                value: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deepClone)(obj[key]),\n            });\n        }\n    }\n}\n/**\n * Create an array of patches from the differences in two objects\n */\nfunction compare(tree1, tree2, invertible = false) {\n    var patches = [];\n    _generate(tree1, tree2, patches, \"\", invertible);\n    return patches;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2Zhc3QtanNvbi1wYXRjaC9zcmMvZHVwbGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZGO0FBQ3REO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1REFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdEQUFXO0FBQzdCLGtCQUFrQix3REFBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0EsWUFBWSwyREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsZ0VBQW1CO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdFQUFtQjtBQUNsRSxtQ0FBbUMsdURBQVU7QUFDN0MseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnRUFBbUI7QUFDOUQsK0JBQStCLHVEQUFVO0FBQ3pDLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnRUFBbUI7QUFDMUQsMkJBQTJCLHVEQUFVO0FBQ3JDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0VBQW1CO0FBQ3RELGFBQWE7QUFDYiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlDQUFpQztBQUNoRTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBLGFBQWEsMkRBQWM7QUFDM0I7QUFDQTtBQUNBLG1DQUFtQyxnRUFBbUI7QUFDdEQsdUJBQXVCLHVEQUFVO0FBQ2pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcdGV4dHNwbGl0dGVyc1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx1dGlsc1xcZmFzdC1qc29uLXBhdGNoXFxzcmNcXGR1cGxleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtbm9jaGVja1xuLy8gSW5saW5lZCBiZWNhdXNlIG9mIEVTTSBpbXBvcnQgaXNzdWVzXG4vKiFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGFyY291bnRlci1KYWNrL0pTT04tUGF0Y2hcbiAqIChjKSAyMDEzLTIwMjEgSm9hY2hpbSBXZXN0ZXJcbiAqIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7IF9kZWVwQ2xvbmUsIF9vYmplY3RLZXlzLCBlc2NhcGVQYXRoQ29tcG9uZW50LCBoYXNPd25Qcm9wZXJ0eSwgfSBmcm9tIFwiLi9oZWxwZXJzLmpzXCI7XG5pbXBvcnQgeyBhcHBseVBhdGNoIH0gZnJvbSBcIi4vY29yZS5qc1wiO1xudmFyIGJlZm9yZURpY3QgPSBuZXcgV2Vha01hcCgpO1xuY2xhc3MgTWlycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib2JqXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9ic2VydmVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICB9XG59XG5jbGFzcyBPYnNlcnZlckluZm8ge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCBvYnNlcnZlcikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWxsYmFja1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvYnNlcnZlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRNaXJyb3Iob2JqKSB7XG4gICAgcmV0dXJuIGJlZm9yZURpY3QuZ2V0KG9iaik7XG59XG5mdW5jdGlvbiBnZXRPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBtaXJyb3Iub2JzZXJ2ZXJzLmdldChjYWxsYmFjayk7XG59XG5mdW5jdGlvbiByZW1vdmVPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBvYnNlcnZlcikge1xuICAgIG1pcnJvci5vYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyLmNhbGxiYWNrKTtcbn1cbi8qKlxuICogRGV0YWNoIGFuIG9ic2VydmVyIGZyb20gYW4gb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bm9ic2VydmUocm9vdCwgb2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoKTtcbn1cbi8qKlxuICogT2JzZXJ2ZXMgY2hhbmdlcyBtYWRlIHRvIGFuIG9iamVjdCwgd2hpY2ggY2FuIHRoZW4gYmUgcmV0cmlldmVkIHVzaW5nIGdlbmVyYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZlKG9iaiwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGF0Y2hlcyA9IFtdO1xuICAgIHZhciBvYnNlcnZlcjtcbiAgICB2YXIgbWlycm9yID0gZ2V0TWlycm9yKG9iaik7XG4gICAgaWYgKCFtaXJyb3IpIHtcbiAgICAgICAgbWlycm9yID0gbmV3IE1pcnJvcihvYmopO1xuICAgICAgICBiZWZvcmVEaWN0LnNldChvYmosIG1pcnJvcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBvYnNlcnZlckluZm8gPSBnZXRPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBjYWxsYmFjayk7XG4gICAgICAgIG9ic2VydmVyID0gb2JzZXJ2ZXJJbmZvICYmIG9ic2VydmVySW5mby5vYnNlcnZlcjtcbiAgICB9XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG4gICAgb2JzZXJ2ZXIgPSB7fTtcbiAgICBtaXJyb3IudmFsdWUgPSBfZGVlcENsb25lKG9iaik7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIG9ic2VydmVyLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIG9ic2VydmVyLm5leHQgPSBudWxsO1xuICAgICAgICB2YXIgZGlydHlDaGVjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGdlbmVyYXRlKG9ic2VydmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZhc3RDaGVjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChvYnNlcnZlci5uZXh0KTtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgPSBzZXRUaW1lb3V0KGRpcnR5Q2hlY2spO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy9ub3QgTm9kZVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmYXN0Q2hlY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9ic2VydmVyLnBhdGNoZXMgPSBwYXRjaGVzO1xuICAgIG9ic2VydmVyLm9iamVjdCA9IG9iajtcbiAgICBvYnNlcnZlci51bm9ic2VydmUgPSAoKSA9PiB7XG4gICAgICAgIGdlbmVyYXRlKG9ic2VydmVyKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KG9ic2VydmVyLm5leHQpO1xuICAgICAgICByZW1vdmVPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBvYnNlcnZlcik7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZhc3RDaGVjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIG1pcnJvci5vYnNlcnZlcnMuc2V0KGNhbGxiYWNrLCBuZXcgT2JzZXJ2ZXJJbmZvKGNhbGxiYWNrLCBvYnNlcnZlcikpO1xuICAgIHJldHVybiBvYnNlcnZlcjtcbn1cbi8qKlxuICogR2VuZXJhdGUgYW4gYXJyYXkgb2YgcGF0Y2hlcyBmcm9tIGFuIG9ic2VydmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZShvYnNlcnZlciwgaW52ZXJ0aWJsZSA9IGZhbHNlKSB7XG4gICAgdmFyIG1pcnJvciA9IGJlZm9yZURpY3QuZ2V0KG9ic2VydmVyLm9iamVjdCk7XG4gICAgX2dlbmVyYXRlKG1pcnJvci52YWx1ZSwgb2JzZXJ2ZXIub2JqZWN0LCBvYnNlcnZlci5wYXRjaGVzLCBcIlwiLCBpbnZlcnRpYmxlKTtcbiAgICBpZiAob2JzZXJ2ZXIucGF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgYXBwbHlQYXRjaChtaXJyb3IudmFsdWUsIG9ic2VydmVyLnBhdGNoZXMpO1xuICAgIH1cbiAgICB2YXIgdGVtcCA9IG9ic2VydmVyLnBhdGNoZXM7XG4gICAgaWYgKHRlbXAubGVuZ3RoID4gMCkge1xuICAgICAgICBvYnNlcnZlci5wYXRjaGVzID0gW107XG4gICAgICAgIGlmIChvYnNlcnZlci5jYWxsYmFjaykge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuY2FsbGJhY2sodGVtcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRlbXA7XG59XG4vLyBEaXJ0eSBjaGVjayBpZiBvYmogaXMgZGlmZmVyZW50IGZyb20gbWlycm9yLCBnZW5lcmF0ZSBwYXRjaGVzIGFuZCB1cGRhdGUgbWlycm9yXG5mdW5jdGlvbiBfZ2VuZXJhdGUobWlycm9yLCBvYmosIHBhdGNoZXMsIHBhdGgsIGludmVydGlibGUpIHtcbiAgICBpZiAob2JqID09PSBtaXJyb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iai50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgfVxuICAgIHZhciBuZXdLZXlzID0gX29iamVjdEtleXMob2JqKTtcbiAgICB2YXIgb2xkS2V5cyA9IF9vYmplY3RLZXlzKG1pcnJvcik7XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgZGVsZXRlZCA9IGZhbHNlO1xuICAgIC8vaWYgZXZlciBcIm1vdmVcIiBvcGVyYXRpb24gaXMgaW1wbGVtZW50ZWQgaGVyZSwgbWFrZSBzdXJlIHRoaXMgdGVzdCBydW5zIE9LOiBcInNob3VsZCBub3QgZ2VuZXJhdGUgdGhlIHNhbWUgcGF0Y2ggdHdpY2UgKG1vdmUpXCJcbiAgICBmb3IgKHZhciB0ID0gb2xkS2V5cy5sZW5ndGggLSAxOyB0ID49IDA7IHQtLSkge1xuICAgICAgICB2YXIga2V5ID0gb2xkS2V5c1t0XTtcbiAgICAgICAgdmFyIG9sZFZhbCA9IG1pcnJvcltrZXldO1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCBrZXkpICYmXG4gICAgICAgICAgICAhKG9ialtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvbGRWYWwgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkob2JqKSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICB2YXIgbmV3VmFsID0gb2JqW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9sZFZhbCA9PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgb2xkVmFsICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgbmV3VmFsID09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBuZXdWYWwgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkob2xkVmFsKSA9PT0gQXJyYXkuaXNBcnJheShuZXdWYWwpKSB7XG4gICAgICAgICAgICAgICAgX2dlbmVyYXRlKG9sZFZhbCwgbmV3VmFsLCBwYXRjaGVzLCBwYXRoICsgXCIvXCIgKyBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSksIGludmVydGlibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFZhbCAhPT0gbmV3VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW52ZXJ0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJ0ZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogcGF0aCArIFwiL1wiICsgZXNjYXBlUGF0aENvbXBvbmVudChrZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfZGVlcENsb25lKG9sZFZhbCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogcGF0aCArIFwiL1wiICsgZXNjYXBlUGF0aENvbXBvbmVudChrZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF9kZWVwQ2xvbmUobmV3VmFsKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobWlycm9yKSA9PT0gQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICBpZiAoaW52ZXJ0aWJsZSkge1xuICAgICAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBcInRlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcGF0aCArIFwiL1wiICsgZXNjYXBlUGF0aENvbXBvbmVudChrZXkpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX2RlZXBDbG9uZShvbGRWYWwpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcDogXCJyZW1vdmVcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoICsgXCIvXCIgKyBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlOyAvLyBwcm9wZXJ0eSBoYXMgYmVlbiBkZWxldGVkXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW52ZXJ0aWJsZSkge1xuICAgICAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7IG9wOiBcInRlc3RcIiwgcGF0aCwgdmFsdWU6IG1pcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7IG9wOiBcInJlcGxhY2VcIiwgcGF0aCwgdmFsdWU6IG9iaiB9KTtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghZGVsZXRlZCAmJiBuZXdLZXlzLmxlbmd0aCA9PSBvbGRLZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbmV3S2V5cy5sZW5ndGg7IHQrKykge1xuICAgICAgICB2YXIga2V5ID0gbmV3S2V5c1t0XTtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShtaXJyb3IsIGtleSkgJiYgb2JqW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoICsgXCIvXCIgKyBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IF9kZWVwQ2xvbmUob2JqW2tleV0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhbiBhcnJheSBvZiBwYXRjaGVzIGZyb20gdGhlIGRpZmZlcmVuY2VzIGluIHR3byBvYmplY3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlKHRyZWUxLCB0cmVlMiwgaW52ZXJ0aWJsZSA9IGZhbHNlKSB7XG4gICAgdmFyIHBhdGNoZXMgPSBbXTtcbiAgICBfZ2VuZXJhdGUodHJlZTEsIHRyZWUyLCBwYXRjaGVzLCBcIlwiLCBpbnZlcnRpYmxlKTtcbiAgICByZXR1cm4gcGF0Y2hlcztcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PatchError: () => (/* binding */ PatchError),\n/* harmony export */   _deepClone: () => (/* binding */ _deepClone),\n/* harmony export */   _getPathRecursive: () => (/* binding */ _getPathRecursive),\n/* harmony export */   _objectKeys: () => (/* binding */ _objectKeys),\n/* harmony export */   escapePathComponent: () => (/* binding */ escapePathComponent),\n/* harmony export */   getPath: () => (/* binding */ getPath),\n/* harmony export */   hasOwnProperty: () => (/* binding */ hasOwnProperty),\n/* harmony export */   hasUndefined: () => (/* binding */ hasUndefined),\n/* harmony export */   isInteger: () => (/* binding */ isInteger),\n/* harmony export */   unescapePathComponent: () => (/* binding */ unescapePathComponent)\n/* harmony export */ });\n// @ts-nocheck\n// Inlined because of ESM import issues\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2017-2022 Joachim Wester\n * MIT licensed\n */\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(obj, key) {\n    return _hasOwnProperty.call(obj, key);\n}\nfunction _objectKeys(obj) {\n    if (Array.isArray(obj)) {\n        const keys = new Array(obj.length);\n        for (let k = 0; k < keys.length; k++) {\n            keys[k] = \"\" + k;\n        }\n        return keys;\n    }\n    if (Object.keys) {\n        return Object.keys(obj);\n    }\n    let keys = [];\n    for (let i in obj) {\n        if (hasOwnProperty(obj, i)) {\n            keys.push(i);\n        }\n    }\n    return keys;\n}\n/**\n * Deeply clone the object.\n * https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\n * @param  {any} obj value to clone\n * @return {any} cloned obj\n */\nfunction _deepClone(obj) {\n    switch (typeof obj) {\n        case \"object\":\n            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\n        case \"undefined\":\n            return null; //this is how JSON.stringify behaves for array items\n        default:\n            return obj; //no need to clone primitives\n    }\n}\n//3x faster than cached /^\\d+$/.test(str)\nfunction isInteger(str) {\n    let i = 0;\n    const len = str.length;\n    let charCode;\n    while (i < len) {\n        charCode = str.charCodeAt(i);\n        if (charCode >= 48 && charCode <= 57) {\n            i++;\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Escapes a json pointer path\n * @param path The raw pointer\n * @return the Escaped path\n */\nfunction escapePathComponent(path) {\n    if (path.indexOf(\"/\") === -1 && path.indexOf(\"~\") === -1)\n        return path;\n    return path.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\n/**\n * Unescapes a json pointer path\n * @param path The escaped pointer\n * @return The unescaped path\n */\nfunction unescapePathComponent(path) {\n    return path.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nfunction _getPathRecursive(root, obj) {\n    let found;\n    for (let key in root) {\n        if (hasOwnProperty(root, key)) {\n            if (root[key] === obj) {\n                return escapePathComponent(key) + \"/\";\n            }\n            else if (typeof root[key] === \"object\") {\n                found = _getPathRecursive(root[key], obj);\n                if (found != \"\") {\n                    return escapePathComponent(key) + \"/\" + found;\n                }\n            }\n        }\n    }\n    return \"\";\n}\nfunction getPath(root, obj) {\n    if (root === obj) {\n        return \"/\";\n    }\n    const path = _getPathRecursive(root, obj);\n    if (path === \"\") {\n        throw new Error(\"Object not found in root\");\n    }\n    return `/${path}`;\n}\n/**\n * Recursively checks whether an object has any undefined values inside.\n */\nfunction hasUndefined(obj) {\n    if (obj === undefined) {\n        return true;\n    }\n    if (obj) {\n        if (Array.isArray(obj)) {\n            for (let i = 0, len = obj.length; i < len; i++) {\n                if (hasUndefined(obj[i])) {\n                    return true;\n                }\n            }\n        }\n        else if (typeof obj === \"object\") {\n            const objKeys = _objectKeys(obj);\n            const objKeysLength = objKeys.length;\n            for (var i = 0; i < objKeysLength; i++) {\n                if (hasUndefined(obj[objKeys[i]])) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nfunction patchErrorMessageFormatter(message, args) {\n    const messageParts = [message];\n    for (const key in args) {\n        const value = typeof args[key] === \"object\"\n            ? JSON.stringify(args[key], null, 2)\n            : args[key]; // pretty print\n        if (typeof value !== \"undefined\") {\n            messageParts.push(`${key}: ${value}`);\n        }\n    }\n    return messageParts.join(\"\\n\");\n}\nclass PatchError extends Error {\n    constructor(message, name, index, operation, tree) {\n        super(patchErrorMessageFormatter(message, { name, index, operation, tree }));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: name\n        });\n        Object.defineProperty(this, \"index\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: index\n        });\n        Object.defineProperty(this, \"operation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: operation\n        });\n        Object.defineProperty(this, \"tree\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: tree\n        });\n        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359\n        this.message = patchErrorMessageFormatter(message, {\n            name,\n            index,\n            operation,\n            tree,\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2Zhc3QtanNvbi1wYXRjaC9zcmMvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQjtBQUNPO0FBQ1A7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlDQUFpQyxJQUFJLElBQUksTUFBTTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvREFBb0QsOEJBQThCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXHRleHRzcGxpdHRlcnNcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdXRpbHNcXGZhc3QtanNvbi1wYXRjaFxcc3JjXFxoZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1ub2NoZWNrXG4vLyBJbmxpbmVkIGJlY2F1c2Ugb2YgRVNNIGltcG9ydCBpc3N1ZXNcbi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL1N0YXJjb3VudGVyLUphY2svSlNPTi1QYXRjaFxuICogKGMpIDIwMTctMjAyMiBKb2FjaGltIFdlc3RlclxuICogTUlUIGxpY2Vuc2VkXG4gKi9cbmNvbnN0IF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5leHBvcnQgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gX2hhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9vYmplY3RLZXlzKG9iaikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IG5ldyBBcnJheShvYmoubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBrZXlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBrZXlzW2tdID0gXCJcIiArIGs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcbiAgICB9XG4gICAgbGV0IGtleXMgPSBbXTtcbiAgICBmb3IgKGxldCBpIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCBpKSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuLyoqXG4gKiBEZWVwbHkgY2xvbmUgdGhlIG9iamVjdC5cbiAqIGh0dHBzOi8vanNwZXJmLmNvbS9kZWVwLWNvcHktdnMtanNvbi1zdHJpbmdpZnktanNvbi1wYXJzZS8yNSAocmVjdXJzaXZlRGVlcENvcHkpXG4gKiBAcGFyYW0gIHthbnl9IG9iaiB2YWx1ZSB0byBjbG9uZVxuICogQHJldHVybiB7YW55fSBjbG9uZWQgb2JqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVlcENsb25lKG9iaikge1xuICAgIHN3aXRjaCAodHlwZW9mIG9iaikge1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTsgLy9GYXN0ZXIgdGhhbiBFUzUgY2xvbmUgLSBodHRwOi8vanNwZXJmLmNvbS9kZWVwLWNsb25pbmctb2Ytb2JqZWN0cy81XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvL3RoaXMgaXMgaG93IEpTT04uc3RyaW5naWZ5IGJlaGF2ZXMgZm9yIGFycmF5IGl0ZW1zXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gb2JqOyAvL25vIG5lZWQgdG8gY2xvbmUgcHJpbWl0aXZlc1xuICAgIH1cbn1cbi8vM3ggZmFzdGVyIHRoYW4gY2FjaGVkIC9eXFxkKyQvLnRlc3Qoc3RyKVxuZXhwb3J0IGZ1bmN0aW9uIGlzSW50ZWdlcihzdHIpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcbiAgICBsZXQgY2hhckNvZGU7XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBFc2NhcGVzIGEganNvbiBwb2ludGVyIHBhdGhcbiAqIEBwYXJhbSBwYXRoIFRoZSByYXcgcG9pbnRlclxuICogQHJldHVybiB0aGUgRXNjYXBlZCBwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVQYXRoQ29tcG9uZW50KHBhdGgpIHtcbiAgICBpZiAocGF0aC5pbmRleE9mKFwiL1wiKSA9PT0gLTEgJiYgcGF0aC5pbmRleE9mKFwiflwiKSA9PT0gLTEpXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbn1cbi8qKlxuICogVW5lc2NhcGVzIGEganNvbiBwb2ludGVyIHBhdGhcbiAqIEBwYXJhbSBwYXRoIFRoZSBlc2NhcGVkIHBvaW50ZXJcbiAqIEByZXR1cm4gVGhlIHVuZXNjYXBlZCBwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmVzY2FwZVBhdGhDb21wb25lbnQocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL34xL2csIFwiL1wiKS5yZXBsYWNlKC9+MC9nLCBcIn5cIik7XG59XG5leHBvcnQgZnVuY3Rpb24gX2dldFBhdGhSZWN1cnNpdmUocm9vdCwgb2JqKSB7XG4gICAgbGV0IGZvdW5kO1xuICAgIGZvciAobGV0IGtleSBpbiByb290KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShyb290LCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAocm9vdFtrZXldID09PSBvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlUGF0aENvbXBvbmVudChrZXkpICsgXCIvXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygcm9vdFtrZXldID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290W2tleV0sIG9iaik7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kICE9IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSArIFwiL1wiICsgZm91bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhdGgocm9vdCwgb2JqKSB7XG4gICAgaWYgKHJvb3QgPT09IG9iaikge1xuICAgICAgICByZXR1cm4gXCIvXCI7XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopO1xuICAgIGlmIChwYXRoID09PSBcIlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdCBub3QgZm91bmQgaW4gcm9vdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGAvJHtwYXRofWA7XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGNoZWNrcyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYW55IHVuZGVmaW5lZCB2YWx1ZXMgaW5zaWRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzVW5kZWZpbmVkKG9iaikge1xuICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1VuZGVmaW5lZChvYmpbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb25zdCBvYmpLZXlzID0gX29iamVjdEtleXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IG9iaktleXNMZW5ndGggPSBvYmpLZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1VuZGVmaW5lZChvYmpbb2JqS2V5c1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwYXRjaEVycm9yTWVzc2FnZUZvcm1hdHRlcihtZXNzYWdlLCBhcmdzKSB7XG4gICAgY29uc3QgbWVzc2FnZVBhcnRzID0gW21lc3NhZ2VdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgYXJnc1trZXldID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KGFyZ3Nba2V5XSwgbnVsbCwgMilcbiAgICAgICAgICAgIDogYXJnc1trZXldOyAvLyBwcmV0dHkgcHJpbnRcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goYCR7a2V5fTogJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZVBhcnRzLmpvaW4oXCJcXG5cIik7XG59XG5leHBvcnQgY2xhc3MgUGF0Y2hFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBuYW1lLCBpbmRleCwgb3BlcmF0aW9uLCB0cmVlKSB7XG4gICAgICAgIHN1cGVyKHBhdGNoRXJyb3JNZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UsIHsgbmFtZSwgaW5kZXgsIG9wZXJhdGlvbiwgdHJlZSB9KSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluZGV4XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBpbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3BlcmF0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBvcGVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyZWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRyZWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7IC8vIHJlc3RvcmUgcHJvdG90eXBlIGNoYWluLCBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ4MzQyMzU5XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHBhdGNoRXJyb3JNZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgICAgIHRyZWUsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/json.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/json.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseJsonMarkdown: () => (/* binding */ parseJsonMarkdown),\n/* harmony export */   parsePartialJson: () => (/* binding */ parsePartialJson)\n/* harmony export */ });\nfunction parseJsonMarkdown(s, parser = parsePartialJson) {\n    // eslint-disable-next-line no-param-reassign\n    s = s.trim();\n    const match = /```(json)?(.*)```/s.exec(s);\n    if (!match) {\n        return parser(s);\n    }\n    else {\n        return parser(match[2]);\n    }\n}\n// Adapted from https://github.com/KillianLucas/open-interpreter/blob/main/interpreter/core/llm/utils/parse_partial_json.py\n// MIT License\nfunction parsePartialJson(s) {\n    // If the input is undefined, return null to indicate failure.\n    if (typeof s === \"undefined\") {\n        return null;\n    }\n    // Attempt to parse the string as-is.\n    try {\n        return JSON.parse(s);\n    }\n    catch (error) {\n        // Pass\n    }\n    // Initialize variables.\n    let new_s = \"\";\n    const stack = [];\n    let isInsideString = false;\n    let escaped = false;\n    // Process each character in the string one at a time.\n    for (let char of s) {\n        if (isInsideString) {\n            if (char === '\"' && !escaped) {\n                isInsideString = false;\n            }\n            else if (char === \"\\n\" && !escaped) {\n                char = \"\\\\n\"; // Replace the newline character with the escape sequence.\n            }\n            else if (char === \"\\\\\") {\n                escaped = !escaped;\n            }\n            else {\n                escaped = false;\n            }\n        }\n        else {\n            if (char === '\"') {\n                isInsideString = true;\n                escaped = false;\n            }\n            else if (char === \"{\") {\n                stack.push(\"}\");\n            }\n            else if (char === \"[\") {\n                stack.push(\"]\");\n            }\n            else if (char === \"}\" || char === \"]\") {\n                if (stack && stack[stack.length - 1] === char) {\n                    stack.pop();\n                }\n                else {\n                    // Mismatched closing character; the input is malformed.\n                    return null;\n                }\n            }\n        }\n        // Append the processed character to the new string.\n        new_s += char;\n    }\n    // If we're still inside a string at the end of processing,\n    // we need to close the string.\n    if (isInsideString) {\n        new_s += '\"';\n    }\n    // Close any remaining open structures in the reverse order that they were opened.\n    for (let i = stack.length - 1; i >= 0; i -= 1) {\n        new_s += stack[i];\n    }\n    // Attempt to parse the modified string as JSON.\n    try {\n        return JSON.parse(new_s);\n    }\n    catch (error) {\n        // If we still can't parse the string as JSON, return null to indicate failure.\n        return null;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2pzb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcdGV4dHNwbGl0dGVyc1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx1dGlsc1xcanNvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gcGFyc2VKc29uTWFya2Rvd24ocywgcGFyc2VyID0gcGFyc2VQYXJ0aWFsSnNvbikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHMgPSBzLnRyaW0oKTtcbiAgICBjb25zdCBtYXRjaCA9IC9gYGAoanNvbik/KC4qKWBgYC9zLmV4ZWMocyk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gcGFyc2VyKHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlcihtYXRjaFsyXSk7XG4gICAgfVxufVxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9LaWxsaWFuTHVjYXMvb3Blbi1pbnRlcnByZXRlci9ibG9iL21haW4vaW50ZXJwcmV0ZXIvY29yZS9sbG0vdXRpbHMvcGFyc2VfcGFydGlhbF9qc29uLnB5XG4vLyBNSVQgTGljZW5zZVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGFydGlhbEpzb24ocykge1xuICAgIC8vIElmIHRoZSBpbnB1dCBpcyB1bmRlZmluZWQsIHJldHVybiBudWxsIHRvIGluZGljYXRlIGZhaWx1cmUuXG4gICAgaWYgKHR5cGVvZiBzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uocyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBQYXNzXG4gICAgfVxuICAgIC8vIEluaXRpYWxpemUgdmFyaWFibGVzLlxuICAgIGxldCBuZXdfcyA9IFwiXCI7XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICBsZXQgaXNJbnNpZGVTdHJpbmcgPSBmYWxzZTtcbiAgICBsZXQgZXNjYXBlZCA9IGZhbHNlO1xuICAgIC8vIFByb2Nlc3MgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZyBvbmUgYXQgYSB0aW1lLlxuICAgIGZvciAobGV0IGNoYXIgb2Ygcykge1xuICAgICAgICBpZiAoaXNJbnNpZGVTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnXCInICYmICFlc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgaXNJbnNpZGVTdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IFwiXFxuXCIgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICBjaGFyID0gXCJcXFxcblwiOyAvLyBSZXBsYWNlIHRoZSBuZXdsaW5lIGNoYXJhY3RlciB3aXRoIHRoZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgaXNJbnNpZGVTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChcIn1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goXCJdXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gXCJ9XCIgfHwgY2hhciA9PT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2sgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IGNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBNaXNtYXRjaGVkIGNsb3NpbmcgY2hhcmFjdGVyOyB0aGUgaW5wdXQgaXMgbWFsZm9ybWVkLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwZW5kIHRoZSBwcm9jZXNzZWQgY2hhcmFjdGVyIHRvIHRoZSBuZXcgc3RyaW5nLlxuICAgICAgICBuZXdfcyArPSBjaGFyO1xuICAgIH1cbiAgICAvLyBJZiB3ZSdyZSBzdGlsbCBpbnNpZGUgYSBzdHJpbmcgYXQgdGhlIGVuZCBvZiBwcm9jZXNzaW5nLFxuICAgIC8vIHdlIG5lZWQgdG8gY2xvc2UgdGhlIHN0cmluZy5cbiAgICBpZiAoaXNJbnNpZGVTdHJpbmcpIHtcbiAgICAgICAgbmV3X3MgKz0gJ1wiJztcbiAgICB9XG4gICAgLy8gQ2xvc2UgYW55IHJlbWFpbmluZyBvcGVuIHN0cnVjdHVyZXMgaW4gdGhlIHJldmVyc2Ugb3JkZXIgdGhhdCB0aGV5IHdlcmUgb3BlbmVkLlxuICAgIGZvciAobGV0IGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBuZXdfcyArPSBzdGFja1tpXTtcbiAgICB9XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSB0aGUgbW9kaWZpZWQgc3RyaW5nIGFzIEpTT04uXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UobmV3X3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgd2Ugc3RpbGwgY2FuJ3QgcGFyc2UgdGhlIHN0cmluZyBhcyBKU09OLCByZXR1cm4gbnVsbCB0byBpbmRpY2F0ZSBmYWlsdXJlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/json.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/signal.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/signal.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   raceWithSignal: () => (/* binding */ raceWithSignal)\n/* harmony export */ });\nasync function raceWithSignal(promise, signal) {\n    if (signal === undefined) {\n        return promise;\n    }\n    let listener;\n    return Promise.race([\n        promise.catch((err) => {\n            if (!signal?.aborted) {\n                throw err;\n            }\n            else {\n                return undefined;\n            }\n        }),\n        new Promise((_, reject) => {\n            listener = () => {\n                reject(new Error(\"Aborted\"));\n            };\n            signal.addEventListener(\"abort\", listener);\n            // Must be here inside the promise to avoid a race condition\n            if (signal.aborted) {\n                reject(new Error(\"Aborted\"));\n            }\n        }),\n    ]).finally(() => signal.removeEventListener(\"abort\", listener));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL3NpZ25hbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXN1c1xcT25lRHJpdmVcXERvY3VtZW50c1xcRGVza3RvcFxcTXkgSW5maW5pdGUgTG9vcFxcSW5maW5pdGVfbG9vcFxcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFx0ZXh0c3BsaXR0ZXJzXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXGNvcmVcXGRpc3RcXHV0aWxzXFxzaWduYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJhY2VXaXRoU2lnbmFsKHByb21pc2UsIHNpZ25hbCkge1xuICAgIGlmIChzaWduYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgbGV0IGxpc3RlbmVyO1xuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgICBwcm9taXNlLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmICghc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJBYm9ydGVkXCIpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIC8vIE11c3QgYmUgaGVyZSBpbnNpZGUgdGhlIHByb21pc2UgdG8gYXZvaWQgYSByYWNlIGNvbmRpdGlvblxuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFib3J0ZWRcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICBdKS5maW5hbGx5KCgpID0+IHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbGlzdGVuZXIpKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/signal.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/stream.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/stream.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncGeneratorWithSetup: () => (/* binding */ AsyncGeneratorWithSetup),\n/* harmony export */   IterableReadableStream: () => (/* binding */ IterableReadableStream),\n/* harmony export */   atee: () => (/* binding */ atee),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   pipeGeneratorWithSetup: () => (/* binding */ pipeGeneratorWithSetup)\n/* harmony export */ });\n/* harmony import */ var _singletons_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../singletons/index.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/singletons/index.js\");\n/* harmony import */ var _signal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./signal.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/signal.js\");\n\n\n/*\n * Support async iterator syntax for ReadableStreams in all environments.\n * Source: https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nclass IterableReadableStream extends ReadableStream {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"reader\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    ensureReader() {\n        if (!this.reader) {\n            this.reader = this.getReader();\n        }\n    }\n    async next() {\n        this.ensureReader();\n        try {\n            const result = await this.reader.read();\n            if (result.done) {\n                this.reader.releaseLock(); // release lock when stream becomes closed\n                return {\n                    done: true,\n                    value: undefined,\n                };\n            }\n            else {\n                return {\n                    done: false,\n                    value: result.value,\n                };\n            }\n        }\n        catch (e) {\n            this.reader.releaseLock(); // release lock when stream becomes errored\n            throw e;\n        }\n    }\n    async return() {\n        this.ensureReader();\n        // If wrapped in a Node stream, cancel is already called.\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        return { done: true, value: undefined };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async throw(e) {\n        this.ensureReader();\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        throw e;\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Not present in Node 18 types, required in latest Node 22\n    async [Symbol.asyncDispose]() {\n        await this.return();\n    }\n    static fromReadableStream(stream) {\n        // From https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#reading_the_stream\n        const reader = stream.getReader();\n        return new IterableReadableStream({\n            start(controller) {\n                return pump();\n                function pump() {\n                    return reader.read().then(({ done, value }) => {\n                        // When no more data needs to be consumed, close the stream\n                        if (done) {\n                            controller.close();\n                            return;\n                        }\n                        // Enqueue the next data chunk into our target stream\n                        controller.enqueue(value);\n                        return pump();\n                    });\n                }\n            },\n            cancel() {\n                reader.releaseLock();\n            },\n        });\n    }\n    static fromAsyncGenerator(generator) {\n        return new IterableReadableStream({\n            async pull(controller) {\n                const { value, done } = await generator.next();\n                // When no more data needs to be consumed, close the stream\n                if (done) {\n                    controller.close();\n                }\n                // Fix: `else if (value)` will hang the streaming when nullish value (e.g. empty string) is pulled\n                controller.enqueue(value);\n            },\n            async cancel(reason) {\n                await generator.return(reason);\n            },\n        });\n    }\n}\nfunction atee(iter, length = 2) {\n    const buffers = Array.from({ length }, () => []);\n    return buffers.map(async function* makeIter(buffer) {\n        while (true) {\n            if (buffer.length === 0) {\n                const result = await iter.next();\n                for (const buffer of buffers) {\n                    buffer.push(result);\n                }\n            }\n            else if (buffer[0].done) {\n                return;\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                yield buffer.shift().value;\n            }\n        }\n    });\n}\nfunction concat(first, second) {\n    if (Array.isArray(first) && Array.isArray(second)) {\n        return first.concat(second);\n    }\n    else if (typeof first === \"string\" && typeof second === \"string\") {\n        return (first + second);\n    }\n    else if (typeof first === \"number\" && typeof second === \"number\") {\n        return (first + second);\n    }\n    else if (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    \"concat\" in first &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        typeof first.concat === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return first.concat(second);\n    }\n    else if (typeof first === \"object\" && typeof second === \"object\") {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const chunk = { ...first };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        for (const [key, value] of Object.entries(second)) {\n            if (key in chunk && !Array.isArray(chunk[key])) {\n                chunk[key] = concat(chunk[key], value);\n            }\n            else {\n                chunk[key] = value;\n            }\n        }\n        return chunk;\n    }\n    else {\n        throw new Error(`Cannot concat ${typeof first} and ${typeof second}`);\n    }\n}\nclass AsyncGeneratorWithSetup {\n    constructor(params) {\n        Object.defineProperty(this, \"generator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"setup\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"signal\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"firstResult\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"firstResultUsed\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.generator = params.generator;\n        this.config = params.config;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.signal = params.signal ?? this.config?.signal;\n        // setup is a promise that resolves only after the first iterator value\n        // is available. this is useful when setup of several piped generators\n        // needs to happen in logical order, ie. in the order in which input to\n        // to each generator is available.\n        this.setup = new Promise((resolve, reject) => {\n            void _singletons_index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.runWithConfig(params.config, async () => {\n                this.firstResult = params.generator.next();\n                if (params.startSetup) {\n                    this.firstResult.then(params.startSetup).then(resolve, reject);\n                }\n                else {\n                    this.firstResult.then((_result) => resolve(undefined), reject);\n                }\n            }, true);\n        });\n    }\n    async next(...args) {\n        this.signal?.throwIfAborted();\n        if (!this.firstResultUsed) {\n            this.firstResultUsed = true;\n            return this.firstResult;\n        }\n        return _singletons_index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton.runWithConfig(this.config, this.signal\n            ? async () => {\n                return (0,_signal_js__WEBPACK_IMPORTED_MODULE_1__.raceWithSignal)(this.generator.next(...args), this.signal);\n            }\n            : async () => {\n                return this.generator.next(...args);\n            }, true);\n    }\n    async return(value) {\n        return this.generator.return(value);\n    }\n    async throw(e) {\n        return this.generator.throw(e);\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Not present in Node 18 types, required in latest Node 22\n    async [Symbol.asyncDispose]() {\n        await this.return();\n    }\n}\nasync function pipeGeneratorWithSetup(to, generator, startSetup, signal, ...args) {\n    const gen = new AsyncGeneratorWithSetup({\n        generator,\n        startSetup,\n        signal,\n    });\n    const setup = await gen.setup;\n    return { output: to(gen, setup, ...args), setup };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTRFO0FBQy9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELHVDQUF1QztBQUN2QyxpQ0FBaUM7QUFDakM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCx1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1AsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxjQUFjLE1BQU0sY0FBYztBQUMzRTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvRkFBa0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvRkFBa0M7QUFDakQ7QUFDQSx1QkFBdUIsMERBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBc3VzXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxEZXNrdG9wXFxNeSBJbmZpbml0ZSBMb29wXFxJbmZpbml0ZV9sb29wXFxub2RlX21vZHVsZXNcXEBsYW5nY2hhaW5cXHRleHRzcGxpdHRlcnNcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcY29yZVxcZGlzdFxcdXRpbHNcXHN0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uIH0gZnJvbSBcIi4uL3NpbmdsZXRvbnMvaW5kZXguanNcIjtcbmltcG9ydCB7IHJhY2VXaXRoU2lnbmFsIH0gZnJvbSBcIi4vc2lnbmFsLmpzXCI7XG4vKlxuICogU3VwcG9ydCBhc3luYyBpdGVyYXRvciBzeW50YXggZm9yIFJlYWRhYmxlU3RyZWFtcyBpbiBhbGwgZW52aXJvbm1lbnRzLlxuICogU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vTWF0dGlhc0J1ZWxlbnMvd2ViLXN0cmVhbXMtcG9seWZpbGwvcHVsbC8xMjIjaXNzdWVjb21tZW50LTE2MjczNTQ0OTBcbiAqL1xuZXhwb3J0IGNsYXNzIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0gZXh0ZW5kcyBSZWFkYWJsZVN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlYWRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbnN1cmVSZWFkZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyID0gdGhpcy5nZXRSZWFkZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICB0aGlzLmVuc3VyZVJlYWRlcigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgY2xvc2VkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgZXJyb3JlZFxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZXR1cm4oKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVhZGVyKCk7XG4gICAgICAgIC8vIElmIHdyYXBwZWQgaW4gYSBOb2RlIHN0cmVhbSwgY2FuY2VsIGlzIGFscmVhZHkgY2FsbGVkLlxuICAgICAgICBpZiAodGhpcy5sb2NrZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSB0aGlzLnJlYWRlci5jYW5jZWwoKTsgLy8gY2FuY2VsIGZpcnN0LCBidXQgZG9uJ3QgYXdhaXQgeWV0XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgZmlyc3RcbiAgICAgICAgICAgIGF3YWl0IGNhbmNlbFByb21pc2U7IC8vIG5vdyBhd2FpdCBpdFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyB0aHJvdyhlKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVhZGVyKCk7XG4gICAgICAgIGlmICh0aGlzLmxvY2tlZCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IHRoaXMucmVhZGVyLmNhbmNlbCgpOyAvLyBjYW5jZWwgZmlyc3QsIGJ1dCBkb24ndCBhd2FpdCB5ZXRcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayBmaXJzdFxuICAgICAgICAgICAgYXdhaXQgY2FuY2VsUHJvbWlzZTsgLy8gbm93IGF3YWl0IGl0XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlIE5vdCBwcmVzZW50IGluIE5vZGUgMTggdHlwZXMsIHJlcXVpcmVkIGluIGxhdGVzdCBOb2RlIDIyXG4gICAgYXN5bmMgW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJldHVybigpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICAvLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdHJlYW1zX0FQSS9Vc2luZ19yZWFkYWJsZV9zdHJlYW1zI3JlYWRpbmdfdGhlX3N0cmVhbVxuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwdW1wKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQoKS50aGVuKCh7IGRvbmUsIHZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gbm8gbW9yZSBkYXRhIG5lZWRzIHRvIGJlIGNvbnN1bWVkLCBjbG9zZSB0aGUgc3RyZWFtXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnF1ZXVlIHRoZSBuZXh0IGRhdGEgY2h1bmsgaW50byBvdXIgdGFyZ2V0IHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Bc3luY0dlbmVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGdlbmVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBubyBtb3JlIGRhdGEgbmVlZHMgdG8gYmUgY29uc3VtZWQsIGNsb3NlIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpeDogYGVsc2UgaWYgKHZhbHVlKWAgd2lsbCBoYW5nIHRoZSBzdHJlYW1pbmcgd2hlbiBudWxsaXNoIHZhbHVlIChlLmcuIGVtcHR5IHN0cmluZykgaXMgcHVsbGVkXG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyBjYW5jZWwocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZ2VuZXJhdG9yLnJldHVybihyZWFzb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGF0ZWUoaXRlciwgbGVuZ3RoID0gMikge1xuICAgIGNvbnN0IGJ1ZmZlcnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sICgpID0+IFtdKTtcbiAgICByZXR1cm4gYnVmZmVycy5tYXAoYXN5bmMgZnVuY3Rpb24qIG1ha2VJdGVyKGJ1ZmZlcikge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpdGVyLm5leHQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiBidWZmZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYnVmZmVyWzBdLmRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIHlpZWxkIGJ1ZmZlci5zaGlmdCgpLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KGZpcnN0LCBzZWNvbmQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaXJzdCkgJiYgQXJyYXkuaXNBcnJheShzZWNvbmQpKSB7XG4gICAgICAgIHJldHVybiBmaXJzdC5jb25jYXQoc2Vjb25kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZpcnN0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBzZWNvbmQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIChmaXJzdCArIHNlY29uZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2Ygc2Vjb25kID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiAoZmlyc3QgKyBzZWNvbmQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIFwiY29uY2F0XCIgaW4gZmlyc3QgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgdHlwZW9mIGZpcnN0LmNvbmNhdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBmaXJzdC5jb25jYXQoc2Vjb25kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZpcnN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBzZWNvbmQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgY2h1bmsgPSB7IC4uLmZpcnN0IH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNlY29uZCkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gY2h1bmsgJiYgIUFycmF5LmlzQXJyYXkoY2h1bmtba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBjaHVua1trZXldID0gY29uY2F0KGNodW5rW2tleV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb25jYXQgJHt0eXBlb2YgZmlyc3R9IGFuZCAke3R5cGVvZiBzZWNvbmR9YCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFzeW5jR2VuZXJhdG9yV2l0aFNldHVwIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2VuZXJhdG9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldHVwXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmZpZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaWduYWxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmlyc3RSZXN1bHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmlyc3RSZXN1bHRVc2VkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBwYXJhbXMuZ2VuZXJhdG9yO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHBhcmFtcy5jb25maWc7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHRoaXMuc2lnbmFsID0gcGFyYW1zLnNpZ25hbCA/PyB0aGlzLmNvbmZpZz8uc2lnbmFsO1xuICAgICAgICAvLyBzZXR1cCBpcyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvbmx5IGFmdGVyIHRoZSBmaXJzdCBpdGVyYXRvciB2YWx1ZVxuICAgICAgICAvLyBpcyBhdmFpbGFibGUuIHRoaXMgaXMgdXNlZnVsIHdoZW4gc2V0dXAgb2Ygc2V2ZXJhbCBwaXBlZCBnZW5lcmF0b3JzXG4gICAgICAgIC8vIG5lZWRzIHRvIGhhcHBlbiBpbiBsb2dpY2FsIG9yZGVyLCBpZS4gaW4gdGhlIG9yZGVyIGluIHdoaWNoIGlucHV0IHRvXG4gICAgICAgIC8vIHRvIGVhY2ggZ2VuZXJhdG9yIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgdGhpcy5zZXR1cCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZvaWQgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKHBhcmFtcy5jb25maWcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0UmVzdWx0ID0gcGFyYW1zLmdlbmVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5zdGFydFNldHVwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RSZXN1bHQudGhlbihwYXJhbXMuc3RhcnRTZXR1cCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJzdFJlc3VsdC50aGVuKChfcmVzdWx0KSA9PiByZXNvbHZlKHVuZGVmaW5lZCksIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBuZXh0KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgIGlmICghdGhpcy5maXJzdFJlc3VsdFVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RSZXN1bHRVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0UmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLnJ1bldpdGhDb25maWcodGhpcy5jb25maWcsIHRoaXMuc2lnbmFsXG4gICAgICAgICAgICA/IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFjZVdpdGhTaWduYWwodGhpcy5nZW5lcmF0b3IubmV4dCguLi5hcmdzKSwgdGhpcy5zaWduYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdG9yLm5leHQoLi4uYXJncyk7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICB9XG4gICAgYXN5bmMgcmV0dXJuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRvci5yZXR1cm4odmFsdWUpO1xuICAgIH1cbiAgICBhc3luYyB0aHJvdyhlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRvci50aHJvdyhlKTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlIE5vdCBwcmVzZW50IGluIE5vZGUgMTggdHlwZXMsIHJlcXVpcmVkIGluIGxhdGVzdCBOb2RlIDIyXG4gICAgYXN5bmMgW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJldHVybigpO1xuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwaXBlR2VuZXJhdG9yV2l0aFNldHVwKHRvLCBnZW5lcmF0b3IsIHN0YXJ0U2V0dXAsIHNpZ25hbCwgLi4uYXJncykge1xuICAgIGNvbnN0IGdlbiA9IG5ldyBBc3luY0dlbmVyYXRvcldpdGhTZXR1cCh7XG4gICAgICAgIGdlbmVyYXRvcixcbiAgICAgICAgc3RhcnRTZXR1cCxcbiAgICAgICAgc2lnbmFsLFxuICAgIH0pO1xuICAgIGNvbnN0IHNldHVwID0gYXdhaXQgZ2VuLnNldHVwO1xuICAgIHJldHVybiB7IG91dHB1dDogdG8oZ2VuLCBzZXR1cCwgLi4uYXJncyksIHNldHVwIH07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/stream.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/tiktoken.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/tiktoken.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodingForModel: () => (/* binding */ encodingForModel),\n/* harmony export */   getEncoding: () => (/* binding */ getEncoding)\n/* harmony export */ });\n/* harmony import */ var js_tiktoken_lite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-tiktoken/lite */ \"(action-browser)/./node_modules/js-tiktoken/dist/lite.js\");\n/* harmony import */ var _async_caller_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./async_caller.js */ \"(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/async_caller.js\");\n\n\nconst cache = {};\nconst caller = /* #__PURE__ */ new _async_caller_js__WEBPACK_IMPORTED_MODULE_1__.AsyncCaller({});\nasync function getEncoding(encoding) {\n    if (!(encoding in cache)) {\n        cache[encoding] = caller\n            .fetch(`https://tiktoken.pages.dev/js/${encoding}.json`)\n            .then((res) => res.json())\n            .then((data) => new js_tiktoken_lite__WEBPACK_IMPORTED_MODULE_0__.Tiktoken(data))\n            .catch((e) => {\n            delete cache[encoding];\n            throw e;\n        });\n    }\n    return await cache[encoding];\n}\nasync function encodingForModel(model) {\n    return getEncoding((0,js_tiktoken_lite__WEBPACK_IMPORTED_MODULE_0__.getEncodingNameForModel)(model));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL3Rpa3Rva2VuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0U7QUFDdEI7QUFDaEQ7QUFDQSxtQ0FBbUMseURBQVcsR0FBRztBQUMxQztBQUNQO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBLGdDQUFnQyxzREFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ087QUFDUCx1QkFBdUIseUVBQXVCO0FBQzlDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcdGV4dHNwbGl0dGVyc1xcbm9kZV9tb2R1bGVzXFxAbGFuZ2NoYWluXFxjb3JlXFxkaXN0XFx1dGlsc1xcdGlrdG9rZW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGlrdG9rZW4sIGdldEVuY29kaW5nTmFtZUZvck1vZGVsLCB9IGZyb20gXCJqcy10aWt0b2tlbi9saXRlXCI7XG5pbXBvcnQgeyBBc3luY0NhbGxlciB9IGZyb20gXCIuL2FzeW5jX2NhbGxlci5qc1wiO1xuY29uc3QgY2FjaGUgPSB7fTtcbmNvbnN0IGNhbGxlciA9IC8qICNfX1BVUkVfXyAqLyBuZXcgQXN5bmNDYWxsZXIoe30pO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEVuY29kaW5nKGVuY29kaW5nKSB7XG4gICAgaWYgKCEoZW5jb2RpbmcgaW4gY2FjaGUpKSB7XG4gICAgICAgIGNhY2hlW2VuY29kaW5nXSA9IGNhbGxlclxuICAgICAgICAgICAgLmZldGNoKGBodHRwczovL3Rpa3Rva2VuLnBhZ2VzLmRldi9qcy8ke2VuY29kaW5nfS5qc29uYClcbiAgICAgICAgICAgIC50aGVuKChyZXMpID0+IHJlcy5qc29uKCkpXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4gbmV3IFRpa3Rva2VuKGRhdGEpKVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgY2FjaGVbZW5jb2RpbmddO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBjYWNoZVtlbmNvZGluZ107XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5jb2RpbmdGb3JNb2RlbChtb2RlbCkge1xuICAgIHJldHVybiBnZXRFbmNvZGluZyhnZXRFbmNvZGluZ05hbWVGb3JNb2RlbChtb2RlbCkpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/tiktoken.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/documents.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/documents.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseDocumentTransformer: () => (/* reexport safe */ _dist_documents_index_js__WEBPACK_IMPORTED_MODULE_0__.BaseDocumentTransformer),
/* harmony export */   Document: () => (/* reexport safe */ _dist_documents_index_js__WEBPACK_IMPORTED_MODULE_0__.Document),
/* harmony export */   MappingDocumentTransformer: () => (/* reexport safe */ _dist_documents_index_js__WEBPACK_IMPORTED_MODULE_0__.MappingDocumentTransformer)
/* harmony export */ });
/* harmony import */ var _dist_documents_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/documents/index.js */ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/documents/index.js");


/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/utils/tiktoken.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/@langchain/core/utils/tiktoken.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   encodingForModel: () => (/* reexport safe */ _dist_utils_tiktoken_js__WEBPACK_IMPORTED_MODULE_0__.encodingForModel),
/* harmony export */   getEncoding: () => (/* reexport safe */ _dist_utils_tiktoken_js__WEBPACK_IMPORTED_MODULE_0__.getEncoding)
/* harmony export */ });
/* harmony import */ var _dist_utils_tiktoken_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/utils/tiktoken.js */ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/@langchain/core/dist/utils/tiktoken.js");


/***/ }),

/***/ "(action-browser)/./node_modules/@langchain/textsplitters/node_modules/ansi-styles/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@langchain/textsplitters/node_modules/ansi-styles/index.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nconst ANSI_BACKGROUND_OFFSET = 10;\n\nconst wrapAnsi256 = (offset = 0) => code => `\\u001B[${38 + offset};5;${code}m`;\n\nconst wrapAnsi16m = (offset = 0) => (red, green, blue) => `\\u001B[${38 + offset};2;${red};${green};${blue}m`;\n\nfunction assembleStyles() {\n\tconst codes = new Map();\n\tconst styles = {\n\t\tmodifier: {\n\t\t\treset: [0, 0],\n\t\t\t// 21 isn't widely supported and 22 does the same thing\n\t\t\tbold: [1, 22],\n\t\t\tdim: [2, 22],\n\t\t\titalic: [3, 23],\n\t\t\tunderline: [4, 24],\n\t\t\toverline: [53, 55],\n\t\t\tinverse: [7, 27],\n\t\t\thidden: [8, 28],\n\t\t\tstrikethrough: [9, 29]\n\t\t},\n\t\tcolor: {\n\t\t\tblack: [30, 39],\n\t\t\tred: [31, 39],\n\t\t\tgreen: [32, 39],\n\t\t\tyellow: [33, 39],\n\t\t\tblue: [34, 39],\n\t\t\tmagenta: [35, 39],\n\t\t\tcyan: [36, 39],\n\t\t\twhite: [37, 39],\n\n\t\t\t// Bright color\n\t\t\tblackBright: [90, 39],\n\t\t\tredBright: [91, 39],\n\t\t\tgreenBright: [92, 39],\n\t\t\tyellowBright: [93, 39],\n\t\t\tblueBright: [94, 39],\n\t\t\tmagentaBright: [95, 39],\n\t\t\tcyanBright: [96, 39],\n\t\t\twhiteBright: [97, 39]\n\t\t},\n\t\tbgColor: {\n\t\t\tbgBlack: [40, 49],\n\t\t\tbgRed: [41, 49],\n\t\t\tbgGreen: [42, 49],\n\t\t\tbgYellow: [43, 49],\n\t\t\tbgBlue: [44, 49],\n\t\t\tbgMagenta: [45, 49],\n\t\t\tbgCyan: [46, 49],\n\t\t\tbgWhite: [47, 49],\n\n\t\t\t// Bright color\n\t\t\tbgBlackBright: [100, 49],\n\t\t\tbgRedBright: [101, 49],\n\t\t\tbgGreenBright: [102, 49],\n\t\t\tbgYellowBright: [103, 49],\n\t\t\tbgBlueBright: [104, 49],\n\t\t\tbgMagentaBright: [105, 49],\n\t\t\tbgCyanBright: [106, 49],\n\t\t\tbgWhiteBright: [107, 49]\n\t\t}\n\t};\n\n\t// Alias bright black as gray (and grey)\n\tstyles.color.gray = styles.color.blackBright;\n\tstyles.bgColor.bgGray = styles.bgColor.bgBlackBright;\n\tstyles.color.grey = styles.color.blackBright;\n\tstyles.bgColor.bgGrey = styles.bgColor.bgBlackBright;\n\n\tfor (const [groupName, group] of Object.entries(styles)) {\n\t\tfor (const [styleName, style] of Object.entries(group)) {\n\t\t\tstyles[styleName] = {\n\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\tclose: `\\u001B[${style[1]}m`\n\t\t\t};\n\n\t\t\tgroup[styleName] = styles[styleName];\n\n\t\t\tcodes.set(style[0], style[1]);\n\t\t}\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false\n\t\t});\n\t}\n\n\tObject.defineProperty(styles, 'codes', {\n\t\tvalue: codes,\n\t\tenumerable: false\n\t});\n\n\tstyles.color.close = '\\u001B[39m';\n\tstyles.bgColor.close = '\\u001B[49m';\n\n\tstyles.color.ansi256 = wrapAnsi256();\n\tstyles.color.ansi16m = wrapAnsi16m();\n\tstyles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);\n\tstyles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);\n\n\t// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js\n\tObject.defineProperties(styles, {\n\t\trgbToAnsi256: {\n\t\t\tvalue: (red, green, blue) => {\n\t\t\t\t// We use the extended greyscale palette here, with the exception of\n\t\t\t\t// black and white. normal palette only has 4 greyscale shades.\n\t\t\t\tif (red === green && green === blue) {\n\t\t\t\t\tif (red < 8) {\n\t\t\t\t\t\treturn 16;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (red > 248) {\n\t\t\t\t\t\treturn 231;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Math.round(((red - 8) / 247) * 24) + 232;\n\t\t\t\t}\n\n\t\t\t\treturn 16 +\n\t\t\t\t\t(36 * Math.round(red / 255 * 5)) +\n\t\t\t\t\t(6 * Math.round(green / 255 * 5)) +\n\t\t\t\t\tMath.round(blue / 255 * 5);\n\t\t\t},\n\t\t\tenumerable: false\n\t\t},\n\t\thexToRgb: {\n\t\t\tvalue: hex => {\n\t\t\t\tconst matches = /(?<colorString>[a-f\\d]{6}|[a-f\\d]{3})/i.exec(hex.toString(16));\n\t\t\t\tif (!matches) {\n\t\t\t\t\treturn [0, 0, 0];\n\t\t\t\t}\n\n\t\t\t\tlet {colorString} = matches.groups;\n\n\t\t\t\tif (colorString.length === 3) {\n\t\t\t\t\tcolorString = colorString.split('').map(character => character + character).join('');\n\t\t\t\t}\n\n\t\t\t\tconst integer = Number.parseInt(colorString, 16);\n\n\t\t\t\treturn [\n\t\t\t\t\t(integer >> 16) & 0xFF,\n\t\t\t\t\t(integer >> 8) & 0xFF,\n\t\t\t\t\tinteger & 0xFF\n\t\t\t\t];\n\t\t\t},\n\t\t\tenumerable: false\n\t\t},\n\t\thexToAnsi256: {\n\t\t\tvalue: hex => styles.rgbToAnsi256(...styles.hexToRgb(hex)),\n\t\t\tenumerable: false\n\t\t}\n\t});\n\n\treturn styles;\n}\n\n// Make the export immutable\nObject.defineProperty(module, 'exports', {\n\tenumerable: true,\n\tget: assembleStyles\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL3RleHRzcGxpdHRlcnMvbm9kZV9tb2R1bGVzL2Fuc2ktc3R5bGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBYTs7QUFFYjs7QUFFQSxzREFBc0QsYUFBYSxFQUFFLEVBQUUsS0FBSzs7QUFFNUUsb0VBQW9FLGFBQWEsRUFBRSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsS0FBSzs7QUFFMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0IscUJBQXFCLFNBQVM7QUFDOUI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0Q0FBNEMsRUFBRSxTQUFTLEVBQUU7QUFDekQ7QUFDQTtBQUNBOztBQUVBLFNBQVMsYUFBYTs7QUFFdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFzdXNcXE9uZURyaXZlXFxEb2N1bWVudHNcXERlc2t0b3BcXE15IEluZmluaXRlIExvb3BcXEluZmluaXRlX2xvb3BcXG5vZGVfbW9kdWxlc1xcQGxhbmdjaGFpblxcdGV4dHNwbGl0dGVyc1xcbm9kZV9tb2R1bGVzXFxhbnNpLXN0eWxlc1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBTlNJX0JBQ0tHUk9VTkRfT0ZGU0VUID0gMTA7XG5cbmNvbnN0IHdyYXBBbnNpMjU2ID0gKG9mZnNldCA9IDApID0+IGNvZGUgPT4gYFxcdTAwMUJbJHszOCArIG9mZnNldH07NTske2NvZGV9bWA7XG5cbmNvbnN0IHdyYXBBbnNpMTZtID0gKG9mZnNldCA9IDApID0+IChyZWQsIGdyZWVuLCBibHVlKSA9PiBgXFx1MDAxQlskezM4ICsgb2Zmc2V0fTsyOyR7cmVkfTske2dyZWVufTske2JsdWV9bWA7XG5cbmZ1bmN0aW9uIGFzc2VtYmxlU3R5bGVzKCkge1xuXHRjb25zdCBjb2RlcyA9IG5ldyBNYXAoKTtcblx0Y29uc3Qgc3R5bGVzID0ge1xuXHRcdG1vZGlmaWVyOiB7XG5cdFx0XHRyZXNldDogWzAsIDBdLFxuXHRcdFx0Ly8gMjEgaXNuJ3Qgd2lkZWx5IHN1cHBvcnRlZCBhbmQgMjIgZG9lcyB0aGUgc2FtZSB0aGluZ1xuXHRcdFx0Ym9sZDogWzEsIDIyXSxcblx0XHRcdGRpbTogWzIsIDIyXSxcblx0XHRcdGl0YWxpYzogWzMsIDIzXSxcblx0XHRcdHVuZGVybGluZTogWzQsIDI0XSxcblx0XHRcdG92ZXJsaW5lOiBbNTMsIDU1XSxcblx0XHRcdGludmVyc2U6IFs3LCAyN10sXG5cdFx0XHRoaWRkZW46IFs4LCAyOF0sXG5cdFx0XHRzdHJpa2V0aHJvdWdoOiBbOSwgMjldXG5cdFx0fSxcblx0XHRjb2xvcjoge1xuXHRcdFx0YmxhY2s6IFszMCwgMzldLFxuXHRcdFx0cmVkOiBbMzEsIDM5XSxcblx0XHRcdGdyZWVuOiBbMzIsIDM5XSxcblx0XHRcdHllbGxvdzogWzMzLCAzOV0sXG5cdFx0XHRibHVlOiBbMzQsIDM5XSxcblx0XHRcdG1hZ2VudGE6IFszNSwgMzldLFxuXHRcdFx0Y3lhbjogWzM2LCAzOV0sXG5cdFx0XHR3aGl0ZTogWzM3LCAzOV0sXG5cblx0XHRcdC8vIEJyaWdodCBjb2xvclxuXHRcdFx0YmxhY2tCcmlnaHQ6IFs5MCwgMzldLFxuXHRcdFx0cmVkQnJpZ2h0OiBbOTEsIDM5XSxcblx0XHRcdGdyZWVuQnJpZ2h0OiBbOTIsIDM5XSxcblx0XHRcdHllbGxvd0JyaWdodDogWzkzLCAzOV0sXG5cdFx0XHRibHVlQnJpZ2h0OiBbOTQsIDM5XSxcblx0XHRcdG1hZ2VudGFCcmlnaHQ6IFs5NSwgMzldLFxuXHRcdFx0Y3lhbkJyaWdodDogWzk2LCAzOV0sXG5cdFx0XHR3aGl0ZUJyaWdodDogWzk3LCAzOV1cblx0XHR9LFxuXHRcdGJnQ29sb3I6IHtcblx0XHRcdGJnQmxhY2s6IFs0MCwgNDldLFxuXHRcdFx0YmdSZWQ6IFs0MSwgNDldLFxuXHRcdFx0YmdHcmVlbjogWzQyLCA0OV0sXG5cdFx0XHRiZ1llbGxvdzogWzQzLCA0OV0sXG5cdFx0XHRiZ0JsdWU6IFs0NCwgNDldLFxuXHRcdFx0YmdNYWdlbnRhOiBbNDUsIDQ5XSxcblx0XHRcdGJnQ3lhbjogWzQ2LCA0OV0sXG5cdFx0XHRiZ1doaXRlOiBbNDcsIDQ5XSxcblxuXHRcdFx0Ly8gQnJpZ2h0IGNvbG9yXG5cdFx0XHRiZ0JsYWNrQnJpZ2h0OiBbMTAwLCA0OV0sXG5cdFx0XHRiZ1JlZEJyaWdodDogWzEwMSwgNDldLFxuXHRcdFx0YmdHcmVlbkJyaWdodDogWzEwMiwgNDldLFxuXHRcdFx0YmdZZWxsb3dCcmlnaHQ6IFsxMDMsIDQ5XSxcblx0XHRcdGJnQmx1ZUJyaWdodDogWzEwNCwgNDldLFxuXHRcdFx0YmdNYWdlbnRhQnJpZ2h0OiBbMTA1LCA0OV0sXG5cdFx0XHRiZ0N5YW5CcmlnaHQ6IFsxMDYsIDQ5XSxcblx0XHRcdGJnV2hpdGVCcmlnaHQ6IFsxMDcsIDQ5XVxuXHRcdH1cblx0fTtcblxuXHQvLyBBbGlhcyBicmlnaHQgYmxhY2sgYXMgZ3JheSAoYW5kIGdyZXkpXG5cdHN0eWxlcy5jb2xvci5ncmF5ID0gc3R5bGVzLmNvbG9yLmJsYWNrQnJpZ2h0O1xuXHRzdHlsZXMuYmdDb2xvci5iZ0dyYXkgPSBzdHlsZXMuYmdDb2xvci5iZ0JsYWNrQnJpZ2h0O1xuXHRzdHlsZXMuY29sb3IuZ3JleSA9IHN0eWxlcy5jb2xvci5ibGFja0JyaWdodDtcblx0c3R5bGVzLmJnQ29sb3IuYmdHcmV5ID0gc3R5bGVzLmJnQ29sb3IuYmdCbGFja0JyaWdodDtcblxuXHRmb3IgKGNvbnN0IFtncm91cE5hbWUsIGdyb3VwXSBvZiBPYmplY3QuZW50cmllcyhzdHlsZXMpKSB7XG5cdFx0Zm9yIChjb25zdCBbc3R5bGVOYW1lLCBzdHlsZV0gb2YgT2JqZWN0LmVudHJpZXMoZ3JvdXApKSB7XG5cdFx0XHRzdHlsZXNbc3R5bGVOYW1lXSA9IHtcblx0XHRcdFx0b3BlbjogYFxcdTAwMUJbJHtzdHlsZVswXX1tYCxcblx0XHRcdFx0Y2xvc2U6IGBcXHUwMDFCWyR7c3R5bGVbMV19bWBcblx0XHRcdH07XG5cblx0XHRcdGdyb3VwW3N0eWxlTmFtZV0gPSBzdHlsZXNbc3R5bGVOYW1lXTtcblxuXHRcdFx0Y29kZXMuc2V0KHN0eWxlWzBdLCBzdHlsZVsxXSk7XG5cdFx0fVxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHN0eWxlcywgZ3JvdXBOYW1lLCB7XG5cdFx0XHR2YWx1ZTogZ3JvdXAsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZVxuXHRcdH0pO1xuXHR9XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHN0eWxlcywgJ2NvZGVzJywge1xuXHRcdHZhbHVlOiBjb2Rlcyxcblx0XHRlbnVtZXJhYmxlOiBmYWxzZVxuXHR9KTtcblxuXHRzdHlsZXMuY29sb3IuY2xvc2UgPSAnXFx1MDAxQlszOW0nO1xuXHRzdHlsZXMuYmdDb2xvci5jbG9zZSA9ICdcXHUwMDFCWzQ5bSc7XG5cblx0c3R5bGVzLmNvbG9yLmFuc2kyNTYgPSB3cmFwQW5zaTI1NigpO1xuXHRzdHlsZXMuY29sb3IuYW5zaTE2bSA9IHdyYXBBbnNpMTZtKCk7XG5cdHN0eWxlcy5iZ0NvbG9yLmFuc2kyNTYgPSB3cmFwQW5zaTI1NihBTlNJX0JBQ0tHUk9VTkRfT0ZGU0VUKTtcblx0c3R5bGVzLmJnQ29sb3IuYW5zaTE2bSA9IHdyYXBBbnNpMTZtKEFOU0lfQkFDS0dST1VORF9PRkZTRVQpO1xuXG5cdC8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL1FpeC0vY29sb3ItY29udmVydC9ibG9iLzNmMGUwZDRlOTJlMjM1Nzk2Y2NiMTdmNmU4NWM3MjA5NGE2NTFmNDkvY29udmVyc2lvbnMuanNcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3R5bGVzLCB7XG5cdFx0cmdiVG9BbnNpMjU2OiB7XG5cdFx0XHR2YWx1ZTogKHJlZCwgZ3JlZW4sIGJsdWUpID0+IHtcblx0XHRcdFx0Ly8gV2UgdXNlIHRoZSBleHRlbmRlZCBncmV5c2NhbGUgcGFsZXR0ZSBoZXJlLCB3aXRoIHRoZSBleGNlcHRpb24gb2Zcblx0XHRcdFx0Ly8gYmxhY2sgYW5kIHdoaXRlLiBub3JtYWwgcGFsZXR0ZSBvbmx5IGhhcyA0IGdyZXlzY2FsZSBzaGFkZXMuXG5cdFx0XHRcdGlmIChyZWQgPT09IGdyZWVuICYmIGdyZWVuID09PSBibHVlKSB7XG5cdFx0XHRcdFx0aWYgKHJlZCA8IDgpIHtcblx0XHRcdFx0XHRcdHJldHVybiAxNjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAocmVkID4gMjQ4KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gMjMxO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCgocmVkIC0gOCkgLyAyNDcpICogMjQpICsgMjMyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIDE2ICtcblx0XHRcdFx0XHQoMzYgKiBNYXRoLnJvdW5kKHJlZCAvIDI1NSAqIDUpKSArXG5cdFx0XHRcdFx0KDYgKiBNYXRoLnJvdW5kKGdyZWVuIC8gMjU1ICogNSkpICtcblx0XHRcdFx0XHRNYXRoLnJvdW5kKGJsdWUgLyAyNTUgKiA1KTtcblx0XHRcdH0sXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZVxuXHRcdH0sXG5cdFx0aGV4VG9SZ2I6IHtcblx0XHRcdHZhbHVlOiBoZXggPT4ge1xuXHRcdFx0XHRjb25zdCBtYXRjaGVzID0gLyg/PGNvbG9yU3RyaW5nPlthLWZcXGRdezZ9fFthLWZcXGRdezN9KS9pLmV4ZWMoaGV4LnRvU3RyaW5nKDE2KSk7XG5cdFx0XHRcdGlmICghbWF0Y2hlcykge1xuXHRcdFx0XHRcdHJldHVybiBbMCwgMCwgMF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZXQge2NvbG9yU3RyaW5nfSA9IG1hdGNoZXMuZ3JvdXBzO1xuXG5cdFx0XHRcdGlmIChjb2xvclN0cmluZy5sZW5ndGggPT09IDMpIHtcblx0XHRcdFx0XHRjb2xvclN0cmluZyA9IGNvbG9yU3RyaW5nLnNwbGl0KCcnKS5tYXAoY2hhcmFjdGVyID0+IGNoYXJhY3RlciArIGNoYXJhY3Rlcikuam9pbignJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBpbnRlZ2VyID0gTnVtYmVyLnBhcnNlSW50KGNvbG9yU3RyaW5nLCAxNik7XG5cblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHQoaW50ZWdlciA+PiAxNikgJiAweEZGLFxuXHRcdFx0XHRcdChpbnRlZ2VyID4+IDgpICYgMHhGRixcblx0XHRcdFx0XHRpbnRlZ2VyICYgMHhGRlxuXHRcdFx0XHRdO1xuXHRcdFx0fSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fSxcblx0XHRoZXhUb0Fuc2kyNTY6IHtcblx0XHRcdHZhbHVlOiBoZXggPT4gc3R5bGVzLnJnYlRvQW5zaTI1NiguLi5zdHlsZXMuaGV4VG9SZ2IoaGV4KSksXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZVxuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuLy8gTWFrZSB0aGUgZXhwb3J0IGltbXV0YWJsZVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgJ2V4cG9ydHMnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogYXNzZW1ibGVTdHlsZXNcbn0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@langchain/textsplitters/node_modules/ansi-styles/index.js\n");

/***/ })

};
;